<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PACC: PACC::XML::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_c_c.html">PACC</a>::<a class="el" href="namespace_p_a_c_c_1_1_x_m_l.html">XML</a>::<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a>
  </div>
</div>
<div class="contents">
<h1>PACC::XML::Node Class Reference<br/>
<small>
[<a class="el" href="group___x_m_l.html">XML: eXtensible Markup Language</a>]</small>
</h1><!-- doxytag: class="PACC::XML::Node" --><!-- doxytag: inherits="PACC::XML::AttributeList" -->
<p>Node of the document tree.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_node_8hpp_source.html">Node.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PACC::XML::Node:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_p_a_c_c_1_1_x_m_l_1_1_node.gif" usemap="#PACC::XML::Node_map" alt=""/>
  <map id="PACC::XML::Node_map" name="PACC::XML::Node_map">
<area href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html" alt="PACC::XML::AttributeList" shape="rect" coords="162,0,314,24"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_primitive.html" alt="PACC::SVG::Primitive" shape="rect" coords="0,112,152,136"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_text_1_1_span.html" alt="PACC::SVG::Text::Span" shape="rect" coords="162,112,314,136"/>
<area href="class_p_a_c_c_1_1_x_m_l_1_1_document.html" alt="PACC::XML::Document" shape="rect" coords="324,112,476,136"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_circle.html" alt="PACC::SVG::Circle" shape="rect" coords="162,168,314,192"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_ellipse.html" alt="PACC::SVG::Ellipse" shape="rect" coords="162,224,314,248"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_group.html" alt="PACC::SVG::Group" shape="rect" coords="162,280,314,304"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_line.html" alt="PACC::SVG::Line" shape="rect" coords="162,336,314,360"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_path.html" alt="PACC::SVG::Path" shape="rect" coords="162,392,314,416"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_polygon.html" alt="PACC::SVG::Polygon" shape="rect" coords="162,448,314,472"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_polyline.html" alt="PACC::SVG::Polyline" shape="rect" coords="162,504,314,528"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_rectangle.html" alt="PACC::SVG::Rectangle" shape="rect" coords="162,560,314,584"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_text.html" alt="PACC::SVG::Text" shape="rect" coords="162,616,314,640"/>
</map>
 </div>
</div>

<p><a href="class_p_a_c_c_1_1_x_m_l_1_1_node-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node_1_1_default_quotes.html">DefaultQuotes</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81cadd2778d4c444bb510fea1458fb0a"></a><!-- doxytag: member="PACC::XML::Node::Node" ref="a81cadd2778d4c444bb510fea1458fb0a" args="(void)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a">Node</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct empty root node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8693e9c791c620ecf5cf305b5fb05d15"></a><!-- doxytag: member="PACC::XML::Node::Node" ref="a8693e9c791c620ecf5cf305b5fb05d15" args="(const string &amp;inValue, NodeType inType=eData)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a8693e9c791c620ecf5cf305b5fb05d15">Node</a> (const string &amp;inValue, <a class="el" href="group___x_m_l.html#gaee55fe15d14e7ff7da9b834404055814">NodeType</a> inType=eData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct node of type <code>inType</code> (default NodeType::eTag) with value <code>inValue</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa80ddc08cb18c08e1ccf37157586d335"></a><!-- doxytag: member="PACC::XML::Node::Node" ref="aa80ddc08cb18c08e1ccf37157586d335" args="(const string &amp;inValue, const AttributeList &amp;inAttrList)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aa80ddc08cb18c08e1ccf37157586d335">Node</a> (const string &amp;inValue, const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html">AttributeList</a> &amp;inAttrList)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct node of type <code>eData</code> with value <code>inValue</code> and attribute list <code>inAttrList</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63b1297db057ffe3d85f57546fcbb20e"></a><!-- doxytag: member="PACC::XML::Node::Node" ref="a63b1297db057ffe3d85f57546fcbb20e" args="(const Node &amp;inNode)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a63b1297db057ffe3d85f57546fcbb20e">Node</a> (const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> &amp;inNode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor: make deep copy of node <code>inNode</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aeff3b3d351014ca9ff4fd1e12da9878d">~Node</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the sub-tree rooted by this node.  <a href="#aeff3b3d351014ca9ff4fd1e12da9878d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aba338919ad01b4a8c38bdba81dda0821">operator=</a> (const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make deep copy of the sub-tree rooted by node <code>inRoot</code>.  <a href="#aba338919ad01b4a8c38bdba81dda0821"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa47492f75a11e700e53b4e7dcd01a0b0"></a><!-- doxytag: member="PACC::XML::Node::getFirstChild" ref="aa47492f75a11e700e53b4e7dcd01a0b0" args="(void)" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aa47492f75a11e700e53b4e7dcd01a0b0">getFirstChild</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the first child of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95dd93d3a06147a92f77c5a5f56f8a22"></a><!-- doxytag: member="PACC::XML::Node::getFirstChild" ref="a95dd93d3a06147a92f77c5a5f56f8a22" args="(void) const " -->
const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a95dd93d3a06147a92f77c5a5f56f8a22">getFirstChild</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the first child of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5bf8372c00924e02c3de589711df78"></a><!-- doxytag: member="PACC::XML::Node::getLastChild" ref="aef5bf8372c00924e02c3de589711df78" args="(void)" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aef5bf8372c00924e02c3de589711df78">getLastChild</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the last child of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7d01c290df74876c6bcbea886f52272"></a><!-- doxytag: member="PACC::XML::Node::getLastChild" ref="ae7d01c290df74876c6bcbea886f52272" args="(void) const " -->
const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ae7d01c290df74876c6bcbea886f52272">getLastChild</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the last child of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c22b8f346fc140f6cf1e34fa1cde00f"></a><!-- doxytag: member="PACC::XML::Node::getNextSibling" ref="a2c22b8f346fc140f6cf1e34fa1cde00f" args="(void)" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a2c22b8f346fc140f6cf1e34fa1cde00f">getNextSibling</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the next sibling of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92daaae951611025c2e3d64ecf410fee"></a><!-- doxytag: member="PACC::XML::Node::getNextSibling" ref="a92daaae951611025c2e3d64ecf410fee" args="(void) const " -->
const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a92daaae951611025c2e3d64ecf410fee">getNextSibling</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the next sibling of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a858451add5961eb7decaf2681d15b005"></a><!-- doxytag: member="PACC::XML::Node::getPreviousSibling" ref="a858451add5961eb7decaf2681d15b005" args="(void)" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a858451add5961eb7decaf2681d15b005">getPreviousSibling</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the previous sibling of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25992d54090220bfec5885b910b667fd"></a><!-- doxytag: member="PACC::XML::Node::getPreviousSibling" ref="a25992d54090220bfec5885b910b667fd" args="(void) const " -->
const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a25992d54090220bfec5885b910b667fd">getPreviousSibling</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the previous sibling of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30412f746bfa2eb75a6954f28c3dc6f3"></a><!-- doxytag: member="PACC::XML::Node::getParent" ref="a30412f746bfa2eb75a6954f28c3dc6f3" args="(void)" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a30412f746bfa2eb75a6954f28c3dc6f3">getParent</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the parent of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c64699c563d9099e9a27a27d7bba12f"></a><!-- doxytag: member="PACC::XML::Node::getParent" ref="a5c64699c563d9099e9a27a27d7bba12f" args="(void) const " -->
const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5c64699c563d9099e9a27a27d7bba12f">getParent</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the parent of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0134728a999645cc6cf4d3351c5c96ac"></a><!-- doxytag: member="PACC::XML::Node::getType" ref="a0134728a999645cc6cf4d3351c5c96ac" args="(void) const " -->
const <a class="el" href="group___x_m_l.html#gaee55fe15d14e7ff7da9b834404055814">NodeType</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a0134728a999645cc6cf4d3351c5c96ac">getType</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the node type (see enum <a class="el" href="group___x_m_l.html#gaee55fe15d14e7ff7da9b834404055814" title="Types of parse tree node.">XML::NodeType</a>). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acff683537a292b3f8292f0299de53fb5"></a><!-- doxytag: member="PACC::XML::Node::getValue" ref="acff683537a292b3f8292f0299de53fb5" args="(void) const " -->
const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5">getValue</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the node value (tag name for NodeType::eData). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81c5eb0107f27467416ac62c6f91cc41"></a><!-- doxytag: member="PACC::XML::Node::setType" ref="a81c5eb0107f27467416ac62c6f91cc41" args="(NodeType inType)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81c5eb0107f27467416ac62c6f91cc41">setType</a> (<a class="el" href="group___x_m_l.html#gaee55fe15d14e7ff7da9b834404055814">NodeType</a> inType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the node type (see enum <a class="el" href="group___x_m_l.html#gaee55fe15d14e7ff7da9b834404055814" title="Types of parse tree node.">XML::NodeType</a>). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2153fdc8f84e00523857170075b31e6"></a><!-- doxytag: member="PACC::XML::Node::setValue" ref="ab2153fdc8f84e00523857170075b31e6" args="(const string &amp;inValue)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ab2153fdc8f84e00523857170075b31e6">setValue</a> (const string &amp;inValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set node value (tag name for nodes of type NodeType::eTag). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ac9c8db449859f59d210f8e84754b29e9">detachFromSiblingsAndParent</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach this node from its siblings and parent.  <a href="#ac9c8db449859f59d210f8e84754b29e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a180240fc70b60e6bd2762a70f274cb17"></a><!-- doxytag: member="PACC::XML::Node::eraseChildren" ref="a180240fc70b60e6bd2762a70f274cb17" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a180240fc70b60e6bd2762a70f274cb17">eraseChildren</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete all children. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aef491e4fa0310ca0a8ca435127a9a309">getChildCount</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of child nodes.  <a href="#aef491e4fa0310ca0a8ca435127a9a309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a0e68df0b3d1d51a01e6875d539616b68">insertAsLastChild</a> (<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *inChild)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node <code>inChild</code> after the last child of this node.  <a href="#a0e68df0b3d1d51a01e6875d539616b68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a3d4d55e56ae811162e70ba2c7d6c84c2">insertAsPreviousSibling</a> (<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *inSibling)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node <code>inSibling</code> as the sibling that preceeds this node.  <a href="#a3d4d55e56ae811162e70ba2c7d6c84c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ad4435832826f4874ee8b59be84267c75">serialize</a> (<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html">Streamer</a> &amp;outStream, bool inIndent=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialize this node into XML streamer <code>outStream</code>.  <a href="#ad4435832826f4874ee8b59be84267c75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94899740910da5eab24ff834c6088fd9"></a><!-- doxytag: member="PACC::XML::Node::operator+" ref="a94899740910da5eab24ff834c6088fd9" args="(const AttributeList &amp;inAttrList) const " -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html">AttributeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a94899740910da5eab24ff834c6088fd9">operator+</a> (const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html">AttributeList</a> &amp;inAttrList) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return concatenation of attribute list <code>inAttrList</code> with this list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a34d6a8adb75592e29528ba6a78e08c"></a><!-- doxytag: member="PACC::XML::Node::operator+=" ref="a2a34d6a8adb75592e29528ba6a78e08c" args="(const AttributeList &amp;inAttrList)" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html">AttributeList</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a2a34d6a8adb75592e29528ba6a78e08c">operator+=</a> (const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html">AttributeList</a> &amp;inAttrList)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append attribute list <code>inAttrList</code> to this list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa329c59996a8338d1097e2d51d598c13"></a><!-- doxytag: member="PACC::XML::Node::getAttribute" ref="aa329c59996a8338d1097e2d51d598c13" args="(const string &amp;inName) const " -->
const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa329c59996a8338d1097e2d51d598c13">getAttribute</a> (const string &amp;inName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value of attribute <code>inName</code>, or empty string if it doesn't exist. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa71362e83a9722288a8e4474aa2b7643"></a><!-- doxytag: member="PACC::XML::Node::isDefined" ref="aa71362e83a9722288a8e4474aa2b7643" args="(const std::string &amp;inName) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa71362e83a9722288a8e4474aa2b7643">isDefined</a> (const std::string &amp;inName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test wheter attribute name <code>inName</code> exists in this list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73fccd9ef0123d725ae77baaccb82d02"></a><!-- doxytag: member="PACC::XML::Node::removeAttribute" ref="a73fccd9ef0123d725ae77baaccb82d02" args="(const string &amp;inName)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a73fccd9ef0123d725ae77baaccb82d02">removeAttribute</a> (const string &amp;inName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove attribute name <code>inName</code> from this attribute list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70b83d7d50f2b40eb6656891cf7d8557"></a><!-- doxytag: member="PACC::XML::Node::setAttribute" ref="a70b83d7d50f2b40eb6656891cf7d8557" args="(const string &amp;inName, const string &amp;inValue)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a70b83d7d50f2b40eb6656891cf7d8557">setAttribute</a> (const string &amp;inName, const string &amp;inValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set attribute <code>inName</code> to value <code>inValue</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67cf0e34061ed93030d8d31d5cc18dc8"></a><!-- doxytag: member="PACC::XML::Node::setAttribute" ref="a67cf0e34061ed93030d8d31d5cc18dc8" args="(const string &amp;inName, double inValue)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a67cf0e34061ed93030d8d31d5cc18dc8">setAttribute</a> (const string &amp;inName, double inValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set attribute <code>inName</code> to value <code>inValue</code>. <br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a48493203d020c08ebbd44bd98f09d43c">parse</a> (<a class="el" href="class_p_a_c_c_1_1_tokenizer.html">Tokenizer</a> &amp;inTokenizer, const set&lt; string &gt; &amp;inNoParseTags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse next tag using stream tokenizer <code>inTokenizer</code>.  <a href="#a48493203d020c08ebbd44bd98f09d43c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ae3112e9f79d990cb581e97179496003d">parseAttributeList</a> (<a class="el" href="class_p_a_c_c_1_1_tokenizer.html">Tokenizer</a> &amp;inTokenizer, string &amp;outToken)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the attribute list using stream tokenizer <code>inTokenizer</code>.  <a href="#ae3112e9f79d990cb581e97179496003d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5610f5b7d3efb7d5f8914ca37e1ae241">parseStartTag</a> (<a class="el" href="class_p_a_c_c_1_1_tokenizer.html">Tokenizer</a> &amp;inTokenizer, string &amp;outToken)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse in stream tokenizer <code>inTokenizer</code> the start tag of this node.  <a href="#a5610f5b7d3efb7d5f8914ca37e1ae241"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff2e32b9e2cf9f330246f931762b6648"></a><!-- doxytag: member="PACC::XML::Node::readContentAsString" ref="aff2e32b9e2cf9f330246f931762b6648" args="(Tokenizer &amp;inTokenizer)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aff2e32b9e2cf9f330246f931762b6648">readContentAsString</a> (<a class="el" href="class_p_a_c_c_1_1_tokenizer.html">Tokenizer</a> &amp;inTokenizer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read in stream tokenizer <code>inTokenizer</code> the content of this node (current tag) as a single string (do not parse content). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97a9b5684ee34f60996ddb5686f40e86"></a><!-- doxytag: member="PACC::XML::Node::throwError" ref="a97a9b5684ee34f60996ddb5686f40e86" args="(Tokenizer &amp;inTokenizer, const string &amp;inMessage) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86">throwError</a> (<a class="el" href="class_p_a_c_c_1_1_tokenizer.html">Tokenizer</a> &amp;inTokenizer, const string &amp;inMessage) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throw runtime error with message <code>inMessage</code> using tokenizer <code>inTokenizer</code>. <br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5227d2bef95e7dda97f2b63d617a3724">convertFromQuotes</a> (string &amp;ioString, map&lt; string, char &gt; &amp;ioMap=<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ab29975ad2c53c213a03768b222c74669">smMap</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert basic xml quotes into ascii characters.  <a href="#a5227d2bef95e7dda97f2b63d617a3724"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb7445cdb7523a95a35ec8adc38bfed0"></a><!-- doxytag: member="PACC::XML::Node::mType" ref="abb7445cdb7523a95a35ec8adc38bfed0" args="" -->
<a class="el" href="group___x_m_l.html#gaee55fe15d14e7ff7da9b834404055814">NodeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0">mType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a216f93b39a91daca6aad1608195c477f"></a><!-- doxytag: member="PACC::XML::Node::mParent" ref="a216f93b39a91daca6aad1608195c477f" args="" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f">mParent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to parent node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5de69ebc4618625e8be3b626f0015d8e"></a><!-- doxytag: member="PACC::XML::Node::mFirstChild" ref="a5de69ebc4618625e8be3b626f0015d8e" args="" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5de69ebc4618625e8be3b626f0015d8e">mFirstChild</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to first child node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a877bbbcdb99e8d86fadf2f407827bc7e"></a><!-- doxytag: member="PACC::XML::Node::mLastChild" ref="a877bbbcdb99e8d86fadf2f407827bc7e" args="" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e">mLastChild</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to last child node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24b310a643deaa72ca39cf9b5c57f056"></a><!-- doxytag: member="PACC::XML::Node::mPrevSibling" ref="a24b310a643deaa72ca39cf9b5c57f056" args="" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056">mPrevSibling</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to previous sibling node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f583ab7607580c61ce035f28239004"></a><!-- doxytag: member="PACC::XML::Node::mNextSibling" ref="a04f583ab7607580c61ce035f28239004" args="" -->
<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004">mNextSibling</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to next sibling node. <br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab29975ad2c53c213a03768b222c74669"></a><!-- doxytag: member="PACC::XML::Node::smMap" ref="ab29975ad2c53c213a03768b222c74669" args="" -->
static <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node_1_1_default_quotes.html">DefaultQuotes</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ab29975ad2c53c213a03768b222c74669">smMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion map for translating quotes. <br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9830fc407400559db7e7783cc10a9394"></a><!-- doxytag: member="PACC::XML::Node::Iterator" ref="a9830fc407400559db7e7783cc10a9394" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5485970bb9da6b5d782fa28638b5658f"></a><!-- doxytag: member="PACC::XML::Node::ConstIterator" ref="a5485970bb9da6b5d782fa28638b5658f" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>ConstIterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a883538034e58fc5c0de7d4e4cab3cef7"></a><!-- doxytag: member="PACC::XML::Node::Document" ref="a883538034e58fc5c0de7d4e4cab3cef7" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Document</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Node of the document tree. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Marc Parizeau, Laboratoire de vision et syst&egrave;mes num&eacute;riques, Universit&eacute; Laval</dd></dl>
<p>A tree node represents an XML element. Method <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a0134728a999645cc6cf4d3351c5c96ac" title="Returns the node type (see enum XML::NodeType).">Node::getType</a> is used to retrieve the element type. This can be a regular data markup (<a class="el" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a62511869bb50207683e31806b802c576" title="Regular data markup element.">XML::eData</a>), an xml declaration (<a class="el" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a1349bbd6e6b8571961f80800dc3059eb" title="XML declaration (&lt;?xml ... ?&gt;).">XML::eDecl</a>), a processing instruction (<a class="el" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814ac2833f6aa343cf425ab0f4aede27c73f" title="Processing instruction (&lt;? ... ?&gt;).">XML::ePI</a>), a comment (<a class="el" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814aca7d2f335cd554b1c57bc9c0a44cd46d" title="Comment ().">XML::eComment</a>), a CDATA section (<a class="el" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a3af269fb25b96d387de378e0249c4fa9" title="CDATA section (&lt;![CDATA[ ... ]]&gt;).">XML::eCDATA</a>), a special element for document type declaration (<a class="el" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a4a0d08873453878b747a733b33ee4f81" title="Special element (&lt;! ... &gt;).">XML::eSpecial</a>), or a literal string (<a class="el" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a02125ab9eed124fe7ff63344f2f3c507" title="Literal string.">XML::eString</a>). Method <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">Node::getValue</a> is used to retrieve different values depending on the node type. For regular markups, this method returns the tag name. For comments, CDATA sections, processing instructions, and other special elements, it returns the literal string of these elements. For the xml declaration, it simply returns "xml". It should be noted that internal DTDs are not supported by the parser (document type nodes cannot embed other nodes).</p>
<p>Markup data elements can have content represented by child nodes. A <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html" title="Node of the document tree.">Node</a> can parse itself from a stream <a class="el" href="class_p_a_c_c_1_1_tokenizer.html" title="Input stream tokenizer.">Tokenizer</a>. Any parse error throws a <code>runtime_error</code> exception. Method <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aa47492f75a11e700e53b4e7dcd01a0b0" title="Return an iterator pointing to the first child of this node.">Node::getFirstChild</a> is used to retrieve an <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_iterator.html" title="Node iterator.">Iterator</a> on the first child of this node. Method <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a30412f746bfa2eb75a6954f28c3dc6f3" title="Return an iterator pointing to the parent of this node.">Node::getParent</a> is used to retrieve an <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_iterator.html" title="Node iterator.">Iterator</a> on the parent of this node. An <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_iterator.html" title="Node iterator.">Iterator</a> is used to iterate on sibling nodes.</p>
<p>Nodes are also derived from a map of attribute name/value pairs that can be fetched and set using methods <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa329c59996a8338d1097e2d51d598c13" title="Return value of attribute inName, or empty string if it doesn&#39;t exist.">Node::getAttribute</a> and <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a70b83d7d50f2b40eb6656891cf7d8557" title="Set attribute inName to value inValue.">Node::setAttribute</a>. Finally, a node can serialize itself into an XML <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html" title="Simple document streamer.">Streamer</a>. </p>

<p>Definition at line <a class="el" href="_node_8hpp_source.html#l00083">83</a> of file <a class="el" href="_node_8hpp_source.html">Node.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeff3b3d351014ca9ff4fd1e12da9878d"></a><!-- doxytag: member="PACC::XML::Node::~Node" ref="aeff3b3d351014ca9ff4fd1e12da9878d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XML::Node::~Node </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the sub-tree rooted by this node. </p>
<p>This method recursively deletes all of its children. </p>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00079">79</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00079"></a>00079                    {
<a name="l00080"></a>00080     <span class="comment">// delete all child nodes</span>
<a name="l00081"></a>00081     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a180240fc70b60e6bd2762a70f274cb17" title="Delete all children.">eraseChildren</a>();
<a name="l00082"></a>00082     <span class="comment">// detach from parent and siblings</span>
<a name="l00083"></a>00083     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ac9c8db449859f59d210f8e84754b29e9" title="Detach this node from its siblings and parent.">detachFromSiblingsAndParent</a>();
<a name="l00084"></a>00084     <span class="comment">// cleanup node pointers</span>
<a name="l00085"></a>00085     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5de69ebc4618625e8be3b626f0015d8e" title="Pointer to first child node.">mFirstChild</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a> = NULL;
<a name="l00086"></a>00086 }
</pre></div></p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5227d2bef95e7dda97f2b63d617a3724"></a><!-- doxytag: member="PACC::XML::Node::convertFromQuotes" ref="a5227d2bef95e7dda97f2b63d617a3724" args="(string &amp;ioString, map&lt; string, char &gt; &amp;ioMap=smMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string &amp; XML::Node::convertFromQuotes </td>
          <td>(</td>
          <td class="paramtype">string &amp;&nbsp;</td>
          <td class="paramname"> <em>ioString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ioMap</em> = <code><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ab29975ad2c53c213a03768b222c74669">smMap</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert basic xml quotes into ascii characters. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the converted string. The default quotes are "&amp;amp;", "&amp;lt;", "&amp;gt;", "&amp;apos;", and "&amp;quot;". Argument <code>ioMap</code> can be used to specify any conversion table. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00137">137</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00138"></a>00138 {
<a name="l00139"></a>00139     string::size_type lStart, lEnd = 0;
<a name="l00140"></a>00140     <span class="keywordflow">while</span>((lStart = ioString.find(<span class="charliteral">&apos;&amp;&apos;</span>, lEnd)) &lt; ioString.size() &amp;&amp; 
<a name="l00141"></a>00141                 (lEnd = ioString.find(<span class="charliteral">&apos;;&apos;</span>, lStart)) &lt; ioString.size())
<a name="l00142"></a>00142     {
<a name="l00143"></a>00143         <span class="keywordtype">string</span> lToken = ioString.substr(lStart+1, lEnd-lStart-1);
<a name="l00144"></a>00144         <span class="keywordflow">if</span>(ioMap.find(lToken) != ioMap.end()) {
<a name="l00145"></a>00145             ioString[lStart] = ioMap[lToken];
<a name="l00146"></a>00146             ioString.erase(lStart+1, lEnd-lStart);
<a name="l00147"></a>00147             lEnd = lStart+1;
<a name="l00148"></a>00148         }
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150     <span class="keywordflow">return</span> ioString;
<a name="l00151"></a>00151 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac9c8db449859f59d210f8e84754b29e9"></a><!-- doxytag: member="PACC::XML::Node::detachFromSiblingsAndParent" ref="ac9c8db449859f59d210f8e84754b29e9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> * XML::Node::detachFromSiblingsAndParent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detach this node from its siblings and parent. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to this node. This method removes this node from its parent tree. The list of sibling nodes is repaired accordingly. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00156">156</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00156"></a>00156                                                   {
<a name="l00157"></a>00157     <span class="comment">// adjust sibling list</span>
<a name="l00158"></a>00158     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>-&gt;mNextSibling = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>;
<a name="l00159"></a>00159     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>-&gt;mPrevSibling = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>;
<a name="l00160"></a>00160     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>) {
<a name="l00161"></a>00161         <span class="comment">// adjust parent first and last child pointers</span>
<a name="l00162"></a>00162         <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>-&gt;mFirstChild == <span class="keyword">this</span>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>-&gt;mFirstChild = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>;
<a name="l00163"></a>00163         <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>-&gt;mLastChild == <span class="keyword">this</span>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>-&gt;mLastChild = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>;
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> = NULL;
<a name="l00166"></a>00166     <span class="keywordflow">return</span> <span class="keyword">this</span>;
<a name="l00167"></a>00167 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aef491e4fa0310ca0a8ca435127a9a309"></a><!-- doxytag: member="PACC::XML::Node::getChildCount" ref="aef491e4fa0310ca0a8ca435127a9a309" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XML::Node::getChildCount </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of child nodes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of child nodes. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00180">180</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00180"></a>00180                                               {
<a name="l00181"></a>00181     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lCount = 0;
<a name="l00182"></a>00182     <span class="keywordflow">for</span>(ConstIterator lChild = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aa47492f75a11e700e53b4e7dcd01a0b0" title="Return an iterator pointing to the first child of this node.">getFirstChild</a>(); lChild; ++lChild) ++lCount;
<a name="l00183"></a>00183     <span class="keywordflow">return</span> lCount;
<a name="l00184"></a>00184 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0e68df0b3d1d51a01e6875d539616b68"></a><!-- doxytag: member="PACC::XML::Node::insertAsLastChild" ref="a0e68df0b3d1d51a01e6875d539616b68" args="(Node *inChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> * XML::Node::insertAsLastChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> *&nbsp;</td>
          <td class="paramname"> <em>inChild</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert node <code>inChild</code> after the last child of this node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the inserted child node. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00188">188</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00188"></a>00188                                                     {
<a name="l00189"></a>00189     <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(inChild, <span class="stringliteral">&quot;Cannot add null pointer node&quot;</span>);
<a name="l00190"></a>00190     <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(!inChild-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> &amp;&amp; !inChild-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> &amp;&amp; !inChild-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>, <span class="stringliteral">&quot;Node must be detached before it can be added!&quot;</span>);
<a name="l00191"></a>00191     <span class="comment">// is this new child the first?</span>
<a name="l00192"></a>00192     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5de69ebc4618625e8be3b626f0015d8e" title="Pointer to first child node.">mFirstChild</a> == NULL) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5de69ebc4618625e8be3b626f0015d8e" title="Pointer to first child node.">mFirstChild</a> = inChild;
<a name="l00193"></a>00193     <span class="keywordflow">else</span> {
<a name="l00194"></a>00194         <span class="comment">// insert after last</span>
<a name="l00195"></a>00195         inChild-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a>;
<a name="l00196"></a>00196         <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a>-&gt;mNextSibling = inChild;
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198     <span class="comment">// adjust parent pointers</span>
<a name="l00199"></a>00199     inChild-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> = <span class="keyword">this</span>;
<a name="l00200"></a>00200     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a> = inChild;
<a name="l00201"></a>00201     <span class="keywordflow">return</span> inChild;
<a name="l00202"></a>00202 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3d4d55e56ae811162e70ba2c7d6c84c2"></a><!-- doxytag: member="PACC::XML::Node::insertAsPreviousSibling" ref="a3d4d55e56ae811162e70ba2c7d6c84c2" args="(Node *inSibling)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> * XML::Node::insertAsPreviousSibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> *&nbsp;</td>
          <td class="paramname"> <em>inSibling</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert node <code>inSibling</code> as the sibling that preceeds this node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the inserted sibling node. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00206">206</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00206"></a>00206                                                             {
<a name="l00207"></a>00207     <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(inSibling, <span class="stringliteral">&quot;Cannot insert null pointer node&quot;</span>);
<a name="l00208"></a>00208     <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(!inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> &amp;&amp; !inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> &amp;&amp; !inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>, <span class="stringliteral">&quot;Node must be detached before it can be inserted!&quot;</span>);
<a name="l00209"></a>00209     <span class="comment">// is this new sibling the first?</span>
<a name="l00210"></a>00210     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> == NULL) {
<a name="l00211"></a>00211         inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a> = <span class="keyword">this</span>;
<a name="l00212"></a>00212         <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = inSibling;
<a name="l00213"></a>00213         <span class="comment">// adjust first child of parent</span>
<a name="l00214"></a>00214         <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>-&gt;mFirstChild = inSibling;
<a name="l00215"></a>00215     } <span class="keywordflow">else</span> {
<a name="l00216"></a>00216         <span class="comment">// this node is neither the first or the last</span>
<a name="l00217"></a>00217         <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>-&gt;mNextSibling = inSibling;
<a name="l00218"></a>00218         inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>;
<a name="l00219"></a>00219         inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a> = <span class="keyword">this</span>;
<a name="l00220"></a>00220         <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = inSibling;
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222     <span class="comment">// adjust parent pointer</span>
<a name="l00223"></a>00223     inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>;
<a name="l00224"></a>00224     <span class="keywordflow">return</span> inSibling;
<a name="l00225"></a>00225 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aba338919ad01b4a8c38bdba81dda0821"></a><!-- doxytag: member="PACC::XML::Node::operator=" ref="aba338919ad01b4a8c38bdba81dda0821" args="(const Node &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> &amp; XML::Node::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">Node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inRoot</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make deep copy of the sub-tree rooted by node <code>inRoot</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to this node </dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>The copied tree must not be a sub-tree of this node. Otherwise, the internal tree structure will become corrupted. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00092">92</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00093"></a>00093 {
<a name="l00094"></a>00094     <span class="comment">// do not self assign!</span>
<a name="l00095"></a>00095     <span class="keywordflow">if</span>(&amp;inRoot == <span class="keyword">this</span>) <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00096"></a>00096     <span class="comment">// delete all child nodes</span>
<a name="l00097"></a>00097     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_iterator.html" title="Node iterator.">XML::Iterator</a> lChild = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aa47492f75a11e700e53b4e7dcd01a0b0" title="Return an iterator pointing to the first child of this node.">getFirstChild</a>();
<a name="l00098"></a>00098     <span class="keywordflow">while</span>(lChild) <span class="keyword">delete</span> &amp;(*(lChild++));
<a name="l00099"></a>00099     <span class="comment">// fix child pointers</span>
<a name="l00100"></a>00100     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5de69ebc4618625e8be3b626f0015d8e" title="Pointer to first child node.">mFirstChild</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a> = NULL;
<a name="l00101"></a>00101     <span class="comment">// assign type and attributes</span>
<a name="l00102"></a>00102     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = inRoot.mType;
<a name="l00103"></a>00103     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aba338919ad01b4a8c38bdba81dda0821" title="Make deep copy of the sub-tree rooted by node inRoot.">map&lt;string,string&gt;::operator=</a>(inRoot);
<a name="l00104"></a>00104     <span class="comment">// copy all children of inRoot</span>
<a name="l00105"></a>00105     <span class="keywordflow">for</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_const_iterator.html" title="Node const iterator.">XML::ConstIterator</a> lNode = inRoot.getFirstChild(); lNode; ++lNode) {
<a name="l00106"></a>00106         <span class="comment">// allocate and copy node</span>
<a name="l00107"></a>00107         <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a" title="Construct empty root node.">Node</a>* lChildNode = <span class="keyword">new</span> <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a" title="Construct empty root node.">Node</a>(*lNode);
<a name="l00108"></a>00108         <span class="comment">// is this the first child?</span>
<a name="l00109"></a>00109         <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5de69ebc4618625e8be3b626f0015d8e" title="Pointer to first child node.">mFirstChild</a> == NULL) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5de69ebc4618625e8be3b626f0015d8e" title="Pointer to first child node.">mFirstChild</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a> = lChildNode;
<a name="l00110"></a>00110         <span class="keywordflow">else</span> {
<a name="l00111"></a>00111             <span class="comment">//adjust sibling pointers</span>
<a name="l00112"></a>00112             <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a>-&gt;mNextSibling = lChildNode;
<a name="l00113"></a>00113             lChildNode-&gt;mPrevSibling = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a>;
<a name="l00114"></a>00114             <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a> = lChildNode;
<a name="l00115"></a>00115         }
<a name="l00116"></a>00116         <span class="comment">// adjust parent pointer</span>
<a name="l00117"></a>00117         lChildNode-&gt;mParent = <span class="keyword">this</span>;
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00120"></a>00120 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a48493203d020c08ebbd44bd98f09d43c"></a><!-- doxytag: member="PACC::XML::Node::parse" ref="a48493203d020c08ebbd44bd98f09d43c" args="(Tokenizer &amp;inTokenizer, const set&lt; string &gt; &amp;inNoParseTags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> * XML::Node::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_tokenizer.html">PACC::Tokenizer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inTokenizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>inNoParseTags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse next tag using stream tokenizer <code>inTokenizer</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A node pointer to the parsed element. Any tag name defined in <code>inNoParseTags</code> will be treated as if its content is a string token (content will not be parsed). </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00230">230</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00231"></a>00231 {
<a name="l00232"></a>00232     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a" title="Construct empty root node.">Node</a>* lNode = NULL;
<a name="l00233"></a>00233     <span class="comment">// look for start tag</span>
<a name="l00234"></a>00234     <span class="keywordtype">string</span> lToken;
<a name="l00235"></a>00235     inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&lt;&quot;</span>);
<a name="l00236"></a>00236     <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken)) <span class="keywordflow">return</span> 0;
<a name="l00237"></a>00237     <span class="comment">// remove any leading white space</span>
<a name="l00238"></a>00238     size_type lPos = lToken.find_first_not_of(<span class="stringliteral">&quot; \t\r\n&quot;</span>);
<a name="l00239"></a>00239     <span class="keywordflow">if</span>(lPos == string::npos) {
<a name="l00240"></a>00240         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken)) <span class="keywordflow">return</span> 0;
<a name="l00241"></a>00241     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lPos &gt; 0) lToken.erase(0, lPos);
<a name="l00242"></a>00242     <span class="keywordflow">if</span>(lToken[0] == <span class="charliteral">&apos;&lt;&apos;</span>) {
<a name="l00243"></a>00243         <span class="comment">// check for end tag</span>
<a name="l00244"></a>00244         <span class="keywordflow">if</span>(inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad30595ff4eceac8815ca139934033888" title="Return the next character from the default input stream.">peekNextChar</a>() == <span class="charliteral">&apos;/&apos;</span>) {
<a name="l00245"></a>00245             <span class="comment">// found end tag; </span>
<a name="l00246"></a>00246             inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>);
<a name="l00247"></a>00247             inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken);
<a name="l00248"></a>00248             <span class="keywordflow">return</span> 0;
<a name="l00249"></a>00249         }
<a name="l00250"></a>00250         <span class="comment">// found start tag</span>
<a name="l00251"></a>00251         lNode = <span class="keyword">new</span> <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a" title="Construct empty root node.">Node</a>;
<a name="l00252"></a>00252         lNode-&gt;parseStartTag(inTokenizer, lToken);
<a name="l00253"></a>00253         <span class="keywordflow">if</span>(lToken[0] == <span class="charliteral">&apos;/&apos;</span>) {
<a name="l00254"></a>00254             <span class="comment">// found end tag; next token must be &apos;&gt;&apos;</span>
<a name="l00255"></a>00255             inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00256"></a>00256             <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken)) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00257"></a>00257             <span class="keywordflow">if</span>(lToken[0] != <span class="charliteral">&apos;&gt;&apos;</span>) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;invalid start tag&quot;</span>);
<a name="l00258"></a>00258         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lNode-&gt;getType() == <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a62511869bb50207683e31806b802c576" title="Regular data markup element.">eData</a>) {
<a name="l00259"></a>00259             <span class="comment">// either read or parse tag content</span>
<a name="l00260"></a>00260             <span class="keywordflow">if</span>(inNoParseTags.find((*lNode)[<span class="stringliteral">&quot;&quot;</span>]) != inNoParseTags.end()) {
<a name="l00261"></a>00261                 lNode-&gt;readContentAsString(inTokenizer);
<a name="l00262"></a>00262             } <span class="keywordflow">else</span> {
<a name="l00263"></a>00263                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a" title="Construct empty root node.">Node</a>* lChild;
<a name="l00264"></a>00264                 <span class="comment">// parse all child</span>
<a name="l00265"></a>00265                 <span class="keywordflow">while</span>((lChild=<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a48493203d020c08ebbd44bd98f09d43c" title="Parse next tag using stream tokenizer inTokenizer.">parse</a>(inTokenizer, inNoParseTags)) != NULL) lNode-&gt;insertAsLastChild(lChild);
<a name="l00266"></a>00266                 <span class="comment">// test for valid end tag</span>
<a name="l00267"></a>00267                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot; \t\n\r&gt;&quot;</span>);
<a name="l00268"></a>00268                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken)) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00269"></a>00269                 <span class="keywordflow">if</span>(lToken != (*lNode)[<span class="stringliteral">&quot;&quot;</span>]) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;invalid end tag&quot;</span>);
<a name="l00270"></a>00270             }
<a name="l00271"></a>00271             <span class="comment">// next token must be &apos;&gt;&apos;</span>
<a name="l00272"></a>00272             inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot; \t\n\r&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00273"></a>00273             <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken)) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00274"></a>00274             <span class="keywordflow">if</span>(lToken[0] != <span class="charliteral">&apos;&gt;&apos;</span>) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;invalid end tag&quot;</span>);
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276         <span class="comment">// else node is not markup</span>
<a name="l00277"></a>00277     } <span class="keywordflow">else</span> {
<a name="l00278"></a>00278         <span class="comment">// found a simple string node</span>
<a name="l00279"></a>00279         lNode = <span class="keyword">new</span> <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a" title="Construct empty root node.">Node</a>;
<a name="l00280"></a>00280         lNode-&gt;mType = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a02125ab9eed124fe7ff63344f2f3c507" title="Literal string.">eString</a>;
<a name="l00281"></a>00281         <span class="comment">// remove any ending white space</span>
<a name="l00282"></a>00282         lPos = lToken.find_last_not_of(<span class="stringliteral">&quot; \t\r\n&quot;</span>);
<a name="l00283"></a>00283         <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(lPos != string::npos, <span class="stringliteral">&quot;Internal error!&quot;</span>);
<a name="l00284"></a>00284         <span class="keywordflow">if</span>(lPos &lt; lToken.size()-1) lToken.resize(lPos+1);
<a name="l00285"></a>00285         <span class="comment">// convert basic quotes</span>
<a name="l00286"></a>00286         (*lNode)[<span class="stringliteral">&quot;&quot;</span>] = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5227d2bef95e7dda97f2b63d617a3724" title="Convert basic xml quotes into ascii characters.">convertFromQuotes</a>(lToken);
<a name="l00287"></a>00287     }
<a name="l00288"></a>00288     <span class="keywordflow">return</span> lNode;
<a name="l00289"></a>00289 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae3112e9f79d990cb581e97179496003d"></a><!-- doxytag: member="PACC::XML::Node::parseAttributeList" ref="ae3112e9f79d990cb581e97179496003d" args="(Tokenizer &amp;inTokenizer, string &amp;outToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XML::Node::parseAttributeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_tokenizer.html">PACC::Tokenizer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inTokenizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&nbsp;</td>
          <td class="paramname"> <em>outToken</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse the attribute list using stream tokenizer <code>inTokenizer</code>. </p>
<p>Ending token is returned through argument <code>outToken</code>. </p>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00294">294</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00295"></a>00295 {
<a name="l00296"></a>00296     inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot; \t\n\r&quot;</span>, <span class="stringliteral">&quot;=/?&gt;&quot;</span>);
<a name="l00297"></a>00297     <span class="comment">// next token should be an attribute name</span>
<a name="l00298"></a>00298     <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00299"></a>00299     <span class="comment">// parse all attributes</span>
<a name="l00300"></a>00300     <span class="keywordflow">while</span>(outToken[0] != <span class="charliteral">&apos;&gt;&apos;</span> &amp;&amp; outToken[0] != <span class="charliteral">&apos;/&apos;</span> &amp;&amp; outToken[0] != <span class="charliteral">&apos;?&apos;</span>)
<a name="l00301"></a>00301     {
<a name="l00302"></a>00302         <span class="keywordflow">if</span>(outToken[0] == <span class="charliteral">&apos;=&apos;</span>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;missing attribute name&quot;</span>);
<a name="l00303"></a>00303         <span class="comment">// ok, found an attribute name!</span>
<a name="l00304"></a>00304         <span class="keywordtype">string</span> lName = outToken;
<a name="l00305"></a>00305         <span class="comment">// next token should be &apos;=&apos;</span>
<a name="l00306"></a>00306         inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot; \t\n\r&quot;</span>, <span class="stringliteral">&quot;=&quot;</span>);
<a name="l00307"></a>00307         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken) || outToken[0] != <span class="charliteral">&apos;=&apos;</span>) 
<a name="l00308"></a>00308             <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;invalid attribute&quot;</span>);
<a name="l00309"></a>00309         inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot; \t\n\r&quot;</span>, <span class="stringliteral">&quot;&apos;\&quot;&quot;</span>);
<a name="l00310"></a>00310         <span class="comment">// next token must be &apos;&quot;&apos; or &quot;&apos;&quot;</span>
<a name="l00311"></a>00311         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00312"></a>00312         <span class="keywordtype">string</span> lValue;
<a name="l00313"></a>00313         <span class="keywordflow">switch</span>(outToken[0]) {
<a name="l00314"></a>00314             <span class="keywordflow">case</span> <span class="charliteral">&apos;\&apos;&apos;</span>:
<a name="l00315"></a>00315                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&apos;&quot;</span>);
<a name="l00316"></a>00316                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00317"></a>00317                     <span class="keywordflow">if</span>(outToken[0] != <span class="charliteral">&apos;\&apos;&apos;</span>) {
<a name="l00318"></a>00318                         lValue = outToken;
<a name="l00319"></a>00319                         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00320"></a>00320                     }
<a name="l00321"></a>00321                         <span class="keywordflow">break</span>;
<a name="l00322"></a>00322             <span class="keywordflow">case</span> <span class="charliteral">&apos;&quot;&apos;</span>:
<a name="l00323"></a>00323                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\&quot;&quot;</span>);
<a name="l00324"></a>00324                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00325"></a>00325                     <span class="keywordflow">if</span>(outToken[0] != <span class="charliteral">&apos;&quot;&apos;</span>) {
<a name="l00326"></a>00326                         lValue = outToken;
<a name="l00327"></a>00327                         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00328"></a>00328                     }
<a name="l00329"></a>00329                         <span class="keywordflow">break</span>;
<a name="l00330"></a>00330             <span class="keywordflow">default</span>:
<a name="l00331"></a>00331                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;invalid attribute value&quot;</span>);
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333         <span class="comment">// insert attribute</span>
<a name="l00334"></a>00334         (*this)[lName] = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5227d2bef95e7dda97f2b63d617a3724" title="Convert basic xml quotes into ascii characters.">convertFromQuotes</a>(lValue);
<a name="l00335"></a>00335         inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot; \t\n\r&quot;</span>, <span class="stringliteral">&quot;=/?&gt;&quot;</span>);
<a name="l00336"></a>00336         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00337"></a>00337     }
<a name="l00338"></a>00338 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5610f5b7d3efb7d5f8914ca37e1ae241"></a><!-- doxytag: member="PACC::XML::Node::parseStartTag" ref="a5610f5b7d3efb7d5f8914ca37e1ae241" args="(Tokenizer &amp;inTokenizer, string &amp;outToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XML::Node::parseStartTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_tokenizer.html">PACC::Tokenizer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inTokenizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&nbsp;</td>
          <td class="paramname"> <em>outToken</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse in stream tokenizer <code>inTokenizer</code> the start tag of this node. </p>
<p>This method assumes that token "&lt;" has already been read. It returns the ending token through argument <code>outToken</code>. </p>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00343">343</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00344"></a>00344 {
<a name="l00345"></a>00345     <span class="comment">// parse tag name</span>
<a name="l00346"></a>00346     inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot; \t\n\r/&gt;&quot;</span>);
<a name="l00347"></a>00347     <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00348"></a>00348     <span class="keywordflow">if</span>(outToken.find_first_of(<span class="stringliteral">&quot; \t\n\r/&gt;&quot;</span>) != string::npos) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;invalid start tag&quot;</span>);
<a name="l00349"></a>00349     <span class="keywordtype">string</span>&amp; lValue = (*this)[<span class="stringliteral">&quot;&quot;</span>];
<a name="l00350"></a>00350     <span class="keywordflow">switch</span>(outToken[0]) {
<a name="l00351"></a>00351         <span class="keywordflow">case</span> <span class="charliteral">&apos;!&apos;</span>:
<a name="l00352"></a>00352             <span class="keywordflow">if</span>(outToken.size() &gt;= 3 &amp;&amp; outToken[1] == <span class="charliteral">&apos;-&apos;</span> &amp;&amp; outToken[2] == <span class="charliteral">&apos;-&apos;</span>) {
<a name="l00353"></a>00353                 <span class="comment">// process comment</span>
<a name="l00354"></a>00354                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814aca7d2f335cd554b1c57bc9c0a44cd46d" title="Comment ().">eComment</a>;
<a name="l00355"></a>00355                 outToken.erase(0, 3);
<a name="l00356"></a>00356                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00357"></a>00357                 <span class="keywordflow">do</span> {
<a name="l00358"></a>00358                     <span class="keywordtype">int</span> lSize = outToken.size();
<a name="l00359"></a>00359                     <span class="keywordflow">if</span>(lSize &gt; 2 &amp;&amp; outToken[lSize-2] == <span class="charliteral">&apos;-&apos;</span> &amp;&amp; outToken[lSize-1] == <span class="charliteral">&apos;-&apos;</span>) {
<a name="l00360"></a>00360                         lValue += outToken.erase(lSize-2, 2);
<a name="l00361"></a>00361                         <span class="keywordflow">break</span>;
<a name="l00362"></a>00362                     } <span class="keywordflow">else</span> lValue += outToken;
<a name="l00363"></a>00363                 } <span class="keywordflow">while</span>(inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken));
<a name="l00364"></a>00364                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00365"></a>00365             } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(outToken.size() &gt;= 8 &amp;&amp; memcmp(outToken.data()+1, <span class="stringliteral">&quot;[CDATA[&quot;</span>, 7) == 0) {
<a name="l00366"></a>00366                 <span class="comment">// process cdata section</span>
<a name="l00367"></a>00367                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a3af269fb25b96d387de378e0249c4fa9" title="CDATA section (&amp;lt;![CDATA[ ... ]]&amp;gt;).">eCDATA</a>;
<a name="l00368"></a>00368                 outToken.erase(0, 8);
<a name="l00369"></a>00369                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00370"></a>00370                 <span class="keywordflow">do</span> {
<a name="l00371"></a>00371                     <span class="keywordtype">int</span> lSize = outToken.size();
<a name="l00372"></a>00372                     <span class="keywordflow">if</span>(lSize &gt;= 2 &amp;&amp; outToken[lSize-2] == <span class="charliteral">&apos;]&apos;</span> &amp;&amp; outToken[lSize-1] == <span class="charliteral">&apos;]&apos;</span>) {
<a name="l00373"></a>00373                         lValue += outToken.erase(lSize-2, 2);
<a name="l00374"></a>00374                         <span class="keywordflow">break</span>;
<a name="l00375"></a>00375                     } <span class="keywordflow">else</span> lValue += outToken;
<a name="l00376"></a>00376                 } <span class="keywordflow">while</span>(inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken));
<a name="l00377"></a>00377                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00378"></a>00378             } <span class="keywordflow">else</span> {
<a name="l00379"></a>00379                 <span class="comment">// process special element (doctype, attribute, etc.)</span>
<a name="l00380"></a>00380                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a4a0d08873453878b747a733b33ee4f81" title="Special element (&amp;lt;! ... &amp;gt;).">eSpecial</a>;
<a name="l00381"></a>00381                 lValue = outToken.erase(0, 1);
<a name="l00382"></a>00382                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00383"></a>00383                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00384"></a>00384                 <span class="keywordflow">if</span>(outToken[0] != <span class="charliteral">&apos;&gt;&apos;</span>) {
<a name="l00385"></a>00385                     lValue += outToken;
<a name="l00386"></a>00386                     <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00387"></a>00387                 }
<a name="l00388"></a>00388             }
<a name="l00389"></a>00389             <span class="keywordflow">break</span>;
<a name="l00390"></a>00390         <span class="keywordflow">case</span> <span class="charliteral">&apos;?&apos;</span>:
<a name="l00391"></a>00391             <span class="keywordflow">if</span>(outToken == <span class="stringliteral">&quot;?xml&quot;</span>) {
<a name="l00392"></a>00392                 <span class="comment">// process xml declaration</span>
<a name="l00393"></a>00393                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a1349bbd6e6b8571961f80800dc3059eb" title="XML declaration (&amp;lt;?xml ... ?&amp;gt;).">eDecl</a>;
<a name="l00394"></a>00394                 lValue = outToken.erase(0, 1);
<a name="l00395"></a>00395                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ae3112e9f79d990cb581e97179496003d" title="Parse the attribute list using stream tokenizer inTokenizer.">parseAttributeList</a>(inTokenizer, outToken);
<a name="l00396"></a>00396                 <span class="keywordflow">if</span>(outToken[0] != <span class="charliteral">&apos;?&apos;</span>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;invalid xml declaration&quot;</span>);
<a name="l00397"></a>00397                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00398"></a>00398                 <span class="keywordflow">if</span>(outToken[0] != <span class="charliteral">&apos;&gt;&apos;</span>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;invalid xml declaration&quot;</span>);
<a name="l00399"></a>00399             } <span class="keywordflow">else</span> {
<a name="l00400"></a>00400                 <span class="comment">// process special processing instruction</span>
<a name="l00401"></a>00401                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814ac2833f6aa343cf425ab0f4aede27c73f" title="Processing instruction (&amp;lt;? ... ?&amp;gt;).">ePI</a>;
<a name="l00402"></a>00402                 lValue = outToken.substr(1, outToken.size()-1);
<a name="l00403"></a>00403                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;?&gt;&quot;</span>);
<a name="l00404"></a>00404                 <span class="keywordflow">while</span>(inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) {
<a name="l00405"></a>00405                     <span class="keywordflow">if</span>(outToken[0] == <span class="charliteral">&apos;?&apos;</span>) {
<a name="l00406"></a>00406                         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00407"></a>00407                         <span class="keywordflow">if</span>(outToken[0] == <span class="charliteral">&apos;&gt;&apos;</span>) <span class="keywordflow">break</span>;
<a name="l00408"></a>00408                         <span class="keywordflow">else</span> lValue += <span class="charliteral">&apos;?&apos;</span>;
<a name="l00409"></a>00409                     } 
<a name="l00410"></a>00410                     lValue += outToken;
<a name="l00411"></a>00411                 }
<a name="l00412"></a>00412                 <span class="keywordflow">if</span>(outToken.empty()) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00413"></a>00413             }
<a name="l00414"></a>00414             <span class="keywordflow">break</span>;
<a name="l00415"></a>00415         <span class="keywordflow">default</span>:
<a name="l00416"></a>00416             <span class="comment">// process data markup</span>
<a name="l00417"></a>00417             <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a62511869bb50207683e31806b802c576" title="Regular data markup element.">eData</a>;
<a name="l00418"></a>00418             lValue = outToken;
<a name="l00419"></a>00419             <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ae3112e9f79d990cb581e97179496003d" title="Parse the attribute list using stream tokenizer inTokenizer.">parseAttributeList</a>(inTokenizer, outToken);
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad4435832826f4874ee8b59be84267c75"></a><!-- doxytag: member="PACC::XML::Node::serialize" ref="ad4435832826f4874ee8b59be84267c75" args="(Streamer &amp;outStream, bool inIndent=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XML::Node::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html">XML::Streamer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inIndent</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serialize this node into XML streamer <code>outStream</code>. </p>
<p>Argument <code>inIndent</code> is used to control indentation. By default (<code>inIndent=true</code>), the sub-tree rooted by this node will be serialized with indentation. If <code>inIndent=false</code>, then the node will be serialized without any form of indentation (including line feeds). </p>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00469">469</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00470"></a>00470 {
<a name="l00471"></a>00471     <span class="keywordflow">switch</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a>)
<a name="l00472"></a>00472     {
<a name="l00473"></a>00473         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a3af269fb25b96d387de378e0249c4fa9" title="CDATA section (&amp;lt;![CDATA[ ... ]]&amp;gt;).">eCDATA</a>:
<a name="l00474"></a>00474         {
<a name="l00475"></a>00475             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a376b16781253a31bfec62a6ef90411f3" title="Insert CDATA section inCDATA (cannot contain any &amp;quot;]]&amp;gt;&amp;quot; substring).">insertCDATA</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>());
<a name="l00476"></a>00476             <span class="keywordflow">break</span>;
<a name="l00477"></a>00477         }
<a name="l00478"></a>00478         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814aca7d2f335cd554b1c57bc9c0a44cd46d" title="Comment ().">eComment</a>: 
<a name="l00479"></a>00479         {
<a name="l00480"></a>00480             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a57398c80e707d17f9cd9b558c8ff1a03" title="Insert comment inComment (cannot contain any &amp;quot;--&amp;quot; substring).">insertComment</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>());
<a name="l00481"></a>00481             <span class="keywordflow">break</span>;
<a name="l00482"></a>00482         }
<a name="l00483"></a>00483         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a62511869bb50207683e31806b802c576" title="Regular data markup element.">eData</a>:
<a name="l00484"></a>00484         {
<a name="l00485"></a>00485             <span class="comment">// check for tag with single string content</span>
<a name="l00486"></a>00486             ConstIterator lChild = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aa47492f75a11e700e53b4e7dcd01a0b0" title="Return an iterator pointing to the first child of this node.">getFirstChild</a>();
<a name="l00487"></a>00487             <span class="keywordflow">if</span>(lChild &amp;&amp; lChild-&gt;mType == <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a02125ab9eed124fe7ff63344f2f3c507" title="Literal string.">eString</a> &amp;&amp; !lChild-&gt;getNextSibling()) {
<a name="l00488"></a>00488                 <span class="comment">// disable indentation</span>
<a name="l00489"></a>00489                 outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#ab7ababa7f01e1864cbb4abe0d0951e20" title="Open new markup tag using name inName.">openTag</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>(), <span class="keyword">false</span>);
<a name="l00490"></a>00490             } <span class="keywordflow">else</span> {
<a name="l00491"></a>00491                 outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#ab7ababa7f01e1864cbb4abe0d0951e20" title="Open new markup tag using name inName.">openTag</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>(), inIndent);
<a name="l00492"></a>00492             }
<a name="l00493"></a>00493             <span class="comment">// serialize attribute list</span>
<a name="l00494"></a>00494             <span class="keywordflow">for</span>(map&lt;string,string&gt;::const_iterator i = begin(); i != end(); ++i) {
<a name="l00495"></a>00495                 <span class="keywordflow">if</span>(i-&gt;first != <span class="stringliteral">&quot;&quot;</span>) outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a3aca8bdecc18f88a8492d1ed1364108f" title="Insert a string attribute with name inName and value inValue into the current start...">insertAttribute</a>(i-&gt;first, i-&gt;second);
<a name="l00496"></a>00496             }
<a name="l00497"></a>00497             <span class="comment">// serialize child nodes</span>
<a name="l00498"></a>00498             <span class="keywordflow">while</span>(lChild) (lChild++)-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ad4435832826f4874ee8b59be84267c75" title="Serialize this node into XML streamer outStream.">serialize</a>(outStream, inIndent);
<a name="l00499"></a>00499             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#aadb172b379622236139be0c95bed55de" title="Close the last opened markup tag.">closeTag</a>();
<a name="l00500"></a>00500             <span class="keywordflow">break</span>;
<a name="l00501"></a>00501         }
<a name="l00502"></a>00502         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a8c37164a8f4d0a8e2271aa763e6b3237" title="Unparsed markup content.">eNoParse</a>:
<a name="l00503"></a>00503         {
<a name="l00504"></a>00504             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a4e6c054f8032d5d03d6614b75656f547" title="Insert string inString as content of current markup.">insertStringContent</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>(), <span class="keyword">false</span>);
<a name="l00505"></a>00505             <span class="keywordflow">break</span>;
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814ac2833f6aa343cf425ab0f4aede27c73f" title="Processing instruction (&amp;lt;? ... ?&amp;gt;).">ePI</a>: 
<a name="l00508"></a>00508         {
<a name="l00509"></a>00509             <span class="keywordtype">string</span> lValue = string(<span class="stringliteral">&quot;&lt;?&quot;</span>) + <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>() + string(<span class="stringliteral">&quot;?&gt;&quot;</span>);
<a name="l00510"></a>00510             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a4e6c054f8032d5d03d6614b75656f547" title="Insert string inString as content of current markup.">insertStringContent</a>(lValue, <span class="keyword">false</span>);
<a name="l00511"></a>00511             <span class="keywordflow">break</span>;
<a name="l00512"></a>00512         }
<a name="l00513"></a>00513         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a4a0d08873453878b747a733b33ee4f81" title="Special element (&amp;lt;! ... &amp;gt;).">eSpecial</a>:
<a name="l00514"></a>00514         {
<a name="l00515"></a>00515             <span class="keywordtype">string</span> lValue = string(<span class="stringliteral">&quot;&lt;!&quot;</span>) + <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>() + string(<span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00516"></a>00516             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a4e6c054f8032d5d03d6614b75656f547" title="Insert string inString as content of current markup.">insertStringContent</a>(lValue, <span class="keyword">false</span>);
<a name="l00517"></a>00517             <span class="keywordflow">break</span>;
<a name="l00518"></a>00518         }
<a name="l00519"></a>00519         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a02125ab9eed124fe7ff63344f2f3c507" title="Literal string.">eString</a>:
<a name="l00520"></a>00520         {
<a name="l00521"></a>00521             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a4e6c054f8032d5d03d6614b75656f547" title="Insert string inString as content of current markup.">insertStringContent</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>(), <span class="keyword">true</span>);
<a name="l00522"></a>00522             <span class="keywordflow">break</span>;
<a name="l00523"></a>00523         }
<a name="l00524"></a>00524         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a1349bbd6e6b8571961f80800dc3059eb" title="XML declaration (&amp;lt;?xml ... ?&amp;gt;).">eDecl</a>: 
<a name="l00525"></a>00525         {
<a name="l00526"></a>00526             <span class="keywordtype">string</span> lValue = <span class="stringliteral">&quot;&lt;?xml version=\&quot;&quot;</span>;
<a name="l00527"></a>00527             <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa71362e83a9722288a8e4474aa2b7643" title="Test wheter attribute name inName exists in this list.">isDefined</a>(<span class="stringliteral">&quot;version&quot;</span>)) lValue += <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa329c59996a8338d1097e2d51d598c13" title="Return value of attribute inName, or empty string if it doesn&amp;#39;t exist.">getAttribute</a>(<span class="stringliteral">&quot;version&quot;</span>);
<a name="l00528"></a>00528             <span class="keywordflow">else</span> lValue += <span class="stringliteral">&quot;1.0&quot;</span>;
<a name="l00529"></a>00529             lValue += <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l00530"></a>00530             <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa71362e83a9722288a8e4474aa2b7643" title="Test wheter attribute name inName exists in this list.">isDefined</a>(<span class="stringliteral">&quot;encoding&quot;</span>)) lValue += <span class="stringliteral">&quot; encoding=\&quot;&quot;</span> + <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa329c59996a8338d1097e2d51d598c13" title="Return value of attribute inName, or empty string if it doesn&amp;#39;t exist.">getAttribute</a>(<span class="stringliteral">&quot;encoding&quot;</span>) + <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l00531"></a>00531             lValue += <span class="stringliteral">&quot;?&gt;&quot;</span>;
<a name="l00532"></a>00532             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a4e6c054f8032d5d03d6614b75656f547" title="Insert string inString as content of current markup.">insertStringContent</a>(lValue, <span class="keyword">false</span>);
<a name="l00533"></a>00533             <span class="keywordflow">break</span>;
<a name="l00534"></a>00534         }
<a name="l00535"></a>00535         <span class="keywordflow">default</span>:
<a name="l00536"></a>00536         {
<a name="l00537"></a>00537             <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(<span class="keyword">false</span>, <span class="stringliteral">&quot;Unknown node type!&quot;</span>);
<a name="l00538"></a>00538         }
<a name="l00539"></a>00539     }
<a name="l00540"></a>00540 }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PACC/XML/<a class="el" href="_node_8hpp_source.html">Node.hpp</a></li>
<li>PACC/XML/<a class="el" href="_node_8cpp_source.html">Node.cpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jan 31 15:10:22 2010 for PACC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
