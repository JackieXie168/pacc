<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PACC: PACC::Socket::TCP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_c_c.html">PACC</a>::<a class="el" href="namespace_p_a_c_c_1_1_socket.html">Socket</a>::<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html">TCP</a>
  </div>
</div>
<div class="contents">
<h1>PACC::Socket::TCP Class Reference<br/>
<small>
[<a class="el" href="group___socket.html">Socket: portable socket networking</a>]</small>
</h1><!-- doxytag: class="PACC::Socket::TCP" --><!-- doxytag: inherits="PACC::Socket::Port" -->
<p>Portable TCP socket client.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_t_c_p_8hpp_source.html">TCP.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PACC::Socket::TCP:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_p_a_c_c_1_1_socket_1_1_t_c_p.gif" usemap="#PACC::Socket::TCP_map" alt=""/>
  <map id="PACC::Socket::TCP_map" name="PACC::Socket::TCP_map">
<area href="class_p_a_c_c_1_1_socket_1_1_port.html" alt="PACC::Socket::Port" shape="rect" coords="85,0,245,24"/>
<area href="class_p_a_c_c_1_1_socket_1_1_cafe.html" alt="PACC::Socket::Cafe" shape="rect" coords="0,112,160,136"/>
<area href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html" alt="PACC::Socket::TCPServer" shape="rect" coords="170,112,330,136"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html" alt="PACC::SVG::Canvas" shape="rect" coords="0,168,160,192"/>
</map>
 </div>
</div>

<p><a href="class_p_a_c_c_1_1_socket_1_1_t_c_p-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7cfc7c83eca302e0e424f2f0aa3bc6d"></a><!-- doxytag: member="PACC::Socket::TCP::TCP" ref="ad7cfc7c83eca302e0e424f2f0aa3bc6d" args="(void)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#ad7cfc7c83eca302e0e424f2f0aa3bc6d">TCP</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct unconnected socket. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ae745d04a1850dbc76eb391190e40ec"></a><!-- doxytag: member="PACC::Socket::TCP::TCP" ref="a9ae745d04a1850dbc76eb391190e40ec" args="(int inDescriptor)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#a9ae745d04a1850dbc76eb391190e40ec">TCP</a> (int inDescriptor)  throw ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct using existing socket descriptor <code>inDescriptor</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b761b892168cf249b2bede44a2c0137"></a><!-- doxytag: member="PACC::Socket::TCP::TCP" ref="a0b761b892168cf249b2bede44a2c0137" args="(const Address &amp;inPeer)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#a0b761b892168cf249b2bede44a2c0137">TCP</a> (const <a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;inPeer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct socket connected to peer <code>inPeer</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2848b4ba6d7b4b2e55af1675727c80d"></a><!-- doxytag: member="PACC::Socket::TCP::close" ref="af2848b4ba6d7b4b2e55af1675727c80d" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#af2848b4ba6d7b4b2e55af1675727c80d">close</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close connection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24eb29f54290765a83e3e8b0469c78c2"></a><!-- doxytag: member="PACC::Socket::TCP::connect" ref="a24eb29f54290765a83e3e8b0469c78c2" args="(const Address &amp;inPeer)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#a24eb29f54290765a83e3e8b0469c78c2">connect</a> (const <a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;inPeer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to server <code>inPeer</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#a7213a4475b86817b0396e6cf87c917d1">receiveMessage</a> (string &amp;outMessage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive string message from connected (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a>) server.  <a href="#a7213a4475b86817b0396e6cf87c917d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#adc5fb826b4851b5314c9248ed94620e9">sendMessage</a> (const string &amp;inMessage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send string message to connected (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a>) server.  <a href="#adc5fb826b4851b5314c9248ed94620e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a002078da6139f20def2af30c22984fcf"></a><!-- doxytag: member="PACC::Socket::TCP::getDescriptor" ref="a002078da6139f20def2af30c22984fcf" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a002078da6139f20def2af30c22984fcf">getDescriptor</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return socket descriptor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a41ecb8dddf4441185f0b893d9dce5514">getPeerAddress</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return address of peer socket host.  <a href="#a41ecb8dddf4441185f0b893d9dce5514"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___socket.html#ga3109f582afef6bc8e60e4bbf26fc0ac6">Protocol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#aaa2f2ae4b67d2dd00a0933f60c784e54">getProtocol</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return protocol of socket.  <a href="#aaa2f2ae4b67d2dd00a0933f60c784e54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a4abe927d07cf69d1048992c6c9ce8452">getSockAddress</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return address of socket host.  <a href="#a4abe927d07cf69d1048992c6c9ce8452"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a758a6afe098539a362de79a86b5f1f1d">getSockOpt</a> (<a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Option</a> inName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value of socket option <code>inName</code>.  <a href="#a758a6afe098539a362de79a86b5f1f1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367">setSockOpt</a> (<a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Option</a> inName, double inValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set socket option <code>inName</code> to value <code>inValue</code>.  <a href="#a0f8abcce1ad096ea617c88b4d366e367"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#ae7bac9446a6f94245a4d9f15a23d3847">accept</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept connection on bound port.  <a href="#ae7bac9446a6f94245a4d9f15a23d3847"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#aaceed74c3414e4a4acccd297aff1084b">bind</a> (unsigned int inPortNumber)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind socket to port number <code>inPortNumber</code>.  <a href="#aaceed74c3414e4a4acccd297aff1084b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a3d153806aea01830530f4ea04c0f338b">convertToNativeOption</a> (<a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Option</a> inName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert socket option <code>inName</code> to native socket option code.  <a href="#a3d153806aea01830530f4ea04c0f338b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5147580c20eb309df5a0fa7cb65e8ef3"></a><!-- doxytag: member="PACC::Socket::TCP::listen" ref="a5147580c20eb309df5a0fa7cb65e8ef3" args="(unsigned int inMaxConnections)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a5147580c20eb309df5a0fa7cb65e8ef3">listen</a> (unsigned int inMaxConnections)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Listen to socket using a queue of at least <code>inMinPending</code> pending connections. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0180add2f0a595baeae502607a74ea64">open</a> (<a class="el" href="group___socket.html#ga3109f582afef6bc8e60e4bbf26fc0ac6">Protocol</a>=eTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open new socket descriptor.  <a href="#a0180add2f0a595baeae502607a74ea64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#aa2bfb38c81fc0695d99f51cc8e7291c6">receive</a> (char *outBuffer, unsigned inMaxCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive data from connected socket.  <a href="#aa2bfb38c81fc0695d99f51cc8e7291c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#abc30f2043f597dc71e7113528824b42b">receiveFrom</a> (char *outBuffer, unsigned inMaxCount, <a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;outPeer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive data from unconnected socket.  <a href="#abc30f2043f597dc71e7113528824b42b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740">send</a> (const char *inBuffer, unsigned int inCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send data to connected socket.  <a href="#a7e0f88dff3eacee95675eb0fcc9cc740"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#ac9c7959ca0afef4d5fa57a28fba3b4d8">sendTo</a> (const char *inBuffer, unsigned int inCount, const <a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;inPeer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send data to unconnected socket.  <a href="#ac9c7959ca0afef4d5fa57a28fba3b4d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a27ed19ee09dc2503886c071edc813cc8">waitForActivity</a> (double inSeconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for activity.  <a href="#a27ed19ee09dc2503886c071edc813cc8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11b5de113c588e85c076ea8f7a42600c"></a><!-- doxytag: member="PACC::Socket::TCP::mDescriptor" ref="a11b5de113c588e85c076ea8f7a42600c" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c">mDescriptor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">socket descriptor <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Portable TCP socket client. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Marc Parizeau, Laboratoire de vision et syst&egrave;mes num&eacute;riques, Universit&eacute; Laval</dd></dl>
<p>This class defines a simple TCP socket client that connects to a peer server. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_t_c_p_8hpp_source.html#l00052">52</a> of file <a class="el" href="_t_c_p_8hpp_source.html">TCP.hpp</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae7bac9446a6f94245a4d9f15a23d3847"></a><!-- doxytag: member="PACC::Socket::TCP::accept" ref="ae7bac9446a6f94245a4d9f15a23d3847" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Socket::Port::accept </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept connection on bound port. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00089">89</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00090"></a>00090 {
<a name="l00091"></a>00091     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::accept() invalid socket&quot;</span>);
<a name="l00092"></a>00092     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00093"></a>00093     socklen_t lSize = <span class="keyword">sizeof</span>(lSock);
<a name="l00094"></a>00094     <span class="keywordtype">int</span> lDescriptor =<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#ae7bac9446a6f94245a4d9f15a23d3847" title="Accept connection on bound port."> ::accept</a>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (<span class="keyword">struct </span>sockaddr*) &amp;lSock, &amp;lSize);
<a name="l00095"></a>00095     <span class="keywordflow">if</span>(lDescriptor &lt; 0) {
<a name="l00096"></a>00096         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::acept() unable to accept connection&quot;</span>);
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098     <span class="keywordflow">return</span> lDescriptor;
<a name="l00099"></a>00099 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaceed74c3414e4a4acccd297aff1084b"></a><!-- doxytag: member="PACC::Socket::TCP::bind" ref="aaceed74c3414e4a4acccd297aff1084b" args="(unsigned int inPortNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::bind </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inPortNumber</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind socket to port number <code>inPortNumber</code>. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. In particular, this method may fail if the port is already binded by another process or thread. It may even fail for a few seconds after the connection is released by another process or thread (see Option::eReuseAddress). </p>

<p>Reimplemented in <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#afa9967ccc64a9b3bbb4f2184d1fb1ff6">PACC::Socket::TCPServer</a>.</p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00107">107</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00108"></a>00108 {
<a name="l00109"></a>00109     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::bind() invalid socket&quot;</span>);
<a name="l00110"></a>00110     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00111"></a>00111     lSock.sin_family = AF_INET;
<a name="l00112"></a>00112     lSock.sin_port = htons(inPortNumber);
<a name="l00113"></a>00113     lSock.sin_addr.s_addr = htonl(INADDR_ANY);
<a name="l00114"></a>00114     memset(&amp;lSock.sin_zero, 0, 8);
<a name="l00115"></a>00115     <span class="keywordflow">if</span>(::<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#aaceed74c3414e4a4acccd297aff1084b" title="Bind socket to port number inPortNumber.">bind</a>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (<span class="keyword">struct</span> sockaddr*) &amp;lSock, <span class="keyword">sizeof</span>(lSock)) != 0) {
<a name="l00116"></a>00116         <span class="keywordtype">int</span> lCode = ErrNo;
<a name="l00117"></a>00117         ostringstream lMessage;
<a name="l00118"></a>00118         lMessage &lt;&lt; <span class="stringliteral">&quot;Port::bind() unable to bind port: &quot;</span> &lt;&lt; inPortNumber;
<a name="l00119"></a>00119         <span class="keywordflow">throw</span> Exception(lCode, lMessage.str());
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3d153806aea01830530f4ea04c0f338b"></a><!-- doxytag: member="PACC::Socket::TCP::convertToNativeOption" ref="a3d153806aea01830530f4ea04c0f338b" args="(Option inName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Socket::Port::convertToNativeOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Socket::Option</a>&nbsp;</td>
          <td class="paramname"> <em>inName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert socket option <code>inName</code> to native socket option code. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00166">166</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00167"></a>00167 {
<a name="l00168"></a>00168     <span class="keywordtype">int</span> lNativeOpt;
<a name="l00169"></a>00169     <span class="keywordflow">switch</span>(inName) {
<a name="l00170"></a>00170         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fad094f0c703765e462059f4c8a92b7292" title="Keep connection alive.">eKeepAlive</a>: lNativeOpt = SO_KEEPALIVE; <span class="keywordflow">break</span>;
<a name="l00171"></a>00171         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fae0dcf7836a0dbfe6de1d8de7f5c1aa47" title="Time to linger on close (in seconds).">eLinger</a>: lNativeOpt = SO_LINGER; <span class="keywordflow">break</span>;
<a name="l00172"></a>00172         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>: lNativeOpt = TCP_NODELAY; <span class="keywordflow">break</span>;
<a name="l00173"></a>00173         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faef38bf8dd0269ab968548ce17aeba64a" title="Socket protocol type">eProtocolType</a>: lNativeOpt = SO_TYPE; <span class="keywordflow">break</span>;
<a name="l00174"></a>00174         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa1839a506c945f06a24ded765b5ece67a" title="Allow reuse of a TCP address without delay.">eReuseAddress</a>: lNativeOpt = SO_REUSEADDR; <span class="keywordflow">break</span>;
<a name="l00175"></a>00175         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>: lNativeOpt = SO_RCVBUF; <span class="keywordflow">break</span>;
<a name="l00176"></a>00176         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faf5ee4bfe5d2341a7875edb7ff10ff1c2" title="Size of send buffer (in number of chars).">eSendBufSize</a>: lNativeOpt = SO_SNDBUF; <span class="keywordflow">break</span>;
<a name="l00177"></a>00177         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">eRecvTimeOut</a>: lNativeOpt = SO_RCVTIMEO; <span class="keywordflow">break</span>;
<a name="l00178"></a>00178         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">eSendTimeOut</a>: lNativeOpt = SO_SNDTIMEO; <span class="keywordflow">break</span>;
<a name="l00179"></a>00179         <span class="keywordflow">default</span>: <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::convertToNativeOption() unknown socket option&quot;</span>);
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181     <span class="keywordflow">return</span> lNativeOpt;
<a name="l00182"></a>00182 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a41ecb8dddf4441185f0b893d9dce5514"></a><!-- doxytag: member="PACC::Socket::TCP::getPeerAddress" ref="a41ecb8dddf4441185f0b893d9dce5514" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Socket::Address</a> Socket::Port::getPeerAddress </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return address of peer socket host. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00187">187</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00188"></a>00188 {
<a name="l00189"></a>00189     <span class="keyword">struct </span>sockaddr lSock;
<a name="l00190"></a>00190     socklen_t lLength = <span class="keyword">sizeof</span>(lSock);
<a name="l00191"></a>00191     <span class="keywordflow">if</span>(::getpeername(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lSock, &amp;lLength) != 0) {
<a name="l00192"></a>00192         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2af3e825a5abff84418308ed3ed6dd0c55" title="Socket is not connected.">eNotConnected</a>, <span class="stringliteral">&quot;Port::getPeerAddress() unable to retrieve peer address&quot;</span>);
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194     <span class="keywordflow">return</span> Address(ntohs(((sockaddr_in*)&amp;lSock)-&gt;sin_port), inet_ntoa(((sockaddr_in*)&amp;lSock)-&gt;sin_addr));
<a name="l00195"></a>00195 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaa2f2ae4b67d2dd00a0933f60c784e54"></a><!-- doxytag: member="PACC::Socket::TCP::getProtocol" ref="aaa2f2ae4b67d2dd00a0933f60c784e54" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___socket.html#ga3109f582afef6bc8e60e4bbf26fc0ac6">Socket::Protocol</a> Socket::Port::getProtocol </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return protocol of socket. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00200">200</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00201"></a>00201 {
<a name="l00202"></a>00202     
<a name="l00203"></a>00203     <span class="keywordtype">int</span> lProtocol = (int) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a758a6afe098539a362de79a86b5f1f1d" title="Return value of socket option inName.">getSockOpt</a>(<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faef38bf8dd0269ab968548ce17aeba64a" title="Socket protocol type">eProtocolType</a>);
<a name="l00204"></a>00204     <span class="keywordflow">if</span>(lProtocol == SOCK_STREAM) <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a058e23bb541cf7bdc7f6975d987c477d" title="Transfer Control Protocol.">eTCP</a>;
<a name="l00205"></a>00205     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lProtocol == SOCK_DGRAM) <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a9caf36aa3cd32acd779c55f0f8e1ff54" title="User Datagram Protocol.">eUDP</a>;
<a name="l00206"></a>00206     <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6aa028e8075f4cfd5365f252d682f1f7ab" title="Other protocol.">eOther</a>;
<a name="l00207"></a>00207 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4abe927d07cf69d1048992c6c9ce8452"></a><!-- doxytag: member="PACC::Socket::TCP::getSockAddress" ref="a4abe927d07cf69d1048992c6c9ce8452" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Socket::Address</a> Socket::Port::getSockAddress </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return address of socket host. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00212">212</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00213"></a>00213 {
<a name="l00214"></a>00214     <span class="keyword">struct </span>sockaddr lSock;
<a name="l00215"></a>00215     socklen_t lLength = <span class="keyword">sizeof</span>(lSock);
<a name="l00216"></a>00216     <span class="keywordflow">if</span>(::getsockname(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lSock, &amp;lLength) != 0) {
<a name="l00217"></a>00217         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::getSockAddress() unable to retrieve socket address&quot;</span>);
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219     <span class="keywordflow">return</span> Address(ntohs(((sockaddr_in*)&amp;lSock)-&gt;sin_port), inet_ntoa(((sockaddr_in*)&amp;lSock)-&gt;sin_addr));
<a name="l00220"></a>00220 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a758a6afe098539a362de79a86b5f1f1d"></a><!-- doxytag: member="PACC::Socket::TCP::getSockOpt" ref="a758a6afe098539a362de79a86b5f1f1d" args="(Option inName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Socket::Port::getSockOpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Socket::Option</a>&nbsp;</td>
          <td class="paramname"> <em>inName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return value of socket option <code>inName</code>. </p>
<p>Valid options are: </p>
<ul>
<li>
eKeepAlive: keep connection alive (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eLinger: time to linger on close (in seconds, <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eNoDelay: disable the Nagle algorithm for packet coalescing (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eProtocolType: socket protocol type </li>
<li>
eReuseAddress: allow reuse of address </li>
<li>
eRecvBufSize: size of receive buffer (in bytes) </li>
<li>
eSendBufSize: size of send buffer (in bytes) </li>
<li>
eRecvTimeOut: time out period for receive operations (in seconds) </li>
<li>
eSendTimeOut: time out period for send operations (in seconds) </li>
</ul>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00237">237</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00238"></a>00238 {
<a name="l00239"></a>00239     <span class="keywordtype">double</span> lValue;
<a name="l00240"></a>00240     <span class="keywordtype">int</span> lBuffer[2] = {0, 0};
<a name="l00241"></a>00241     socklen_t lSize = <span class="keyword">sizeof</span>(lBuffer);
<a name="l00242"></a>00242     <span class="keywordflow">if</span>(::getsockopt(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (inName==<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>?IPPROTO_TCP:SOL_SOCKET), <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a3d153806aea01830530f4ea04c0f338b" title="Convert socket option inName to native socket option code.">convertToNativeOption</a>(inName), (<span class="keywordtype">char</span>*)lBuffer, &amp;lSize) != 0)
<a name="l00243"></a>00243     {
<a name="l00244"></a>00244         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::getSockOpt() unable to retrieve socket option&quot;</span>);
<a name="l00245"></a>00245     }
<a name="l00246"></a>00246     <span class="keywordflow">switch</span>(inName) {
<a name="l00247"></a>00247         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fad094f0c703765e462059f4c8a92b7292" title="Keep connection alive.">eKeepAlive</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa1839a506c945f06a24ded765b5ece67a" title="Allow reuse of a TCP address without delay.">eReuseAddress</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faf5ee4bfe5d2341a7875edb7ff10ff1c2" title="Size of send buffer (in number of chars).">eSendBufSize</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faef38bf8dd0269ab968548ce17aeba64a" title="Socket protocol type">eProtocolType</a>:
<a name="l00248"></a>00248             lValue = lBuffer[0];
<a name="l00249"></a>00249             <span class="keywordflow">break</span>;
<a name="l00250"></a>00250         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fae0dcf7836a0dbfe6de1d8de7f5c1aa47" title="Time to linger on close (in seconds).">eLinger</a>:
<a name="l00251"></a>00251         {
<a name="l00252"></a>00252             <span class="comment">// warning: the linger structure is not the same size on windows and unix!</span>
<a name="l00253"></a>00253             <span class="keyword">struct </span>linger* lPtr = (<span class="keyword">struct </span>linger*) lBuffer;
<a name="l00254"></a>00254             <span class="keywordflow">if</span>(lPtr-&gt;l_onoff) lValue = lPtr-&gt;l_linger;
<a name="l00255"></a>00255             <span class="keywordflow">else</span> lValue = -1;
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257             <span class="keywordflow">break</span>;
<a name="l00258"></a>00258         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">eRecvTimeOut</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">eSendTimeOut</a>:
<a name="l00259"></a>00259 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>            <span class="comment">// on windows, timeout is specified in milliseconds</span>
<a name="l00261"></a>00261             lValue = (float)lBuffer[0]/1000.;
<a name="l00262"></a>00262 <span class="preprocessor">#else</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span>            <span class="comment">// on unix, timeout is specified with timeval structure</span>
<a name="l00264"></a>00264             {
<a name="l00265"></a>00265                 <span class="keyword">struct </span>timeval* lPtr = (<span class="keyword">struct </span>timeval*) lBuffer;
<a name="l00266"></a>00266                 lValue = (float)lPtr-&gt;tv_sec + lPtr-&gt;tv_usec/1000000.;
<a name="l00267"></a>00267             }
<a name="l00268"></a>00268 <span class="preprocessor">#endif</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span>                <span class="keywordflow">break</span>;
<a name="l00270"></a>00270         <span class="keywordflow">default</span>:
<a name="l00271"></a>00271             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::getSockOpt() unknown socket option&quot;</span>);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273     <span class="keywordflow">return</span> lValue;
<a name="l00274"></a>00274 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0180add2f0a595baeae502607a74ea64"></a><!-- doxytag: member="PACC::Socket::TCP::open" ref="a0180add2f0a595baeae502607a74ea64" args="(Protocol=eTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga3109f582afef6bc8e60e4bbf26fc0ac6">Socket::Protocol</a>&nbsp;</td>
          <td class="paramname"> <em>inProtocol</em> = <code>eTCP</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open new socket descriptor. </p>
<p>A socket descriptor is allocated using the protocol determined by parameter <code>inProtocol</code>. The <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> protocol is selected with value <code>eTCP</code> (default), while the <a class="el" href="class_p_a_c_c_1_1_socket_1_1_u_d_p.html" title="Portable UDP client.">UDP</a> protocol is chosen with value <code>eUDP</code>.</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00291">291</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00292"></a>00292 {
<a name="l00293"></a>00293 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">bool</span> lInitialized = <span class="keyword">false</span>;
<a name="l00295"></a>00295     <span class="keywordflow">if</span>(!lInitialized) {
<a name="l00296"></a>00296         WSADATA wsdata;
<a name="l00297"></a>00297         <span class="keywordflow">if</span> (WSAStartup(MAKEWORD(2,2), &amp;wsdata) != 0) {
<a name="l00298"></a>00298             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::open() failed to load WinSock2&quot;</span>);
<a name="l00299"></a>00299         }
<a name="l00300"></a>00300         lInitialized = <span class="keyword">true</span>;
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302 <span class="preprocessor">#endif</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span>    <span class="comment">// first close socket if already open</span>
<a name="l00304"></a>00304     <span class="keywordflow">if</span>(!INVALID_SOCKET) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00305"></a>00305     <span class="comment">// select protocol and create new socket descriptor</span>
<a name="l00306"></a>00306     <span class="keywordflow">if</span>(inProtocol == <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a058e23bb541cf7bdc7f6975d987c477d" title="Transfer Control Protocol.">eTCP</a>) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> = ::socket(AF_INET, SOCK_STREAM, 0);
<a name="l00307"></a>00307     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(inProtocol == <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a9caf36aa3cd32acd779c55f0f8e1ff54" title="User Datagram Protocol.">eUDP</a>) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> = ::socket(AF_INET, SOCK_DGRAM, 0);
<a name="l00308"></a>00308     <span class="keywordflow">else</span> <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::open() unsupported socket protocol&quot;</span>);
<a name="l00309"></a>00309     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) {
<a name="l00310"></a>00310         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::open() unable to allocate socket descriptor&quot;</span>);
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa2bfb38c81fc0695d99f51cc8e7291c6"></a><!-- doxytag: member="PACC::Socket::TCP::receive" ref="aa2bfb38c81fc0695d99f51cc8e7291c6" args="(char *outBuffer, unsigned inMaxCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Socket::Port::receive </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>inMaxCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive data from connected socket. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of received characters.</dd></dl>
<p>This function waits until some data is received through the socket, or until the timeout period expires. The received data is returned through output parameter <code>outBuffer</code> which must be large enough to contain up to <code>inMaxCount</code> characters. Note that this ouput buffer is NOT null terminated. The function returns the effective number of read characters contained in the output buffer. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, if the other party closes the connection (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> sockets), an exception is thrown with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a>, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if nothing is received before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">Socket::eRecvTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00319">319</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00320"></a>00320 {
<a name="l00321"></a>00321     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::receive() invalid socket&quot;</span>);
<a name="l00322"></a>00322     void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00323"></a>00323     <span class="keywordtype">int</span> lRecv = ::recv(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, outBuffer, inMaxCount, 0);
<a name="l00324"></a>00324     ::signal(SIGPIPE, lPipeMethod);
<a name="l00325"></a>00325     <span class="keywordflow">if</span>(lRecv &lt; 0) {
<a name="l00326"></a>00326         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00327"></a>00327     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lRecv == 0) {
<a name="l00328"></a>00328         <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00329"></a>00329         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331     <span class="keywordflow">return</span> lRecv;
<a name="l00332"></a>00332 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abc30f2043f597dc71e7113528824b42b"></a><!-- doxytag: member="PACC::Socket::TCP::receiveFrom" ref="abc30f2043f597dc71e7113528824b42b" args="(char *outBuffer, unsigned inMaxCount, Address &amp;outPeer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Socket::Port::receiveFrom </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>inMaxCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outPeer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive data from unconnected socket. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of received characters .</dd></dl>
<p>This function waits until some data is received through the socket, or until the timeout period expires. The received data is returned through output parameter <code>outBuffer</code> which must be large enough to contain up to <code>inMaxCount</code> characters. Note that this ouput buffer is NOT null terminated. The function returns the effective number of read characters contained in the output buffer. The peer socket address is also returned through output parameter <code>outPeer</code>. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, if the other party closes the connection (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> sockets), an exception is thrown with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a>, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if nothing is received before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">Socket::eRecvTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00339">339</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00340"></a>00340 {
<a name="l00341"></a>00341     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::receiveFrom() invalid socket&quot;</span>);
<a name="l00342"></a>00342     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00343"></a>00343     socklen_t lSize = <span class="keyword">sizeof</span>(lSock);
<a name="l00344"></a>00344     void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00345"></a>00345     <span class="keywordtype">int</span> lRecv = ::recvfrom(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, outBuffer, inMaxCount, 0, (<span class="keyword">struct </span>sockaddr*) &amp;lSock, &amp;lSize);
<a name="l00346"></a>00346     ::signal(SIGPIPE, lPipeMethod);
<a name="l00347"></a>00347     <span class="keywordflow">if</span>(lRecv &lt; 0) {
<a name="l00348"></a>00348         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00349"></a>00349     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lRecv == 0) {
<a name="l00350"></a>00350         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352     <span class="comment">// transfer peer address</span>
<a name="l00353"></a>00353     outPeer = Address(ntohs(lSock.sin_port), inet_ntoa(lSock.sin_addr));
<a name="l00354"></a>00354     <span class="keywordflow">return</span> lRecv;
<a name="l00355"></a>00355 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7213a4475b86817b0396e6cf87c917d1"></a><!-- doxytag: member="PACC::Socket::TCP::receiveMessage" ref="a7213a4475b86817b0396e6cf87c917d1" args="(string &amp;outMessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::TCP::receiveMessage </td>
          <td>(</td>
          <td class="paramtype">string &amp;&nbsp;</td>
          <td class="paramname"> <em>outMessage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive string message from connected (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a>) server. </p>
<p>This function waits for a message from the connected peer socket, or until time out. It returns the received message through output parameter <code>OutMessage</code>. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party before message end, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the timeout period expires before reception of any message. The timeout period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">Socket::eRecvTimeOut</a>. </p>

<p>Reimplemented in <a class="el" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a05f1172f301e049288c059e1b7353544">PACC::Socket::Cafe</a>.</p>

<p>Definition at line <a class="el" href="_t_c_p_8cpp_source.html#l00045">45</a> of file <a class="el" href="_t_c_p_8cpp_source.html">TCP.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00046"></a>00046 {
<a name="l00047"></a>00047     <span class="comment">// reserve adequate buffer space (if needed)</span>
<a name="l00048"></a>00048     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lRecvBufSize = (<span class="keywordtype">unsigned</span> int) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a758a6afe098539a362de79a86b5f1f1d" title="Return value of socket option inName.">getSockOpt</a>(<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>);
<a name="l00049"></a>00049     <span class="keywordflow">if</span>(outMessage.size() &lt; lRecvBufSize) outMessage.resize(lRecvBufSize);
<a name="l00050"></a>00050     <span class="comment">// receive message</span>
<a name="l00051"></a>00051     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lRecv = <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#aa2bfb38c81fc0695d99f51cc8e7291c6" title="Receive data from connected socket.">receive</a>(&amp;outMessage[0], outMessage.size());
<a name="l00052"></a>00052     <span class="comment">// resize output string</span>
<a name="l00053"></a>00053     outMessage.resize(lRecv);
<a name="l00054"></a>00054 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7e0f88dff3eacee95675eb0fcc9cc740"></a><!-- doxytag: member="PACC::Socket::TCP::send" ref="a7e0f88dff3eacee95675eb0fcc9cc740" args="(const char *inBuffer, unsigned int inCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::send </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send data to connected socket. </p>
<p>This function sends to its peer socket the <code>inCount</code> characters of data contained in buffer <code>inBuffer</code> (socket is assumed connected). Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party during message transmission, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the message cannot be sent before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">Socket::eSendTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00360">360</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00361"></a>00361 {
<a name="l00362"></a>00362     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::send() invalid socket&quot;</span>);
<a name="l00363"></a>00363     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lTotalSent = 0;
<a name="l00364"></a>00364     <span class="comment">// send all data</span>
<a name="l00365"></a>00365     <span class="keywordflow">while</span>(lTotalSent &lt; inCount) {
<a name="l00366"></a>00366         void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00367"></a>00367         <span class="keywordtype">int</span> lSent =<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket."> ::send</a>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, inBuffer+lTotalSent, inCount-lTotalSent, 0);
<a name="l00368"></a>00368         ::signal(SIGPIPE, lPipeMethod);
<a name="l00369"></a>00369         <span class="keywordflow">if</span>(lSent &lt; 0) {
<a name="l00370"></a>00370             <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00371"></a>00371         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lSent &lt; 1) {
<a name="l00372"></a>00372             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00373"></a>00373             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375         lTotalSent += lSent;
<a name="l00376"></a>00376     }
<a name="l00377"></a>00377 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adc5fb826b4851b5314c9248ed94620e9"></a><!-- doxytag: member="PACC::Socket::TCP::sendMessage" ref="adc5fb826b4851b5314c9248ed94620e9" args="(const string &amp;inMessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::TCP::sendMessage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>inMessage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send string message to connected (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a>) server. </p>
<p>This function sends message string <code>inMessage</code> to the connected peer socket. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party during message transmission, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the message cannot be sent before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">Socket::eSendTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_t_c_p_8cpp_source.html#l00060">60</a> of file <a class="el" href="_t_c_p_8cpp_source.html">TCP.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00061"></a>00061 {
<a name="l00062"></a>00062     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket.">send</a>(inMessage.data(), inMessage.size());
<a name="l00063"></a>00063 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac9c7959ca0afef4d5fa57a28fba3b4d8"></a><!-- doxytag: member="PACC::Socket::TCP::sendTo" ref="ac9c7959ca0afef4d5fa57a28fba3b4d8" args="(const char *inBuffer, unsigned int inCount, const Address &amp;inPeer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::sendTo </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inPeer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send data to unconnected socket. </p>
<p>This function sends to peer <code>inPeer</code> the data contained in buffer <code>inBuffer</code> (total of <code>inCount</code> characters). Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party during message transmission, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the message cannot be sent before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">Socket::eSendTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00382">382</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00383"></a>00383 {
<a name="l00384"></a>00384     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::sendTo() invalid socket&quot;</span>);
<a name="l00385"></a>00385     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00386"></a>00386     lSock.sin_family = AF_INET;
<a name="l00387"></a>00387     lSock.sin_port = htons(inPeer.getPortNumber());
<a name="l00388"></a>00388     lSock.sin_addr.s_addr = inet_addr(inPeer.getIPAddress().c_str());
<a name="l00389"></a>00389     memset(&amp;lSock.sin_zero, 0, 8);
<a name="l00390"></a>00390     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lTotalSent = 0;
<a name="l00391"></a>00391     <span class="comment">// send all data</span>
<a name="l00392"></a>00392     <span class="keywordflow">while</span>(lTotalSent &lt; inCount) {
<a name="l00393"></a>00393         void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00394"></a>00394         <span class="keywordtype">int</span> lSent = ::sendto(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, inBuffer+lTotalSent, inCount-lTotalSent, 0, (<span class="keyword">struct </span>sockaddr*) &amp;lSock, <span class="keyword">sizeof</span>(lSock));
<a name="l00395"></a>00395         ::signal(SIGPIPE, lPipeMethod);
<a name="l00396"></a>00396         <span class="keywordflow">if</span>(lSent &lt; 0) {
<a name="l00397"></a>00397             <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00398"></a>00398         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lSent &lt; 1) {
<a name="l00399"></a>00399             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00400"></a>00400             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402         lTotalSent += lSent;
<a name="l00403"></a>00403     }
<a name="l00404"></a>00404 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0f8abcce1ad096ea617c88b4d366e367"></a><!-- doxytag: member="PACC::Socket::TCP::setSockOpt" ref="a0f8abcce1ad096ea617c88b4d366e367" args="(Option inName, double inValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::setSockOpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Option</a>&nbsp;</td>
          <td class="paramname"> <em>inName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set socket option <code>inName</code> to value <code>inValue</code>. </p>
<p>Options are: </p>
<ul>
<li>
eKeepAlive: keep connection alive (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eLinger: time to linger on close (in seconds; <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eNoDelay: Disable the Nagle algorithm for packet coalescing (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eReuseAddress: allow reuse of address </li>
<li>
eRecvBufSize: size of receive buffer (in bytes) </li>
<li>
eSendBufSize: size of send buffer (in bytes) </li>
<li>
eRecvTimeOut: time out period for receive operations (in seconds) </li>
<li>
eSendTimeOut: time out period for send operations (in seconds) </li>
</ul>
<p>Note that for option <code>eLinger</code>, a negative value means don't linger. For options <code>eRecvTimeOut</code> and <code>eSendTimeOut</code>, a negative or nul value means dont't timeout, and a positive value of less than 1 msec will be equivalent to 1 msec. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00420">420</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00421"></a>00421 {
<a name="l00422"></a>00422     <span class="keywordtype">int</span> lBuffer[2] = {0, 0};
<a name="l00423"></a>00423     socklen_t lSize;
<a name="l00424"></a>00424     <span class="keywordflow">switch</span>(inName) {
<a name="l00425"></a>00425         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fad094f0c703765e462059f4c8a92b7292" title="Keep connection alive.">eKeepAlive</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa1839a506c945f06a24ded765b5ece67a" title="Allow reuse of a TCP address without delay.">eReuseAddress</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faf5ee4bfe5d2341a7875edb7ff10ff1c2" title="Size of send buffer (in number of chars).">eSendBufSize</a>:
<a name="l00426"></a>00426             lBuffer[0] = (int) inValue;
<a name="l00427"></a>00427             lSize = <span class="keyword">sizeof</span>(int);
<a name="l00428"></a>00428             <span class="keywordflow">break</span>;
<a name="l00429"></a>00429         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fae0dcf7836a0dbfe6de1d8de7f5c1aa47" title="Time to linger on close (in seconds).">eLinger</a>:
<a name="l00430"></a>00430         {
<a name="l00431"></a>00431             <span class="comment">// warning: the linger structure is not the same size on windows and unix!</span>
<a name="l00432"></a>00432             <span class="keyword">struct </span>linger* lPtr = (<span class="keyword">struct </span>linger*) lBuffer;
<a name="l00433"></a>00433 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span>            lPtr-&gt;l_onoff = (u_short) (inValue &gt;= 0);
<a name="l00435"></a>00435             lPtr-&gt;l_linger = (u_short) (inValue &gt;= 0 ? inValue : 0);
<a name="l00436"></a>00436 <span class="preprocessor">#else</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span>            lPtr-&gt;l_onoff = (int) (inValue &gt;= 0);
<a name="l00438"></a>00438             lPtr-&gt;l_linger = (int) (inValue &gt;= 0 ? inValue : 0);
<a name="l00439"></a>00439 <span class="preprocessor">#endif</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span>        }
<a name="l00441"></a>00441             lSize = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>linger);
<a name="l00442"></a>00442             <span class="keywordflow">break</span>;
<a name="l00443"></a>00443         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">eRecvTimeOut</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">eSendTimeOut</a>:
<a name="l00444"></a>00444             <span class="keywordflow">if</span>(inValue &lt; 0) inValue = 0;
<a name="l00445"></a>00445             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(inValue &gt; 0 &amp;&amp; inValue &lt; 0.001) inValue = 0.001;
<a name="l00446"></a>00446 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span>                <span class="comment">// on windows, timeout must be specified in milliseconds</span>
<a name="l00448"></a>00448                 lBuffer[0] = (int) (1000*inValue);
<a name="l00449"></a>00449             lSize = <span class="keyword">sizeof</span>(int);
<a name="l00450"></a>00450 <span class="preprocessor">#else</span>
<a name="l00451"></a>00451 <span class="preprocessor"></span>            <span class="comment">// on unix, timeout must be specified with timeval structure</span>
<a name="l00452"></a>00452             {
<a name="l00453"></a>00453                 <span class="keyword">struct </span>timeval* lPtr = (<span class="keyword">struct </span>timeval*) lBuffer;
<a name="l00454"></a>00454                 lPtr-&gt;tv_sec = (int32_t) inValue;
<a name="l00455"></a>00455                 lPtr-&gt;tv_usec = (int32_t) ((inValue-lPtr-&gt;tv_sec)*1000000);
<a name="l00456"></a>00456                 lSize = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>timeval);
<a name="l00457"></a>00457             }
<a name="l00458"></a>00458 <span class="preprocessor">#endif</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span>                <span class="keywordflow">break</span>;
<a name="l00460"></a>00460         <span class="keywordflow">default</span>:
<a name="l00461"></a>00461             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::setSockOpt() unsupported socket option&quot;</span>);
<a name="l00462"></a>00462     }
<a name="l00463"></a>00463     <span class="keywordflow">if</span>(::setsockopt(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (inName==<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>?IPPROTO_TCP:SOL_SOCKET), <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a3d153806aea01830530f4ea04c0f338b" title="Convert socket option inName to native socket option code.">convertToNativeOption</a>(inName), (<span class="keywordtype">char</span>*)lBuffer, lSize) != 0)
<a name="l00464"></a>00464     {
<a name="l00465"></a>00465         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::setSockOpt() unable to set socket option&quot;</span>);
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a27ed19ee09dc2503886c071edc813cc8"></a><!-- doxytag: member="PACC::Socket::TCP::waitForActivity" ref="a27ed19ee09dc2503886c071edc813cc8" args="(double inSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Socket::Port::waitForActivity </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inSeconds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for activity. </p>
<p>This function waits for any socket activity for up to <code>inSeconds</code> seconds. The three types of activities are: ready for read, ready for write, and pending errors. It returns true if an activity is detected before timeout, and false otherwise. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00472">472</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00473"></a>00473 {
<a name="l00474"></a>00474     fd_set lRead, lWrite, lError;
<a name="l00475"></a>00475     FD_ZERO(&amp;lRead);
<a name="l00476"></a>00476     FD_SET(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lRead);
<a name="l00477"></a>00477     FD_ZERO(&amp;lWrite);
<a name="l00478"></a>00478     FD_SET(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lWrite);
<a name="l00479"></a>00479     FD_ZERO(&amp;lError);
<a name="l00480"></a>00480     FD_SET(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lError);
<a name="l00481"></a>00481     <span class="keyword">struct </span>timeval lTime;
<a name="l00482"></a>00482     lTime.tv_sec = (long) inSeconds;
<a name="l00483"></a>00483     lTime.tv_usec = (long) ((inSeconds-lTime.tv_sec)*1000000);
<a name="l00484"></a>00484     <span class="keywordflow">return</span> select(FD_SETSIZE, &amp;lRead, &amp;lWrite, &amp;lError, &amp;lTime) == 1;
<a name="l00485"></a>00485 }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PACC/Socket/<a class="el" href="_t_c_p_8hpp_source.html">TCP.hpp</a></li>
<li>PACC/Socket/<a class="el" href="_t_c_p_8cpp_source.html">TCP.cpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jan 31 15:10:20 2010 for PACC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
