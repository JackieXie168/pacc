<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PACC: PACC::Threading::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_c_c.html">PACC</a>::<a class="el" href="namespace_p_a_c_c_1_1_threading.html">Threading</a>::<a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html">Thread</a>
  </div>
</div>
<div class="contents">
<h1>PACC::Threading::Thread Class Reference<br/>
<small>
[<a class="el" href="group___threading.html">Threading: portable thread management</a>]</small>
</h1><!-- doxytag: class="PACC::Threading::Thread" --><!-- doxytag: inherits="PACC::Threading::Condition" -->
<p>Abstract thread.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_thread_8hpp_source.html">Thread.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PACC::Threading::Thread:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_p_a_c_c_1_1_threading_1_1_thread.gif" usemap="#PACC::Threading::Thread_map" alt=""/>
  <map id="PACC::Threading::Thread_map" name="PACC::Threading::Thread_map">
<area href="class_p_a_c_c_1_1_threading_1_1_condition.html" alt="PACC::Threading::Condition" shape="rect" coords="99,56,287,80"/>
<area href="class_p_a_c_c_1_1_threading_1_1_mutex.html" alt="PACC::Threading::Mutex" shape="rect" coords="99,0,287,24"/>
<area href="class_p_a_c_c_1_1_socket_1_1_server_thread.html" alt="PACC::Socket::ServerThread" shape="rect" coords="0,168,188,192"/>
<area href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html" alt="PACC::Threading::SlaveThread" shape="rect" coords="198,168,386,192"/>
</map>
 </div>
</div>

<p><a href="class_p_a_c_c_1_1_threading_1_1_thread-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a1ce15affadbef9c3e6f4dde06110e211">Thread</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create thread.  <a href="#a1ce15affadbef9c3e6f4dde06110e211"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a5e1b8b31a35a57cbd449643699561a78">~Thread</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete thread.  <a href="#a5e1b8b31a35a57cbd449643699561a78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aee017bb71dd63da6f4dc95b7edbc5e53">cancel</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel execution of thread.  <a href="#aee017bb71dd63da6f4dc95b7edbc5e53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a11a768f0e39d46debe24799b569b7181">isRunning</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check wheter or not the thread is currently running.  <a href="#a11a768f0e39d46debe24799b569b7181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abffb7a8b1f0bcf8c71d86130e9a91579"></a><!-- doxytag: member="PACC::Threading::Thread::isSelf" ref="abffb7a8b1f0bcf8c71d86130e9a91579" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#abffb7a8b1f0bcf8c71d86130e9a91579">isSelf</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether the calling thread is the same as this thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ab38b3bdd86b8c1e75f7e9e0d9b4555ea">run</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and startup thread.  <a href="#ab38b3bdd86b8c1e75f7e9e0d9b4555ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946">wait</a> (bool inLock=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for thread termination.  <a href="#ac79a458c34d93c08d4cb5f00dbb09946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a5103716b4853043b7e68a9ace2193a22">broadcast</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broadcast a wake up signal to all waiting threads.  <a href="#a5103716b4853043b7e68a9ace2193a22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#aa1c0ab62547bc517761df1ddcde8faed">signal</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal a single waiting thread to wake up (which waiting thread wakes up is undetermined).  <a href="#aa1c0ab62547bc517761df1ddcde8faed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a678ef989bf3d6a806907fc2632ad3a60">wait</a> (double inMaxTime=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait up to <code>inMaxTime</code> seconds for the condition to be signaled (or broadcasted).  <a href="#a678ef989bf3d6a806907fc2632ad3a60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8">lock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the mutex.  <a href="#a614784b931143e8ccb460e2a4ac9a3e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a831807e017053475f53203505168548d">tryLock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to lock the mutex without blocking.  <a href="#a831807e017053475f53203505168548d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d">unlock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the mutex.  <a href="#ac56644852bc8f3afa80372491045955d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a7fdc459d74d538dba730d2c09cb56dda">sleep</a> (double inSeconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sleep calling thread for <code>inSeconds</code> seconds.  <a href="#a7fdc459d74d538dba730d2c09cb56dda"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a92d700d8f73300ea118e0bbcf4f57f21">main</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements main procedure of thread.  <a href="#a92d700d8f73300ea118e0bbcf4f57f21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a74093833bc523c83dea2d62981cc5a39">makeCancellationPoint</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create cancellation point.  <a href="#a74093833bc523c83dea2d62981cc5a39"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa16693f58797d092bc80001039b2f040"></a><!-- doxytag: member="PACC::Threading::Thread::mThread" ref="aa16693f58797d092bc80001039b2f040" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040">mThread</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e3d695ada216ddcc42d433f4606e349"></a><!-- doxytag: member="PACC::Threading::Thread::mCancel" ref="a0e3d695ada216ddcc42d433f4606e349" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349">mCancel</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should be canceled flag. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9788ffad4188072b492cf13bdf722f62"></a><!-- doxytag: member="PACC::Threading::Thread::mRunning" ref="a9788ffad4188072b492cf13bdf722f62" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62">mRunning</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is running flag. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a522f03215ec1b3dc7e49f14da402f21b"></a><!-- doxytag: member="PACC::Threading::Thread::mCondition" ref="a522f03215ec1b3dc7e49f14da402f21b" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b">mCondition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native condition. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a3148fa4affbe20e96b7f0593c06e89"></a><!-- doxytag: member="PACC::Threading::Thread::mMutex" ref="a6a3148fa4affbe20e96b7f0593c06e89" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89">mMutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native mutex. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Abstract thread. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Marc Parizeau, Laboratoire de vision et syst&egrave;mes num&eacute;riques, Universit&eacute; Laval</dd></dl>
<p>This class incapsulates an abstract cross-platform thread. It should be subclassed in order to define virtual member function <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a92d700d8f73300ea118e0bbcf4f57f21" title="Implements main procedure of thread.">Thread::main</a> which is called soon after thread creation (see <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ab38b3bdd86b8c1e75f7e9e0d9b4555ea" title="Create and startup thread.">Thread::run</a>). The thread terminates when main returns or after a call to <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aee017bb71dd63da6f4dc95b7edbc5e53" title="Cancel execution of thread.">Thread::cancel</a> is honored by a subsequent cancellation point. A cancellation point can be created by a call to <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a74093833bc523c83dea2d62981cc5a39" title="Create cancellation point.">Thread::makeCancellationPoint</a>.</p>
<p>This class should be compatible with any flavour of Unix that supports POSIX threads. It should also be compatible will any version of Windows that is supported by class <a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html" title="Condition for thread synchronization.">Condition</a> (refer to its documentation for more details). It has been tested under Linux, MacOS X, and Windows 2000/XP. </p>

<p>Definition at line <a class="el" href="_thread_8hpp_source.html#l00053">53</a> of file <a class="el" href="_thread_8hpp_source.html">Thread.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1ce15affadbef9c3e6f4dde06110e211"></a><!-- doxytag: member="PACC::Threading::Thread::Thread" ref="a1ce15affadbef9c3e6f4dde06110e211" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Threading::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create thread. </p>
<p>Note that method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ab38b3bdd86b8c1e75f7e9e0d9b4555ea" title="Create and startup thread.">Thread::run</a> must be called in order to start the execution of <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a92d700d8f73300ea118e0bbcf4f57f21" title="Implements main procedure of thread.">Thread::main</a>. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00063">63</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00063"></a>00063 : <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040" title="Opaque structure of native thread.">mThread</a>(0), <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349" title="Should be canceled flag.">mCancel</a>(<span class="keyword">false</span>), <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a>(<span class="keyword">false</span>) {}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5e1b8b31a35a57cbd449643699561a78"></a><!-- doxytag: member="PACC::Threading::Thread::~Thread" ref="a5e1b8b31a35a57cbd449643699561a78" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Threading::Thread::~Thread </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete thread. </p>
<p>Assuming that the caller has canceled the thread and waited for its termination, this method detaches the thread and deletes its native structure. In debug mode, if the thread is found still running, then the method aborts the application with a descriptive fatal error message.</p>
<p>A good strategy is to always define a destructor in the derived class, and to make this destructor wait for thread termination. For instance: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyThread : <span class="keyword">public</span> Threading::<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a1ce15affadbef9c3e6f4dde06110e211" title="Create thread.">Thread</a> {
    ...
    ~MyThread(<span class="keywordtype">void</span>) {<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946" title="Wait for thread termination.">wait</a>();}
    ...
};
</pre></div><p>The calling thread can also use method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aee017bb71dd63da6f4dc95b7edbc5e53" title="Cancel execution of thread.">Thread::cancel</a> to request early termination for this thread. But thread cancellation is asynchronous, it will be deferred to the next cancellation point. From within <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a92d700d8f73300ea118e0bbcf4f57f21" title="Implements main procedure of thread.">Thread::main</a>, in order to allow rapid thread cancellation, method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a74093833bc523c83dea2d62981cc5a39" title="Create cancellation point.">Thread::makeCancellationPoint</a> should be called as often as possible whenever it is safe to cancel the thread. A running thread that omits cancellation points and never terminates will block the calling thread of this method indefinitely.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>If the destructor in the derived thread class (e.g. MyThread above) does not wait for thread termination, the potential hazardous situation is that the runtime system will have deleted all of its members before calling this destructor (in C++, class destructors are called in reversed sequence). Thus, the still running thread could access deleted data members with unpredictable and unexpected results. So beware! </dd></dl>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00082">82</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00083"></a>00083 {
<a name="l00084"></a>00084     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">lock</a>();
<a name="l00085"></a>00085     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040" title="Opaque structure of native thread.">mThread</a>) {
<a name="l00086"></a>00086         <span class="comment">// make sure that thread is no longer running</span>
<a name="l00087"></a>00087         <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(!<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a>, <span class="stringliteral">&quot;Destructor called without first cancelling the thread and waiting for its termination. Please correct the situation because it is potentially very hazardous!&quot;</span>);
<a name="l00088"></a>00088         <span class="comment">// detach thread</span>
<a name="l00089"></a>00089         ThreadStruct* lThread = (ThreadStruct*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040" title="Opaque structure of native thread.">mThread</a>;
<a name="l00090"></a>00090 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(::WaitForSingleObject(lThread-&gt;mHandle, INFINITE) == WAIT_FAILED)
<a name="l00092"></a>00092 #<span class="keywordflow">else</span> <span class="comment">// Unix...</span>
<a name="l00093"></a>00093         <span class="keywordflow">if</span>(::pthread_join(*lThread, 0) != 0)
<a name="l00094"></a>00094 #endif
<a name="l00095"></a>00095         {
<a name="l00096"></a>00096             <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Thread::~Thread() unable to join thread&quot;</span>);
<a name="l00097"></a>00097         }
<a name="l00098"></a>00098         <span class="comment">// delete native structure</span>
<a name="l00099"></a>00099         <span class="keyword">delete</span> lThread;
<a name="l00100"></a>00100         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040" title="Opaque structure of native thread.">mThread</a> = 0;
<a name="l00101"></a>00101     }
<a name="l00102"></a>00102     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00103"></a>00103 }
</pre></div></p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5103716b4853043b7e68a9ace2193a22"></a><!-- doxytag: member="PACC::Threading::Thread::broadcast" ref="a5103716b4853043b7e68a9ace2193a22" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Condition::broadcast </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Broadcast a wake up signal to all waiting threads. </p>
<p>This method assumes that the embedded mutex has already been LOCKED by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>). It allows the caller to execute some thread critical operations like setting an external condition prior to broadcasting. If no thread is waiting, the signal is simply ignored. Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">lCondition.lock();
<span class="comment">// set some external condition</span>
...
lCondition.broadcast();
lCondition.unlock();
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00113">113</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00114"></a>00114 {
<a name="l00115"></a>00115     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00116"></a>00116 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00118"></a>00118     <span class="keywordflow">if</span>(lCondition-&gt;mWaiters &gt; 0) {
<a name="l00119"></a>00119         lCondition-&gt;mBroadcast = <span class="keyword">true</span>;
<a name="l00120"></a>00120         <span class="comment">// wake up the waiting threads atomically</span>
<a name="l00121"></a>00121         <span class="keywordflow">if</span>(!::ReleaseSemaphore(lCondition-&gt;mSemaphore, lCondition-&gt;mWaiters, 0)) {
<a name="l00122"></a>00122             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00123"></a>00123             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() unable to release semaphore!&quot;</span>);
<a name="l00124"></a>00124         }
<a name="l00125"></a>00125         <span class="comment">// wait for threads to acquire the counting semaphore</span>
<a name="l00126"></a>00126         LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00127"></a>00127         <span class="keywordflow">if</span>(::WaitForSingleObject(lCondition-&gt;mDone, INFINITE) != WAIT_OBJECT_0) {
<a name="l00128"></a>00128             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00129"></a>00129             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() invalid event!&quot;</span>);
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131         lCondition-&gt;mBroadcast = <span class="keyword">false</span>;
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133     <span class="keywordflow">else</span> LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00134"></a>00134 <span class="preprocessor">#else</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::pthread_cond_broadcast(lCondition) != 0) {
<a name="l00136"></a>00136         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00137"></a>00137         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() invalid condition!&quot;</span>);
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139 <span class="preprocessor">#endif</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="aee017bb71dd63da6f4dc95b7edbc5e53"></a><!-- doxytag: member="PACC::Threading::Thread::cancel" ref="aee017bb71dd63da6f4dc95b7edbc5e53" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Thread::cancel </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel execution of thread. </p>
<p>The cancellation process requested by this function runs asynchronously with the calling thread. The latter can call function <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946" title="Wait for thread termination.">Thread::wait</a> in order to wait for thread termination. The cancelled thread will not terminate before it reaches its next cancellation point, or before it terminates by itself. Before deleting a cancelled thread, the caller should always wait for thread termination.</p>
<p>The caller should always lock the thread (using the lock method) prior to asking for cancellation. If it wishes to wait immediately for thread termination, it should keep the thread locked and call the wait method with argument false (see <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946" title="Wait for thread termination.">Thread::wait</a>). </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00111">111</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00112"></a>00112 {
<a name="l00113"></a>00113     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349" title="Should be canceled flag.">mCancel</a> = <span class="keyword">true</span>;
<a name="l00114"></a>00114 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a11a768f0e39d46debe24799b569b7181"></a><!-- doxytag: member="PACC::Threading::Thread::isRunning" ref="a11a768f0e39d46debe24799b569b7181" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Thread::isRunning </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check wheter or not the thread is currently running. </p>
<p>The caller should always lock the thread (using the lock method) prior to checking the running flag. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00120">120</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00121"></a>00121 {
<a name="l00122"></a>00122     <span class="keywordflow">return</span> <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a>;
<a name="l00123"></a>00123 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a614784b931143e8ccb460e2a4ac9a3e8"></a><!-- doxytag: member="PACC::Threading::Thread::lock" ref="a614784b931143e8ccb460e2a4ac9a3e8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Mutex::lock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock the mutex. </p>
<p>A thread should never lock a mutex twice consecutively (without calling method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">Mutex::unlock</a>). Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00087">87</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00088"></a>00088 {
<a name="l00089"></a>00089     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00090"></a>00090 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::WaitForSingleObject(*lMutex, INFINITE) != WAIT_OBJECT_0)
<a name="l00092"></a>00092 #<span class="keywordflow">else</span>
<a name="l00093"></a>00093         <span class="keywordflow">if</span>(::pthread_mutex_lock(lMutex) != 0) 
<a name="l00094"></a>00094 #endif
<a name="l00095"></a>00095             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afba3c013a24ae9803571dbbe6651fc65a7a" title="Operation would produce a dead lock.">eWouldDeadLock</a>, <span class="stringliteral">&quot;Mutex::lock() can&apos;t lock!&quot;</span>);
<a name="l00096"></a>00096 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a92d700d8f73300ea118e0bbcf4f57f21"></a><!-- doxytag: member="PACC::Threading::Thread::main" ref="a92d700d8f73300ea118e0bbcf4f57f21" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PACC::Threading::Thread::main </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements main procedure of thread. </p>
<p>This virtual method must be overloaded in a derived class in order to implement the main procedure of this thread. As much as possible, and whenever it is safe to cancel execution, this method should call <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a74093833bc523c83dea2d62981cc5a39" title="Create cancellation point.">Thread::makeCancellationPoint</a> so that this thread can be canceled by other threads (including deleted by the main thread). Otherwise, any thread cancellation (or deletion) will be postponed until after main returns. For instance, if main's implementation requires a loop, a cancellation point should be included at least once for each iteration. </p>

<p>Implemented in <a class="el" href="class_p_a_c_c_1_1_socket_1_1_server_thread.html#ac1d0618fdae73e975d1451bc854d5e16">PACC::Socket::ServerThread</a>, and <a class="el" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#ab32671f2aaaa7c270b84281051679014">PACC::Threading::SlaveThread</a>.</p>

</div>
</div>
<a class="anchor" id="a74093833bc523c83dea2d62981cc5a39"></a><!-- doxytag: member="PACC::Threading::Thread::makeCancellationPoint" ref="a74093833bc523c83dea2d62981cc5a39" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Thread::makeCancellationPoint </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create cancellation point. </p>
<p>This function should be called by <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a92d700d8f73300ea118e0bbcf4f57f21" title="Implements main procedure of thread.">Thread::main</a> as often as possible in order to enable thread cancellation. A <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aee017bb71dd63da6f4dc95b7edbc5e53" title="Cancel execution of thread.">Thread::cancel</a> request can only be honored at a future cancellation point. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00145">145</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00146"></a>00146 {
<a name="l00147"></a>00147     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">lock</a>();
<a name="l00148"></a>00148     <span class="comment">// exit thread if cancellation was requested</span>
<a name="l00149"></a>00149     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349" title="Should be canceled flag.">mCancel</a>) {
<a name="l00150"></a>00150         <span class="comment">// signal all that thread has terminated</span>
<a name="l00151"></a>00151         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a> = <span class="keyword">false</span>;
<a name="l00152"></a>00152         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a5103716b4853043b7e68a9ace2193a22" title="Broadcast a wake up signal to all waiting threads.">broadcast</a>();
<a name="l00153"></a>00153         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00154"></a>00154         <span class="comment">// now exit thread</span>
<a name="l00155"></a>00155 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span>        ::ExitThread(0);
<a name="l00157"></a>00157 <span class="preprocessor">#else // Unix...</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span>        ::pthread_exit(0);
<a name="l00159"></a>00159 <span class="preprocessor">#endif</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>    }
<a name="l00161"></a>00161     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00162"></a>00162 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab38b3bdd86b8c1e75f7e9e0d9b4555ea"></a><!-- doxytag: member="PACC::Threading::Thread::run" ref="ab38b3bdd86b8c1e75f7e9e0d9b4555ea" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Thread::run </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create and startup thread. </p>
<p>This function allocates memory for the native thread structure, and then creates the thread which starts up asynchronously. The calling thread will block until this thread as actually started to run.</p>
<p>Any error will raise a <a class="el" href="namespace_p_a_c_c_1_1_threading.html" title="Portable thread management classes.">Threading</a>:<a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Exception</a>. In particular, this method should not be called if the thread is already running. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00170">170</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00171"></a>00171 {
<a name="l00172"></a>00172     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">lock</a>();
<a name="l00173"></a>00173     <span class="comment">// check that thread is not already running</span>
<a name="l00174"></a>00174     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a>) {
<a name="l00175"></a>00175         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00176"></a>00176         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afba655cedbfb54eefdb53c332bb56511968" title="Thread is already running.">eRunning</a>, <span class="stringliteral">&quot;Thread::run() thread is already running!&quot;</span>);
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349" title="Should be canceled flag.">mCancel</a> = <span class="keyword">false</span>;
<a name="l00179"></a>00179     <span class="comment">// allocate native structure</span>
<a name="l00180"></a>00180     <span class="keywordflow">if</span>(!<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040" title="Opaque structure of native thread.">mThread</a>) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040" title="Opaque structure of native thread.">mThread</a> = <span class="keyword">new</span> ThreadStruct;
<a name="l00181"></a>00181     ThreadStruct* lThread = (ThreadStruct*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040" title="Opaque structure of native thread.">mThread</a>;
<a name="l00182"></a>00182     <span class="comment">// create thread</span>
<a name="l00183"></a>00183 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>    <span class="keywordflow">if</span>((lThread-&gt;mHandle = ::CreateThread(0, 0, (LPTHREAD_START_ROUTINE)startup, <span class="keyword">this</span>, 0, &amp;lThread-&gt;mId)) == 0)
<a name="l00185"></a>00185 #<span class="keywordflow">else</span> <span class="comment">// Unix</span>
<a name="l00186"></a>00186     <span class="keywordflow">if</span>(::pthread_create(lThread, 0, startup, <span class="keyword">this</span>) != 0)  
<a name="l00187"></a>00187 #endif
<a name="l00188"></a>00188     {
<a name="l00189"></a>00189         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00190"></a>00190         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Thread::run() can&apos;t create thread!&quot;</span>);
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192     <span class="comment">// wait for thread to start up</span>
<a name="l00193"></a>00193     <span class="keywordflow">if</span>(!<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a>) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946" title="Wait for thread termination.">Condition::wait</a>();
<a name="l00194"></a>00194     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00195"></a>00195 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa1c0ab62547bc517761df1ddcde8faed"></a><!-- doxytag: member="PACC::Threading::Thread::signal" ref="aa1c0ab62547bc517761df1ddcde8faed" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Condition::signal </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal a single waiting thread to wake up (which waiting thread wakes up is undetermined). </p>
<p>This method assumes that the embedded mutex has already been locked by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>). It allows the caller to execute some thread critical operations, like setting or resetting external conditions. If no thread is waiting, the signal is simply ignored. Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">lCondition.lock();
<span class="comment">// set some external condition</span>
...
lCondition.signal();
lCondition.unlock();
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00156">156</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00157"></a>00157 {
<a name="l00158"></a>00158     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00159"></a>00159 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00161"></a>00161     <span class="keywordtype">int</span> lWaiters = lCondition-&gt;mWaiters;
<a name="l00162"></a>00162     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00163"></a>00163     <span class="comment">// wake up a single waiting thread if any waiters</span>
<a name="l00164"></a>00164     <span class="keywordflow">if</span>(lWaiters &gt; 0 &amp;&amp; ::ReleaseSemaphore(lCondition-&gt;mSemaphore, 1, 0) == 0)
<a name="l00165"></a>00165 <span class="preprocessor">#else</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(::pthread_cond_signal(lCondition) != 0)
<a name="l00167"></a>00167 <span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>        {
<a name="l00169"></a>00169             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00170"></a>00170             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::signal() invalid condition!&quot;</span>);
<a name="l00171"></a>00171         }
<a name="l00172"></a>00172 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7fdc459d74d538dba730d2c09cb56dda"></a><!-- doxytag: member="PACC::Threading::Thread::sleep" ref="a7fdc459d74d538dba730d2c09cb56dda" args="(double inSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Thread::sleep </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inSeconds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sleep calling thread for <code>inSeconds</code> seconds. </p>
<p>A negative value will throw a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00201">201</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00202"></a>00202 {
<a name="l00203"></a>00203     <span class="keywordflow">if</span>(inSeconds &lt; 0) <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Thread::sleep() invalid time&quot;</span>);
<a name="l00204"></a>00204 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span>    <span class="comment">// argument must be in milliseconds for windows</span>
<a name="l00206"></a>00206     ::Sleep((DWORD)(1000*inSeconds));
<a name="l00207"></a>00207 <span class="preprocessor">#else // Unix...</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(inSeconds &lt; 1000) {
<a name="l00209"></a>00209         <span class="comment">// use microsecond sleep</span>
<a name="l00210"></a>00210         <span class="keywordflow">if</span>(::usleep((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(1000000*inSeconds)) != 0) {
<a name="l00211"></a>00211             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Thread::sleep() can&apos;t sleep&quot;</span>);
<a name="l00212"></a>00212         }
<a name="l00213"></a>00213     } <span class="keywordflow">else</span> {
<a name="l00214"></a>00214         <span class="comment">// use regular sleep</span>
<a name="l00215"></a>00215         <span class="keywordflow">if</span>(::<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a7fdc459d74d538dba730d2c09cb56dda" title="Sleep calling thread for inSeconds seconds.">sleep</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(inSeconds)) != 0) {
<a name="l00216"></a>00216             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Thread::sleep() can&apos;t sleep&quot;</span>);
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219 <span class="preprocessor">#endif</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a831807e017053475f53203505168548d"></a><!-- doxytag: member="PACC::Threading::Thread::tryLock" ref="a831807e017053475f53203505168548d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Mutex::tryLock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to lock the mutex without blocking. </p>
<p>Return's true if successful; false otherwise.</p>
<p>Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00104">104</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00105"></a>00105 {
<a name="l00106"></a>00106     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00107"></a>00107 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>    <span class="keywordtype">int</span> lValue = ::WaitForSingleObject(*lMutex, 0);
<a name="l00109"></a>00109     <span class="keywordflow">if</span>(lValue == WAIT_TIMEOUT) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00110"></a>00110     <span class="keywordflow">if</span>(lValue != WAIT_OBJECT_0)
<a name="l00111"></a>00111 <span class="preprocessor">#else</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>        <span class="keywordtype">int</span> lValue = ::pthread_mutex_trylock(lMutex);
<a name="l00113"></a>00113     <span class="keywordflow">if</span>(lValue == EBUSY) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00114"></a>00114     <span class="keywordflow">if</span>(lValue != 0) 
<a name="l00115"></a>00115 <span class="preprocessor">#endif</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>        <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Mutex::trylock() can&apos;t trylock!&quot;</span>);
<a name="l00117"></a>00117     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00118"></a>00118 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac56644852bc8f3afa80372491045955d"></a><!-- doxytag: member="PACC::Threading::Thread::unlock" ref="ac56644852bc8f3afa80372491045955d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Mutex::unlock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the mutex. </p>
<p>A thread should never unlock a mutex twice consecutively (without calling method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Mutex::lock</a>). Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00125">125</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00126"></a>00126 {
<a name="l00127"></a>00127     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00128"></a>00128 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::ReleaseMutex(*lMutex) == 0)
<a name="l00130"></a>00130 #<span class="keywordflow">else</span>
<a name="l00131"></a>00131         <span class="keywordflow">if</span>(::pthread_mutex_unlock(lMutex) != 0)
<a name="l00132"></a>00132 #endif
<a name="l00133"></a>00133             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afba158cbdf072ad8c387b006134f3d32e75" title="Mutex not own by calling thread.">eMutexNotOwned</a>, <span class="stringliteral">&quot;Mutex::unlock() can&apos;t unlock!&quot;</span>);
<a name="l00134"></a>00134 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a678ef989bf3d6a806907fc2632ad3a60"></a><!-- doxytag: member="PACC::Threading::Thread::wait" ref="a678ef989bf3d6a806907fc2632ad3a60" args="(double inMaxTime=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Condition::wait </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inMaxTime</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait up to <code>inMaxTime</code> seconds for the condition to be signaled (or broadcasted). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if condition was signaled (or broadcasted), false if timed out.</dd></dl>
<p>This method assumes that the embedded mutex has already been locked by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>), and will also return with the mutex locked. A negative or null time out (default) means that the method should wait indefinitely.</p>
<p>Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">...
lCondition.lock();
<span class="keywordflow">if</span>(external_condition == <span class="keyword">false</span>) {
    <span class="comment">// wait indefinitely...</span>
    lCondition.wait();
    <span class="comment">// reset external condition</span>
    ...
}
lCondition.unlock();
...
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00196">196</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00197"></a>00197 {
<a name="l00198"></a>00198     <span class="keywordtype">bool</span> lReturn;
<a name="l00199"></a>00199     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00200"></a>00200 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00202"></a>00202     <span class="comment">// increment number of waiters</span>
<a name="l00203"></a>00203     lCondition-&gt;mWaiters += 1;
<a name="l00204"></a>00204     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00205"></a>00205     <span class="comment">// wait for the semaphore after atomically unlocking the mutex</span>
<a name="l00206"></a>00206     HANDLE* lMutex = (HANDLE*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00207"></a>00207     DWORD lRes = ::SignalObjectAndWait(*lMutex, lCondition-&gt;mSemaphore, (inMaxTime &lt;= 0 ? INFINITE : (DWORD)(inMaxTime*1000)), <span class="keyword">false</span>);
<a name="l00208"></a>00208     <span class="keywordflow">if</span>((lReturn = (lRes != WAIT_TIMEOUT)) &amp;&amp; lRes != WAIT_OBJECT_0) {
<a name="l00209"></a>00209         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00210"></a>00210         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid semaphore!&quot;</span>);
<a name="l00211"></a>00211     }   
<a name="l00212"></a>00212     EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00213"></a>00213     <span class="comment">// we&apos;re no longer waiting, decrement number of waiters</span>
<a name="l00214"></a>00214     lCondition-&gt;mWaiters -= 1;
<a name="l00215"></a>00215     <span class="keywordtype">bool</span> lLastWaiter = lCondition-&gt;mBroadcast &amp;&amp; lCondition-&gt;mWaiters == 0;
<a name="l00216"></a>00216     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00217"></a>00217     <span class="keywordflow">if</span>(lLastWaiter) {
<a name="l00218"></a>00218         <span class="comment">// wait for the mutex after atomically signaling the broadcaster that all threads have awakened</span>
<a name="l00219"></a>00219         <span class="keywordflow">if</span>(::SignalObjectAndWait(lCondition-&gt;mDone, *lMutex, INFINITE, <span class="keyword">false</span>) != WAIT_OBJECT_0)
<a name="l00220"></a>00220         {
<a name="l00221"></a>00221             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00222"></a>00222             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid mutex!&quot;</span>);
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(::WaitForSingleObject(*lMutex, INFINITE) != WAIT_OBJECT_0) {
<a name="l00226"></a>00226         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00227"></a>00227         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid mutex!&quot;</span>);
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 <span class="preprocessor">#else</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span>    <span class="keywordtype">int</span> lRes;
<a name="l00231"></a>00231     <span class="comment">// pthread_cond_wait atomically unlocks the mutex, waits on the condition, and locks the mutex again</span>
<a name="l00232"></a>00232     <span class="keywordflow">if</span>(inMaxTime &lt;= 0) lRes = ::pthread_cond_wait(lCondition, (pthread_mutex_t*)<a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>);
<a name="l00233"></a>00233     <span class="keywordflow">else</span> {
<a name="l00234"></a>00234         <span class="comment">// get time of day and add specified time out</span>
<a name="l00235"></a>00235         <span class="keyword">struct </span>timeval lVal;
<a name="l00236"></a>00236         ::gettimeofday(&amp;lVal, 0);
<a name="l00237"></a>00237         <span class="keyword">struct </span>timespec lSpec;
<a name="l00238"></a>00238         lSpec.tv_sec = lVal.tv_sec + (long) inMaxTime;
<a name="l00239"></a>00239         lSpec.tv_nsec = lVal.tv_usec*1000 + (long) ((inMaxTime - floor(inMaxTime)) * 1000000000);
<a name="l00240"></a>00240         <span class="comment">// check that the number of nanoseconds is less than 1 sec</span>
<a name="l00241"></a>00241         <span class="keywordflow">if</span>(lSpec.tv_nsec &gt;= 1000000000)
<a name="l00242"></a>00242         {
<a name="l00243"></a>00243             <span class="comment">// otherwise adjust...</span>
<a name="l00244"></a>00244             lSpec.tv_nsec -= 1000000000;
<a name="l00245"></a>00245             lSpec.tv_sec += 1;
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247         <span class="comment">// pthread_cond_timedwait atomically unlocks the mutex, waits on the condition, and locks the mutex again</span>
<a name="l00248"></a>00248         lRes = ::pthread_cond_timedwait(lCondition, (pthread_mutex_t*)<a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>, &amp;lSpec);
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250     <span class="keywordflow">if</span>((lReturn = (lRes != ETIMEDOUT)) &amp;&amp; lRes != 0)
<a name="l00251"></a>00251     {
<a name="l00252"></a>00252         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00253"></a>00253         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid condition!&quot;</span>);
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255 <span class="preprocessor">#endif</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span>    <span class="keywordflow">return</span> lReturn;
<a name="l00257"></a>00257 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac79a458c34d93c08d4cb5f00dbb09946"></a><!-- doxytag: member="PACC::Threading::Thread::wait" ref="ac79a458c34d93c08d4cb5f00dbb09946" args="(bool inLock=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Thread::wait </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inLock</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for thread termination. </p>
<p>This method will wait for thread termination. If argument <code>inLock</code> is true (default), it will first lock the thread mutex before checking wheter or not the thread is still running. If the thread has already terminated, it will promptly return after unlocking the mutex. Otherwise, it will wait for the thread to terminate by itself.</p>
<p>If argument <code>inLock</code> is false, this method assumes that the caller has already locked the mutex (using <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Thread::lock</a>) and is responsible for unlocking it. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00250">250</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00251"></a>00251 {
<a name="l00252"></a>00252     <span class="keywordflow">if</span>(inLock) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">lock</a>();
<a name="l00253"></a>00253     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a>) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946" title="Wait for thread termination.">Condition::wait</a>();
<a name="l00254"></a>00254     <span class="keywordflow">if</span>(inLock) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00255"></a>00255 }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PACC/Threading/<a class="el" href="_thread_8hpp_source.html">Thread.hpp</a></li>
<li>PACC/Threading/<a class="el" href="_thread_8cpp_source.html">Thread.cpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jan 31 15:10:22 2010 for PACC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
