<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PACC: PACC::SVG::Canvas Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_c_c.html">PACC</a>::<a class="el" href="namespace_p_a_c_c_1_1_s_v_g.html">SVG</a>::<a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html">Canvas</a>
  </div>
</div>
<div class="contents">
<h1>PACC::SVG::Canvas Class Reference<br/>
<small>
[<a class="el" href="group___s_v_gdoc.html">Containers</a>]</small>
</h1><!-- doxytag: class="PACC::SVG::Canvas" --><!-- doxytag: inherits="PACC::SVG::Document,PACC::Socket::Cafe" -->
<p>Specialized document to display on-screen graphics.A canvas opens a TCP/IP connection with a running viewer user agent on the network. By default it connects to the localhost at port 61250.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_canvas_8hpp_source.html">Canvas.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PACC::SVG::Canvas:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_p_a_c_c_1_1_s_v_g_1_1_canvas.gif" usemap="#PACC::SVG::Canvas_map" alt=""/>
  <map id="PACC::SVG::Canvas_map" name="PACC::SVG::Canvas_map">
<area href="class_p_a_c_c_1_1_s_v_g_1_1_document.html" alt="PACC::SVG::Document" shape="rect" coords="0,280,152,304"/>
<area href="class_p_a_c_c_1_1_socket_1_1_cafe.html" alt="PACC::Socket::Cafe" shape="rect" coords="162,280,314,304"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_frame.html" alt="PACC::SVG::Frame" shape="rect" coords="0,224,152,248"/>
<area href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" alt="PACC::Socket::TCP" shape="rect" coords="162,224,314,248"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_group.html" alt="PACC::SVG::Group" shape="rect" coords="0,168,152,192"/>
<area href="class_p_a_c_c_1_1_socket_1_1_port.html" alt="PACC::Socket::Port" shape="rect" coords="162,168,314,192"/>
<area href="class_p_a_c_c_1_1_s_v_g_1_1_primitive.html" alt="PACC::SVG::Primitive" shape="rect" coords="0,112,152,136"/>
<area href="class_p_a_c_c_1_1_x_m_l_1_1_node.html" alt="PACC::XML::Node" shape="rect" coords="0,56,152,80"/>
<area href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html" alt="PACC::XML::AttributeList" shape="rect" coords="0,0,152,24"/>
</map>
 </div>
</div>

<p><a href="class_p_a_c_c_1_1_s_v_g_1_1_canvas-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a473ce9d1b5ef1bdf46305062d555bd7c"></a><!-- doxytag: member="PACC::SVG::Canvas::Canvas" ref="a473ce9d1b5ef1bdf46305062d555bd7c" args="(const string &amp;inTitle, const Size &amp;inSize, const string &amp;inHostPort=&quot;localhost:61250&quot;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html#a473ce9d1b5ef1bdf46305062d555bd7c">Canvas</a> (const string &amp;inTitle, const <a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_size.html">Size</a> &amp;inSize, const string &amp;inHostPort=&quot;localhost:61250&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pop canvas on viewer at address <code>inHostPort</code> with title <code>inTitle</code> and size <code>inSize</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a530fa1e41fd54ebe1f23a234da41f603"></a><!-- doxytag: member="PACC::SVG::Canvas::Canvas" ref="a530fa1e41fd54ebe1f23a234da41f603" args="(const string &amp;inTitle, const Size &amp;inSize, const Style &amp;inStyle, const string &amp;inHostPort=&quot;localhost:61250&quot;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html#a530fa1e41fd54ebe1f23a234da41f603">Canvas</a> (const string &amp;inTitle, const <a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_size.html">Size</a> &amp;inSize, const <a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_style.html">Style</a> &amp;inStyle, const string &amp;inHostPort=&quot;localhost:61250&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pop canvas on viewer at address <code>inAddress:inPort</code> with title <code>inTitle</code>, size <code>inSize</code>, and style <code>inStyle</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34507155eeef6d4afd3a8386f120a552"></a><!-- doxytag: member="PACC::SVG::Canvas::Canvas" ref="a34507155eeef6d4afd3a8386f120a552" args="(const Document &amp;inDocument, const string &amp;inHostPort=&quot;localhost:61250&quot;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html#a34507155eeef6d4afd3a8386f120a552">Canvas</a> (const <a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_document.html">Document</a> &amp;inDocument, const string &amp;inHostPort=&quot;localhost:61250&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pop canvas on viewer at address <code>inAddress:inPort</code> using document <code>inDocument</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4af8b82c5d22f767967de74ea778c592"></a><!-- doxytag: member="PACC::SVG::Canvas::operator=" ref="a4af8b82c5d22f767967de74ea778c592" args="(const Document &amp;inDocument)" -->
<a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html">Canvas</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html#a4af8b82c5d22f767967de74ea778c592">operator=</a> (const <a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_document.html">Document</a> &amp;inDocument)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign frame <code>inFrame</code> to this canvas. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae26de6cdeee1bc52ecdca64cc5487faa"></a><!-- doxytag: member="PACC::SVG::Canvas::operator&lt;&lt;" ref="ae26de6cdeee1bc52ecdca64cc5487faa" args="(const Primitive &amp;inGraphic)" -->
<a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html">Canvas</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html#ae26de6cdeee1bc52ecdca64cc5487faa">operator&lt;&lt;</a> (const <a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_primitive.html">Primitive</a> &amp;inGraphic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert graphic primitive <code>inGraphic</code> into this canvas. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf35b919182ed93e6fe5c038c8cf44df"></a><!-- doxytag: member="PACC::SVG::Canvas::clear" ref="abf35b919182ed93e6fe5c038c8cf44df" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html#abf35b919182ed93e6fe5c038c8cf44df">clear</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all drwing elements. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec5f17b4a6ecd145ae414077d5097b1f"></a><!-- doxytag: member="PACC::SVG::Canvas::setSize" ref="aec5f17b4a6ecd145ae414077d5097b1f" args="(const Size &amp;inSize)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html#aec5f17b4a6ecd145ae414077d5097b1f">setSize</a> (const <a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_size.html">Size</a> &amp;inSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set size of canvas to size <code>inSize</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2860dbc35290283f44d1f6093baab43e"></a><!-- doxytag: member="PACC::SVG::Canvas::setSize" ref="a2860dbc35290283f44d1f6093baab43e" args="(double inWidth, double inHeight)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html#a2860dbc35290283f44d1f6093baab43e">setSize</a> (double inWidth, double inHeight)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set frame size to width <code>inwidth</code> and height <code>inHeight</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae497061c39a60942b34894470e6798ff"></a><!-- doxytag: member="PACC::SVG::Canvas::waitForClick" ref="ae497061c39a60942b34894470e6798ff" args="(int &amp;outButtonClicked, double inMaxDelay=0)" -->
<a class="el" href="struct_p_a_c_c_1_1_s_v_g_1_1_point.html">Point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_canvas.html#ae497061c39a60942b34894470e6798ff">waitForClick</a> (int &amp;outButtonClicked, double inMaxDelay=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait up to <code>inMaxDelay</code> seconds for the user to click a mouse button. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ef863986831509272cbe20443c03093"></a><!-- doxytag: member="PACC::SVG::Canvas::setTitle" ref="a5ef863986831509272cbe20443c03093" args="(const string &amp;inTitle)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_document.html#a5ef863986831509272cbe20443c03093">setTitle</a> (const string &amp;inTitle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set title of this canvas. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add0b176d4ef171c7dc5916caf5fd98af"></a><!-- doxytag: member="PACC::SVG::Canvas::read" ref="add0b176d4ef171c7dc5916caf5fd98af" args="(const XML::ConstIterator &amp;inNode)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_document.html#add0b176d4ef171c7dc5916caf5fd98af">read</a> (const <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_const_iterator.html">XML::ConstIterator</a> &amp;inNode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read this document from parser tree node <code>inNode</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d20c34caedd1e347ef7e6dfacc22e15"></a><!-- doxytag: member="PACC::SVG::Canvas::write" ref="a4d20c34caedd1e347ef7e6dfacc22e15" args="(ostream &amp;outStream) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_document.html#a4d20c34caedd1e347ef7e6dfacc22e15">write</a> (ostream &amp;outStream) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialize this document into stream <code>outStream</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae057ca6fcd9dde802cd17b2eedf2674e"></a><!-- doxytag: member="PACC::SVG::Canvas::getOrigin" ref="ae057ca6fcd9dde802cd17b2eedf2674e" args="(void) const " -->
<a class="el" href="struct_p_a_c_c_1_1_s_v_g_1_1_point.html">Point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_frame.html#ae057ca6fcd9dde802cd17b2eedf2674e">getOrigin</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return frame origin. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e0ca9d2dd24a33b6c4d8d017a2408a3"></a><!-- doxytag: member="PACC::SVG::Canvas::getSize" ref="a8e0ca9d2dd24a33b6c4d8d017a2408a3" args="() const " -->
<a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_size.html">Size</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_frame.html#a8e0ca9d2dd24a33b6c4d8d017a2408a3">getSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return frame size. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5406af26fdcc39a0a5b4e295706342b3"></a><!-- doxytag: member="PACC::SVG::Canvas::setOrigin" ref="a5406af26fdcc39a0a5b4e295706342b3" args="(double inX, double inY)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_frame.html#a5406af26fdcc39a0a5b4e295706342b3">setOrigin</a> (double inX, double inY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set frame origin to coordinates <code>inX</code> and <code>inY</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b256143dd8dc3a909e61ad65ea5f506"></a><!-- doxytag: member="PACC::SVG::Canvas::setViewBox" ref="a9b256143dd8dc3a909e61ad65ea5f506" args="(const Point &amp;inOrigin, const Size &amp;inSize, bool inPreserveAspect=false)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_frame.html#a9b256143dd8dc3a909e61ad65ea5f506">setViewBox</a> (const <a class="el" href="struct_p_a_c_c_1_1_s_v_g_1_1_point.html">Point</a> &amp;inOrigin, const <a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_size.html">Size</a> &amp;inSize, bool inPreserveAspect=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set viewbox of this frame to origin <code>inOrigin</code> and size <code>inSize</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6351cc4fe9275d0729cc7e72e0710f70"></a><!-- doxytag: member="PACC::SVG::Canvas::count" ref="a6351cc4fe9275d0729cc7e72e0710f70" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_group.html#a6351cc4fe9275d0729cc7e72e0710f70">count</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of primitives in this group. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_primitive.html#a3fc3ac301189075d239a5c87f24b13a7">addStyle</a> (const <a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_style.html">Style</a> &amp;inStyle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add style attributes to element.  <a href="#a3fc3ac301189075d239a5c87f24b13a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_primitive.html#a89c3460c2013d6b1fce550a378963693">setID</a> (const string &amp;inID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set id of primitive.  <a href="#a89c3460c2013d6b1fce550a378963693"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa47492f75a11e700e53b4e7dcd01a0b0"></a><!-- doxytag: member="PACC::SVG::Canvas::getFirstChild" ref="aa47492f75a11e700e53b4e7dcd01a0b0" args="(void)" -->
Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aa47492f75a11e700e53b4e7dcd01a0b0">getFirstChild</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the first child of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95dd93d3a06147a92f77c5a5f56f8a22"></a><!-- doxytag: member="PACC::SVG::Canvas::getFirstChild" ref="a95dd93d3a06147a92f77c5a5f56f8a22" args="(void) const " -->
const Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a95dd93d3a06147a92f77c5a5f56f8a22">getFirstChild</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the first child of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5bf8372c00924e02c3de589711df78"></a><!-- doxytag: member="PACC::SVG::Canvas::getLastChild" ref="aef5bf8372c00924e02c3de589711df78" args="(void)" -->
Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aef5bf8372c00924e02c3de589711df78">getLastChild</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the last child of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7d01c290df74876c6bcbea886f52272"></a><!-- doxytag: member="PACC::SVG::Canvas::getLastChild" ref="ae7d01c290df74876c6bcbea886f52272" args="(void) const " -->
const Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ae7d01c290df74876c6bcbea886f52272">getLastChild</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the last child of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c22b8f346fc140f6cf1e34fa1cde00f"></a><!-- doxytag: member="PACC::SVG::Canvas::getNextSibling" ref="a2c22b8f346fc140f6cf1e34fa1cde00f" args="(void)" -->
Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a2c22b8f346fc140f6cf1e34fa1cde00f">getNextSibling</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the next sibling of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92daaae951611025c2e3d64ecf410fee"></a><!-- doxytag: member="PACC::SVG::Canvas::getNextSibling" ref="a92daaae951611025c2e3d64ecf410fee" args="(void) const " -->
const Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a92daaae951611025c2e3d64ecf410fee">getNextSibling</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the next sibling of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a858451add5961eb7decaf2681d15b005"></a><!-- doxytag: member="PACC::SVG::Canvas::getPreviousSibling" ref="a858451add5961eb7decaf2681d15b005" args="(void)" -->
Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a858451add5961eb7decaf2681d15b005">getPreviousSibling</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the previous sibling of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25992d54090220bfec5885b910b667fd"></a><!-- doxytag: member="PACC::SVG::Canvas::getPreviousSibling" ref="a25992d54090220bfec5885b910b667fd" args="(void) const " -->
const Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a25992d54090220bfec5885b910b667fd">getPreviousSibling</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the previous sibling of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30412f746bfa2eb75a6954f28c3dc6f3"></a><!-- doxytag: member="PACC::SVG::Canvas::getParent" ref="a30412f746bfa2eb75a6954f28c3dc6f3" args="(void)" -->
Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a30412f746bfa2eb75a6954f28c3dc6f3">getParent</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the parent of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c64699c563d9099e9a27a27d7bba12f"></a><!-- doxytag: member="PACC::SVG::Canvas::getParent" ref="a5c64699c563d9099e9a27a27d7bba12f" args="(void) const " -->
const Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5c64699c563d9099e9a27a27d7bba12f">getParent</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the parent of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0134728a999645cc6cf4d3351c5c96ac"></a><!-- doxytag: member="PACC::SVG::Canvas::getType" ref="a0134728a999645cc6cf4d3351c5c96ac" args="(void) const " -->
const NodeType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a0134728a999645cc6cf4d3351c5c96ac">getType</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the node type (see enum <a class="el" href="group___x_m_l.html#gaee55fe15d14e7ff7da9b834404055814" title="Types of parse tree node.">XML::NodeType</a>). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acff683537a292b3f8292f0299de53fb5"></a><!-- doxytag: member="PACC::SVG::Canvas::getValue" ref="acff683537a292b3f8292f0299de53fb5" args="(void) const " -->
const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5">getValue</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the node value (tag name for NodeType::eData). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81c5eb0107f27467416ac62c6f91cc41"></a><!-- doxytag: member="PACC::SVG::Canvas::setType" ref="a81c5eb0107f27467416ac62c6f91cc41" args="(NodeType inType)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81c5eb0107f27467416ac62c6f91cc41">setType</a> (NodeType inType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the node type (see enum <a class="el" href="group___x_m_l.html#gaee55fe15d14e7ff7da9b834404055814" title="Types of parse tree node.">XML::NodeType</a>). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2153fdc8f84e00523857170075b31e6"></a><!-- doxytag: member="PACC::SVG::Canvas::setValue" ref="ab2153fdc8f84e00523857170075b31e6" args="(const string &amp;inValue)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ab2153fdc8f84e00523857170075b31e6">setValue</a> (const string &amp;inValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set node value (tag name for nodes of type NodeType::eTag). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ac9c8db449859f59d210f8e84754b29e9">detachFromSiblingsAndParent</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach this node from its siblings and parent.  <a href="#ac9c8db449859f59d210f8e84754b29e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a180240fc70b60e6bd2762a70f274cb17"></a><!-- doxytag: member="PACC::SVG::Canvas::eraseChildren" ref="a180240fc70b60e6bd2762a70f274cb17" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a180240fc70b60e6bd2762a70f274cb17">eraseChildren</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete all children. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aef491e4fa0310ca0a8ca435127a9a309">getChildCount</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of child nodes.  <a href="#aef491e4fa0310ca0a8ca435127a9a309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a0e68df0b3d1d51a01e6875d539616b68">insertAsLastChild</a> (Node *inChild)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node <code>inChild</code> after the last child of this node.  <a href="#a0e68df0b3d1d51a01e6875d539616b68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a3d4d55e56ae811162e70ba2c7d6c84c2">insertAsPreviousSibling</a> (Node *inSibling)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node <code>inSibling</code> as the sibling that preceeds this node.  <a href="#a3d4d55e56ae811162e70ba2c7d6c84c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ad4435832826f4874ee8b59be84267c75">serialize</a> (Streamer &amp;outStream, bool inIndent=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialize this node into XML streamer <code>outStream</code>.  <a href="#ad4435832826f4874ee8b59be84267c75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ae3112e9f79d990cb581e97179496003d">parseAttributeList</a> (<a class="el" href="class_p_a_c_c_1_1_tokenizer.html">Tokenizer</a> &amp;inTokenizer, string &amp;outToken)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the attribute list using stream tokenizer <code>inTokenizer</code>.  <a href="#ae3112e9f79d990cb581e97179496003d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5610f5b7d3efb7d5f8914ca37e1ae241">parseStartTag</a> (<a class="el" href="class_p_a_c_c_1_1_tokenizer.html">Tokenizer</a> &amp;inTokenizer, string &amp;outToken)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse in stream tokenizer <code>inTokenizer</code> the start tag of this node.  <a href="#a5610f5b7d3efb7d5f8914ca37e1ae241"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff2e32b9e2cf9f330246f931762b6648"></a><!-- doxytag: member="PACC::SVG::Canvas::readContentAsString" ref="aff2e32b9e2cf9f330246f931762b6648" args="(Tokenizer &amp;inTokenizer)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aff2e32b9e2cf9f330246f931762b6648">readContentAsString</a> (<a class="el" href="class_p_a_c_c_1_1_tokenizer.html">Tokenizer</a> &amp;inTokenizer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read in stream tokenizer <code>inTokenizer</code> the content of this node (current tag) as a single string (do not parse content). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97a9b5684ee34f60996ddb5686f40e86"></a><!-- doxytag: member="PACC::SVG::Canvas::throwError" ref="a97a9b5684ee34f60996ddb5686f40e86" args="(Tokenizer &amp;inTokenizer, const string &amp;inMessage) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86">throwError</a> (<a class="el" href="class_p_a_c_c_1_1_tokenizer.html">Tokenizer</a> &amp;inTokenizer, const string &amp;inMessage) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throw runtime error with message <code>inMessage</code> using tokenizer <code>inTokenizer</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94899740910da5eab24ff834c6088fd9"></a><!-- doxytag: member="PACC::SVG::Canvas::operator+" ref="a94899740910da5eab24ff834c6088fd9" args="(const AttributeList &amp;inAttrList) const " -->
AttributeList&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a94899740910da5eab24ff834c6088fd9">operator+</a> (const AttributeList &amp;inAttrList) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return concatenation of attribute list <code>inAttrList</code> with this list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a34d6a8adb75592e29528ba6a78e08c"></a><!-- doxytag: member="PACC::SVG::Canvas::operator+=" ref="a2a34d6a8adb75592e29528ba6a78e08c" args="(const AttributeList &amp;inAttrList)" -->
AttributeList &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a2a34d6a8adb75592e29528ba6a78e08c">operator+=</a> (const AttributeList &amp;inAttrList)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append attribute list <code>inAttrList</code> to this list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa329c59996a8338d1097e2d51d598c13"></a><!-- doxytag: member="PACC::SVG::Canvas::getAttribute" ref="aa329c59996a8338d1097e2d51d598c13" args="(const string &amp;inName) const " -->
const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa329c59996a8338d1097e2d51d598c13">getAttribute</a> (const string &amp;inName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value of attribute <code>inName</code>, or empty string if it doesn't exist. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa71362e83a9722288a8e4474aa2b7643"></a><!-- doxytag: member="PACC::SVG::Canvas::isDefined" ref="aa71362e83a9722288a8e4474aa2b7643" args="(const std::string &amp;inName) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa71362e83a9722288a8e4474aa2b7643">isDefined</a> (const std::string &amp;inName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test wheter attribute name <code>inName</code> exists in this list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73fccd9ef0123d725ae77baaccb82d02"></a><!-- doxytag: member="PACC::SVG::Canvas::removeAttribute" ref="a73fccd9ef0123d725ae77baaccb82d02" args="(const string &amp;inName)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a73fccd9ef0123d725ae77baaccb82d02">removeAttribute</a> (const string &amp;inName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove attribute name <code>inName</code> from this attribute list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70b83d7d50f2b40eb6656891cf7d8557"></a><!-- doxytag: member="PACC::SVG::Canvas::setAttribute" ref="a70b83d7d50f2b40eb6656891cf7d8557" args="(const string &amp;inName, const string &amp;inValue)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a70b83d7d50f2b40eb6656891cf7d8557">setAttribute</a> (const string &amp;inName, const string &amp;inValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set attribute <code>inName</code> to value <code>inValue</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67cf0e34061ed93030d8d31d5cc18dc8"></a><!-- doxytag: member="PACC::SVG::Canvas::setAttribute" ref="a67cf0e34061ed93030d8d31d5cc18dc8" args="(const string &amp;inName, double inValue)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a67cf0e34061ed93030d8d31d5cc18dc8">setAttribute</a> (const string &amp;inName, double inValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set attribute <code>inName</code> to value <code>inValue</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a05f1172f301e049288c059e1b7353544">receiveMessage</a> (string &amp;outMessage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive string message from connected server using the 0cafe protocol.  <a href="#a05f1172f301e049288c059e1b7353544"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a6211c7829f7a55ce68fcaffdaed7a513">sendMessage</a> (const string &amp;inMessage, unsigned int inCompressionLevel=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send string message <code>inMessage</code> to connected server using the cafe protocol.  <a href="#a6211c7829f7a55ce68fcaffdaed7a513"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#adc5fb826b4851b5314c9248ed94620e9">sendMessage</a> (const string &amp;inMessage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send string message to connected (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a>) server.  <a href="#adc5fb826b4851b5314c9248ed94620e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ef4276b27831a7de99867dfbbe1710f"></a><!-- doxytag: member="PACC::SVG::Canvas::compress" ref="a8ef4276b27831a7de99867dfbbe1710f" args="(const string &amp;inMessage, string &amp;outMessage, unsigned int inCompressionLevel)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a8ef4276b27831a7de99867dfbbe1710f">compress</a> (const string &amp;inMessage, string &amp;outMessage, unsigned int inCompressionLevel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compress string <code>inMessage</code> using compression level <code>inCompressionLevel</code>, and return result through string <code>outMessage</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe889cfda9bf200f415161f4bba3e754"></a><!-- doxytag: member="PACC::SVG::Canvas::uncompress" ref="abe889cfda9bf200f415161f4bba3e754" args="(string &amp;ioMessage, unsigned long inSize)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#abe889cfda9bf200f415161f4bba3e754">uncompress</a> (string &amp;ioMessage, unsigned long inSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uncompress string <code>ioMessage</code> knowing that the uncompressed message length is <code>inUncompressedSize</code>, and return result through string <code>ioMessage</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a51c6ac893e8b8d3ebeb6578de0243fad">receive</a> (char *inBuffer, unsigned int inCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive <code>inCount</code> bytes from socket.  <a href="#a51c6ac893e8b8d3ebeb6578de0243fad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#aa2bfb38c81fc0695d99f51cc8e7291c6">receive</a> (char *outBuffer, unsigned inMaxCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive data from connected socket.  <a href="#aa2bfb38c81fc0695d99f51cc8e7291c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2848b4ba6d7b4b2e55af1675727c80d"></a><!-- doxytag: member="PACC::SVG::Canvas::close" ref="af2848b4ba6d7b4b2e55af1675727c80d" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#af2848b4ba6d7b4b2e55af1675727c80d">close</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close connection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24eb29f54290765a83e3e8b0469c78c2"></a><!-- doxytag: member="PACC::SVG::Canvas::connect" ref="a24eb29f54290765a83e3e8b0469c78c2" args="(const Address &amp;inPeer)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#a24eb29f54290765a83e3e8b0469c78c2">connect</a> (const Address &amp;inPeer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to server <code>inPeer</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a002078da6139f20def2af30c22984fcf"></a><!-- doxytag: member="PACC::SVG::Canvas::getDescriptor" ref="a002078da6139f20def2af30c22984fcf" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a002078da6139f20def2af30c22984fcf">getDescriptor</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return socket descriptor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Address&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a41ecb8dddf4441185f0b893d9dce5514">getPeerAddress</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return address of peer socket host.  <a href="#a41ecb8dddf4441185f0b893d9dce5514"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Protocol&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#aaa2f2ae4b67d2dd00a0933f60c784e54">getProtocol</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return protocol of socket.  <a href="#aaa2f2ae4b67d2dd00a0933f60c784e54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Address&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a4abe927d07cf69d1048992c6c9ce8452">getSockAddress</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return address of socket host.  <a href="#a4abe927d07cf69d1048992c6c9ce8452"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a758a6afe098539a362de79a86b5f1f1d">getSockOpt</a> (Option inName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value of socket option <code>inName</code>.  <a href="#a758a6afe098539a362de79a86b5f1f1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367">setSockOpt</a> (Option inName, double inValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set socket option <code>inName</code> to value <code>inValue</code>.  <a href="#a0f8abcce1ad096ea617c88b4d366e367"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#ae7bac9446a6f94245a4d9f15a23d3847">accept</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept connection on bound port.  <a href="#ae7bac9446a6f94245a4d9f15a23d3847"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#aaceed74c3414e4a4acccd297aff1084b">bind</a> (unsigned int inPortNumber)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind socket to port number <code>inPortNumber</code>.  <a href="#aaceed74c3414e4a4acccd297aff1084b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a3d153806aea01830530f4ea04c0f338b">convertToNativeOption</a> (Option inName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert socket option <code>inName</code> to native socket option code.  <a href="#a3d153806aea01830530f4ea04c0f338b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5147580c20eb309df5a0fa7cb65e8ef3"></a><!-- doxytag: member="PACC::SVG::Canvas::listen" ref="a5147580c20eb309df5a0fa7cb65e8ef3" args="(unsigned int inMaxConnections)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a5147580c20eb309df5a0fa7cb65e8ef3">listen</a> (unsigned int inMaxConnections)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Listen to socket using a queue of at least <code>inMinPending</code> pending connections. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0180add2f0a595baeae502607a74ea64">open</a> (Protocol=eTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open new socket descriptor.  <a href="#a0180add2f0a595baeae502607a74ea64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#abc30f2043f597dc71e7113528824b42b">receiveFrom</a> (char *outBuffer, unsigned inMaxCount, Address &amp;outPeer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive data from unconnected socket.  <a href="#abc30f2043f597dc71e7113528824b42b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740">send</a> (const char *inBuffer, unsigned int inCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send data to connected socket.  <a href="#a7e0f88dff3eacee95675eb0fcc9cc740"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#ac9c7959ca0afef4d5fa57a28fba3b4d8">sendTo</a> (const char *inBuffer, unsigned int inCount, const Address &amp;inPeer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send data to unconnected socket.  <a href="#ac9c7959ca0afef4d5fa57a28fba3b4d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a27ed19ee09dc2503886c071edc813cc8">waitForActivity</a> (double inSeconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for activity.  <a href="#a27ed19ee09dc2503886c071edc813cc8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a48493203d020c08ebbd44bd98f09d43c">parse</a> (<a class="el" href="class_p_a_c_c_1_1_tokenizer.html">Tokenizer</a> &amp;inTokenizer, const set&lt; string &gt; &amp;inNoParseTags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse next tag using stream tokenizer <code>inTokenizer</code>.  <a href="#a48493203d020c08ebbd44bd98f09d43c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5227d2bef95e7dda97f2b63d617a3724">convertFromQuotes</a> (string &amp;ioString, map&lt; string, char &gt; &amp;ioMap=<a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ab29975ad2c53c213a03768b222c74669">smMap</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert basic xml quotes into ascii characters.  <a href="#a5227d2bef95e7dda97f2b63d617a3724"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb7445cdb7523a95a35ec8adc38bfed0"></a><!-- doxytag: member="PACC::SVG::Canvas::mType" ref="abb7445cdb7523a95a35ec8adc38bfed0" args="" -->
NodeType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0">mType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a216f93b39a91daca6aad1608195c477f"></a><!-- doxytag: member="PACC::SVG::Canvas::mParent" ref="a216f93b39a91daca6aad1608195c477f" args="" -->
Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f">mParent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to parent node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5de69ebc4618625e8be3b626f0015d8e"></a><!-- doxytag: member="PACC::SVG::Canvas::mFirstChild" ref="a5de69ebc4618625e8be3b626f0015d8e" args="" -->
Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5de69ebc4618625e8be3b626f0015d8e">mFirstChild</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to first child node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a877bbbcdb99e8d86fadf2f407827bc7e"></a><!-- doxytag: member="PACC::SVG::Canvas::mLastChild" ref="a877bbbcdb99e8d86fadf2f407827bc7e" args="" -->
Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e">mLastChild</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to last child node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24b310a643deaa72ca39cf9b5c57f056"></a><!-- doxytag: member="PACC::SVG::Canvas::mPrevSibling" ref="a24b310a643deaa72ca39cf9b5c57f056" args="" -->
Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056">mPrevSibling</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to previous sibling node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f583ab7607580c61ce035f28239004"></a><!-- doxytag: member="PACC::SVG::Canvas::mNextSibling" ref="a04f583ab7607580c61ce035f28239004" args="" -->
Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004">mNextSibling</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to next sibling node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11b5de113c588e85c076ea8f7a42600c"></a><!-- doxytag: member="PACC::SVG::Canvas::mDescriptor" ref="a11b5de113c588e85c076ea8f7a42600c" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c">mDescriptor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">socket descriptor <br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab29975ad2c53c213a03768b222c74669"></a><!-- doxytag: member="PACC::SVG::Canvas::smMap" ref="ab29975ad2c53c213a03768b222c74669" args="" -->
static <a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node_1_1_default_quotes.html">DefaultQuotes</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ab29975ad2c53c213a03768b222c74669">smMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion map for translating quotes. <br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a883538034e58fc5c0de7d4e4cab3cef7"></a><!-- doxytag: member="PACC::SVG::Canvas::Document" ref="a883538034e58fc5c0de7d4e4cab3cef7" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_primitive.html#a883538034e58fc5c0de7d4e4cab3cef7">Document</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allowing access to method Node::serialize. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2697825715974a353728f0d4d5658112"></a><!-- doxytag: member="PACC::SVG::Canvas::Group" ref="a2697825715974a353728f0d4d5658112" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_primitive.html#a2697825715974a353728f0d4d5658112">Group</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allowing the use of Element's &lt;&lt; operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9830fc407400559db7e7783cc10a9394"></a><!-- doxytag: member="PACC::SVG::Canvas::Iterator" ref="a9830fc407400559db7e7783cc10a9394" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5485970bb9da6b5d782fa28638b5658f"></a><!-- doxytag: member="PACC::SVG::Canvas::ConstIterator" ref="a5485970bb9da6b5d782fa28638b5658f" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>ConstIterator</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Specialized document to display on-screen graphics.</p>
<p>A canvas opens a TCP/IP connection with a running viewer user agent on the network. By default it connects to the localhost at port 61250. </p>
<p>The viewer opens a window showing the canvas. Changes made to the canvas are updated in real-time on the viewer side. </p>

<p>Definition at line <a class="el" href="_canvas_8hpp_source.html#l00056">56</a> of file <a class="el" href="_canvas_8hpp_source.html">Canvas.hpp</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae7bac9446a6f94245a4d9f15a23d3847"></a><!-- doxytag: member="PACC::SVG::Canvas::accept" ref="ae7bac9446a6f94245a4d9f15a23d3847" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Socket::Port::accept </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept connection on bound port. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00089">89</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00090"></a>00090 {
<a name="l00091"></a>00091     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::accept() invalid socket&quot;</span>);
<a name="l00092"></a>00092     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00093"></a>00093     socklen_t lSize = <span class="keyword">sizeof</span>(lSock);
<a name="l00094"></a>00094     <span class="keywordtype">int</span> lDescriptor =<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#ae7bac9446a6f94245a4d9f15a23d3847" title="Accept connection on bound port."> ::accept</a>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (<span class="keyword">struct </span>sockaddr*) &amp;lSock, &amp;lSize);
<a name="l00095"></a>00095     <span class="keywordflow">if</span>(lDescriptor &lt; 0) {
<a name="l00096"></a>00096         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::acept() unable to accept connection&quot;</span>);
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098     <span class="keywordflow">return</span> lDescriptor;
<a name="l00099"></a>00099 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3fc3ac301189075d239a5c87f24b13a7"></a><!-- doxytag: member="PACC::SVG::Canvas::addStyle" ref="a3fc3ac301189075d239a5c87f24b13a7" args="(const Style &amp;inStyle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVG::Primitive::addStyle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_c_c_1_1_s_v_g_1_1_style.html">Style</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inStyle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add style attributes to element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inStyle</em>&nbsp;</td><td>A style attribute list to add to this element.</td></tr>
  </table>
  </dd>
</dl>
<p>If the same style attribute with the same name is already present, it will be replaced by the new value. </p>

<p>Definition at line <a class="el" href="_primitives_8cpp_source.html#l00060">60</a> of file <a class="el" href="_primitives_8cpp_source.html">Primitives.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00061"></a>00061 {
<a name="l00062"></a>00062     *<span class="keyword">this</span> += inStyle;
<a name="l00063"></a>00063 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaceed74c3414e4a4acccd297aff1084b"></a><!-- doxytag: member="PACC::SVG::Canvas::bind" ref="aaceed74c3414e4a4acccd297aff1084b" args="(unsigned int inPortNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::bind </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inPortNumber</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind socket to port number <code>inPortNumber</code>. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. In particular, this method may fail if the port is already binded by another process or thread. It may even fail for a few seconds after the connection is released by another process or thread (see Option::eReuseAddress). </p>

<p>Reimplemented in <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#afa9967ccc64a9b3bbb4f2184d1fb1ff6">PACC::Socket::TCPServer</a>.</p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00107">107</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00108"></a>00108 {
<a name="l00109"></a>00109     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::bind() invalid socket&quot;</span>);
<a name="l00110"></a>00110     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00111"></a>00111     lSock.sin_family = AF_INET;
<a name="l00112"></a>00112     lSock.sin_port = htons(inPortNumber);
<a name="l00113"></a>00113     lSock.sin_addr.s_addr = htonl(INADDR_ANY);
<a name="l00114"></a>00114     memset(&amp;lSock.sin_zero, 0, 8);
<a name="l00115"></a>00115     <span class="keywordflow">if</span>(::<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#aaceed74c3414e4a4acccd297aff1084b" title="Bind socket to port number inPortNumber.">bind</a>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (<span class="keyword">struct</span> sockaddr*) &amp;lSock, <span class="keyword">sizeof</span>(lSock)) != 0) {
<a name="l00116"></a>00116         <span class="keywordtype">int</span> lCode = ErrNo;
<a name="l00117"></a>00117         ostringstream lMessage;
<a name="l00118"></a>00118         lMessage &lt;&lt; <span class="stringliteral">&quot;Port::bind() unable to bind port: &quot;</span> &lt;&lt; inPortNumber;
<a name="l00119"></a>00119         <span class="keywordflow">throw</span> Exception(lCode, lMessage.str());
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5227d2bef95e7dda97f2b63d617a3724"></a><!-- doxytag: member="PACC::SVG::Canvas::convertFromQuotes" ref="a5227d2bef95e7dda97f2b63d617a3724" args="(string &amp;ioString, map&lt; string, char &gt; &amp;ioMap=smMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string &amp; XML::Node::convertFromQuotes </td>
          <td>(</td>
          <td class="paramtype">string &amp;&nbsp;</td>
          <td class="paramname"> <em>ioString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ioMap</em> = <code><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ab29975ad2c53c213a03768b222c74669">smMap</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert basic xml quotes into ascii characters. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the converted string. The default quotes are "&amp;amp;", "&amp;lt;", "&amp;gt;", "&amp;apos;", and "&amp;quot;". Argument <code>ioMap</code> can be used to specify any conversion table. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00137">137</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00138"></a>00138 {
<a name="l00139"></a>00139     string::size_type lStart, lEnd = 0;
<a name="l00140"></a>00140     <span class="keywordflow">while</span>((lStart = ioString.find(<span class="charliteral">&apos;&amp;&apos;</span>, lEnd)) &lt; ioString.size() &amp;&amp; 
<a name="l00141"></a>00141                 (lEnd = ioString.find(<span class="charliteral">&apos;;&apos;</span>, lStart)) &lt; ioString.size())
<a name="l00142"></a>00142     {
<a name="l00143"></a>00143         <span class="keywordtype">string</span> lToken = ioString.substr(lStart+1, lEnd-lStart-1);
<a name="l00144"></a>00144         <span class="keywordflow">if</span>(ioMap.find(lToken) != ioMap.end()) {
<a name="l00145"></a>00145             ioString[lStart] = ioMap[lToken];
<a name="l00146"></a>00146             ioString.erase(lStart+1, lEnd-lStart);
<a name="l00147"></a>00147             lEnd = lStart+1;
<a name="l00148"></a>00148         }
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150     <span class="keywordflow">return</span> ioString;
<a name="l00151"></a>00151 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3d153806aea01830530f4ea04c0f338b"></a><!-- doxytag: member="PACC::SVG::Canvas::convertToNativeOption" ref="a3d153806aea01830530f4ea04c0f338b" args="(Option inName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Socket::Port::convertToNativeOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Socket::Option</a>&nbsp;</td>
          <td class="paramname"> <em>inName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert socket option <code>inName</code> to native socket option code. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00166">166</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00167"></a>00167 {
<a name="l00168"></a>00168     <span class="keywordtype">int</span> lNativeOpt;
<a name="l00169"></a>00169     <span class="keywordflow">switch</span>(inName) {
<a name="l00170"></a>00170         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fad094f0c703765e462059f4c8a92b7292" title="Keep connection alive.">eKeepAlive</a>: lNativeOpt = SO_KEEPALIVE; <span class="keywordflow">break</span>;
<a name="l00171"></a>00171         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fae0dcf7836a0dbfe6de1d8de7f5c1aa47" title="Time to linger on close (in seconds).">eLinger</a>: lNativeOpt = SO_LINGER; <span class="keywordflow">break</span>;
<a name="l00172"></a>00172         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>: lNativeOpt = TCP_NODELAY; <span class="keywordflow">break</span>;
<a name="l00173"></a>00173         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faef38bf8dd0269ab968548ce17aeba64a" title="Socket protocol type">eProtocolType</a>: lNativeOpt = SO_TYPE; <span class="keywordflow">break</span>;
<a name="l00174"></a>00174         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa1839a506c945f06a24ded765b5ece67a" title="Allow reuse of a TCP address without delay.">eReuseAddress</a>: lNativeOpt = SO_REUSEADDR; <span class="keywordflow">break</span>;
<a name="l00175"></a>00175         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>: lNativeOpt = SO_RCVBUF; <span class="keywordflow">break</span>;
<a name="l00176"></a>00176         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faf5ee4bfe5d2341a7875edb7ff10ff1c2" title="Size of send buffer (in number of chars).">eSendBufSize</a>: lNativeOpt = SO_SNDBUF; <span class="keywordflow">break</span>;
<a name="l00177"></a>00177         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">eRecvTimeOut</a>: lNativeOpt = SO_RCVTIMEO; <span class="keywordflow">break</span>;
<a name="l00178"></a>00178         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">eSendTimeOut</a>: lNativeOpt = SO_SNDTIMEO; <span class="keywordflow">break</span>;
<a name="l00179"></a>00179         <span class="keywordflow">default</span>: <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::convertToNativeOption() unknown socket option&quot;</span>);
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181     <span class="keywordflow">return</span> lNativeOpt;
<a name="l00182"></a>00182 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac9c8db449859f59d210f8e84754b29e9"></a><!-- doxytag: member="PACC::SVG::Canvas::detachFromSiblingsAndParent" ref="ac9c8db449859f59d210f8e84754b29e9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> * XML::Node::detachFromSiblingsAndParent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detach this node from its siblings and parent. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to this node. This method removes this node from its parent tree. The list of sibling nodes is repaired accordingly. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00156">156</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00156"></a>00156                                                   {
<a name="l00157"></a>00157     <span class="comment">// adjust sibling list</span>
<a name="l00158"></a>00158     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>-&gt;mNextSibling = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>;
<a name="l00159"></a>00159     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>-&gt;mPrevSibling = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>;
<a name="l00160"></a>00160     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>) {
<a name="l00161"></a>00161         <span class="comment">// adjust parent first and last child pointers</span>
<a name="l00162"></a>00162         <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>-&gt;mFirstChild == <span class="keyword">this</span>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>-&gt;mFirstChild = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>;
<a name="l00163"></a>00163         <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>-&gt;mLastChild == <span class="keyword">this</span>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>-&gt;mLastChild = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>;
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> = NULL;
<a name="l00166"></a>00166     <span class="keywordflow">return</span> <span class="keyword">this</span>;
<a name="l00167"></a>00167 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aef491e4fa0310ca0a8ca435127a9a309"></a><!-- doxytag: member="PACC::SVG::Canvas::getChildCount" ref="aef491e4fa0310ca0a8ca435127a9a309" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XML::Node::getChildCount </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of child nodes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of child nodes. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00180">180</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00180"></a>00180                                               {
<a name="l00181"></a>00181     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lCount = 0;
<a name="l00182"></a>00182     <span class="keywordflow">for</span>(ConstIterator lChild = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aa47492f75a11e700e53b4e7dcd01a0b0" title="Return an iterator pointing to the first child of this node.">getFirstChild</a>(); lChild; ++lChild) ++lCount;
<a name="l00183"></a>00183     <span class="keywordflow">return</span> lCount;
<a name="l00184"></a>00184 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a41ecb8dddf4441185f0b893d9dce5514"></a><!-- doxytag: member="PACC::SVG::Canvas::getPeerAddress" ref="a41ecb8dddf4441185f0b893d9dce5514" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Socket::Address</a> Socket::Port::getPeerAddress </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return address of peer socket host. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00187">187</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00188"></a>00188 {
<a name="l00189"></a>00189     <span class="keyword">struct </span>sockaddr lSock;
<a name="l00190"></a>00190     socklen_t lLength = <span class="keyword">sizeof</span>(lSock);
<a name="l00191"></a>00191     <span class="keywordflow">if</span>(::getpeername(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lSock, &amp;lLength) != 0) {
<a name="l00192"></a>00192         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2af3e825a5abff84418308ed3ed6dd0c55" title="Socket is not connected.">eNotConnected</a>, <span class="stringliteral">&quot;Port::getPeerAddress() unable to retrieve peer address&quot;</span>);
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194     <span class="keywordflow">return</span> Address(ntohs(((sockaddr_in*)&amp;lSock)-&gt;sin_port), inet_ntoa(((sockaddr_in*)&amp;lSock)-&gt;sin_addr));
<a name="l00195"></a>00195 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaa2f2ae4b67d2dd00a0933f60c784e54"></a><!-- doxytag: member="PACC::SVG::Canvas::getProtocol" ref="aaa2f2ae4b67d2dd00a0933f60c784e54" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___socket.html#ga3109f582afef6bc8e60e4bbf26fc0ac6">Socket::Protocol</a> Socket::Port::getProtocol </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return protocol of socket. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00200">200</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00201"></a>00201 {
<a name="l00202"></a>00202     
<a name="l00203"></a>00203     <span class="keywordtype">int</span> lProtocol = (int) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a758a6afe098539a362de79a86b5f1f1d" title="Return value of socket option inName.">getSockOpt</a>(<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faef38bf8dd0269ab968548ce17aeba64a" title="Socket protocol type">eProtocolType</a>);
<a name="l00204"></a>00204     <span class="keywordflow">if</span>(lProtocol == SOCK_STREAM) <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a058e23bb541cf7bdc7f6975d987c477d" title="Transfer Control Protocol.">eTCP</a>;
<a name="l00205"></a>00205     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lProtocol == SOCK_DGRAM) <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a9caf36aa3cd32acd779c55f0f8e1ff54" title="User Datagram Protocol.">eUDP</a>;
<a name="l00206"></a>00206     <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6aa028e8075f4cfd5365f252d682f1f7ab" title="Other protocol.">eOther</a>;
<a name="l00207"></a>00207 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4abe927d07cf69d1048992c6c9ce8452"></a><!-- doxytag: member="PACC::SVG::Canvas::getSockAddress" ref="a4abe927d07cf69d1048992c6c9ce8452" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Socket::Address</a> Socket::Port::getSockAddress </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return address of socket host. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00212">212</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00213"></a>00213 {
<a name="l00214"></a>00214     <span class="keyword">struct </span>sockaddr lSock;
<a name="l00215"></a>00215     socklen_t lLength = <span class="keyword">sizeof</span>(lSock);
<a name="l00216"></a>00216     <span class="keywordflow">if</span>(::getsockname(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lSock, &amp;lLength) != 0) {
<a name="l00217"></a>00217         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::getSockAddress() unable to retrieve socket address&quot;</span>);
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219     <span class="keywordflow">return</span> Address(ntohs(((sockaddr_in*)&amp;lSock)-&gt;sin_port), inet_ntoa(((sockaddr_in*)&amp;lSock)-&gt;sin_addr));
<a name="l00220"></a>00220 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a758a6afe098539a362de79a86b5f1f1d"></a><!-- doxytag: member="PACC::SVG::Canvas::getSockOpt" ref="a758a6afe098539a362de79a86b5f1f1d" args="(Option inName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Socket::Port::getSockOpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Socket::Option</a>&nbsp;</td>
          <td class="paramname"> <em>inName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return value of socket option <code>inName</code>. </p>
<p>Valid options are: </p>
<ul>
<li>
eKeepAlive: keep connection alive (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eLinger: time to linger on close (in seconds, <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eNoDelay: disable the Nagle algorithm for packet coalescing (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eProtocolType: socket protocol type </li>
<li>
eReuseAddress: allow reuse of address </li>
<li>
eRecvBufSize: size of receive buffer (in bytes) </li>
<li>
eSendBufSize: size of send buffer (in bytes) </li>
<li>
eRecvTimeOut: time out period for receive operations (in seconds) </li>
<li>
eSendTimeOut: time out period for send operations (in seconds) </li>
</ul>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00237">237</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00238"></a>00238 {
<a name="l00239"></a>00239     <span class="keywordtype">double</span> lValue;
<a name="l00240"></a>00240     <span class="keywordtype">int</span> lBuffer[2] = {0, 0};
<a name="l00241"></a>00241     socklen_t lSize = <span class="keyword">sizeof</span>(lBuffer);
<a name="l00242"></a>00242     <span class="keywordflow">if</span>(::getsockopt(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (inName==<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>?IPPROTO_TCP:SOL_SOCKET), <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a3d153806aea01830530f4ea04c0f338b" title="Convert socket option inName to native socket option code.">convertToNativeOption</a>(inName), (<span class="keywordtype">char</span>*)lBuffer, &amp;lSize) != 0)
<a name="l00243"></a>00243     {
<a name="l00244"></a>00244         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::getSockOpt() unable to retrieve socket option&quot;</span>);
<a name="l00245"></a>00245     }
<a name="l00246"></a>00246     <span class="keywordflow">switch</span>(inName) {
<a name="l00247"></a>00247         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fad094f0c703765e462059f4c8a92b7292" title="Keep connection alive.">eKeepAlive</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa1839a506c945f06a24ded765b5ece67a" title="Allow reuse of a TCP address without delay.">eReuseAddress</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faf5ee4bfe5d2341a7875edb7ff10ff1c2" title="Size of send buffer (in number of chars).">eSendBufSize</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faef38bf8dd0269ab968548ce17aeba64a" title="Socket protocol type">eProtocolType</a>:
<a name="l00248"></a>00248             lValue = lBuffer[0];
<a name="l00249"></a>00249             <span class="keywordflow">break</span>;
<a name="l00250"></a>00250         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fae0dcf7836a0dbfe6de1d8de7f5c1aa47" title="Time to linger on close (in seconds).">eLinger</a>:
<a name="l00251"></a>00251         {
<a name="l00252"></a>00252             <span class="comment">// warning: the linger structure is not the same size on windows and unix!</span>
<a name="l00253"></a>00253             <span class="keyword">struct </span>linger* lPtr = (<span class="keyword">struct </span>linger*) lBuffer;
<a name="l00254"></a>00254             <span class="keywordflow">if</span>(lPtr-&gt;l_onoff) lValue = lPtr-&gt;l_linger;
<a name="l00255"></a>00255             <span class="keywordflow">else</span> lValue = -1;
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257             <span class="keywordflow">break</span>;
<a name="l00258"></a>00258         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">eRecvTimeOut</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">eSendTimeOut</a>:
<a name="l00259"></a>00259 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>            <span class="comment">// on windows, timeout is specified in milliseconds</span>
<a name="l00261"></a>00261             lValue = (float)lBuffer[0]/1000.;
<a name="l00262"></a>00262 <span class="preprocessor">#else</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span>            <span class="comment">// on unix, timeout is specified with timeval structure</span>
<a name="l00264"></a>00264             {
<a name="l00265"></a>00265                 <span class="keyword">struct </span>timeval* lPtr = (<span class="keyword">struct </span>timeval*) lBuffer;
<a name="l00266"></a>00266                 lValue = (float)lPtr-&gt;tv_sec + lPtr-&gt;tv_usec/1000000.;
<a name="l00267"></a>00267             }
<a name="l00268"></a>00268 <span class="preprocessor">#endif</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span>                <span class="keywordflow">break</span>;
<a name="l00270"></a>00270         <span class="keywordflow">default</span>:
<a name="l00271"></a>00271             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::getSockOpt() unknown socket option&quot;</span>);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273     <span class="keywordflow">return</span> lValue;
<a name="l00274"></a>00274 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0e68df0b3d1d51a01e6875d539616b68"></a><!-- doxytag: member="PACC::SVG::Canvas::insertAsLastChild" ref="a0e68df0b3d1d51a01e6875d539616b68" args="(Node *inChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> * XML::Node::insertAsLastChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> *&nbsp;</td>
          <td class="paramname"> <em>inChild</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert node <code>inChild</code> after the last child of this node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the inserted child node. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00188">188</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00188"></a>00188                                                     {
<a name="l00189"></a>00189     <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(inChild, <span class="stringliteral">&quot;Cannot add null pointer node&quot;</span>);
<a name="l00190"></a>00190     <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(!inChild-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> &amp;&amp; !inChild-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> &amp;&amp; !inChild-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>, <span class="stringliteral">&quot;Node must be detached before it can be added!&quot;</span>);
<a name="l00191"></a>00191     <span class="comment">// is this new child the first?</span>
<a name="l00192"></a>00192     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5de69ebc4618625e8be3b626f0015d8e" title="Pointer to first child node.">mFirstChild</a> == NULL) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5de69ebc4618625e8be3b626f0015d8e" title="Pointer to first child node.">mFirstChild</a> = inChild;
<a name="l00193"></a>00193     <span class="keywordflow">else</span> {
<a name="l00194"></a>00194         <span class="comment">// insert after last</span>
<a name="l00195"></a>00195         inChild-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a>;
<a name="l00196"></a>00196         <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a>-&gt;mNextSibling = inChild;
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198     <span class="comment">// adjust parent pointers</span>
<a name="l00199"></a>00199     inChild-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> = <span class="keyword">this</span>;
<a name="l00200"></a>00200     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a877bbbcdb99e8d86fadf2f407827bc7e" title="Pointer to last child node.">mLastChild</a> = inChild;
<a name="l00201"></a>00201     <span class="keywordflow">return</span> inChild;
<a name="l00202"></a>00202 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3d4d55e56ae811162e70ba2c7d6c84c2"></a><!-- doxytag: member="PACC::SVG::Canvas::insertAsPreviousSibling" ref="a3d4d55e56ae811162e70ba2c7d6c84c2" args="(Node *inSibling)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> * XML::Node::insertAsPreviousSibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> *&nbsp;</td>
          <td class="paramname"> <em>inSibling</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert node <code>inSibling</code> as the sibling that preceeds this node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the inserted sibling node. </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00206">206</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00206"></a>00206                                                             {
<a name="l00207"></a>00207     <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(inSibling, <span class="stringliteral">&quot;Cannot insert null pointer node&quot;</span>);
<a name="l00208"></a>00208     <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(!inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> &amp;&amp; !inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> &amp;&amp; !inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a>, <span class="stringliteral">&quot;Node must be detached before it can be inserted!&quot;</span>);
<a name="l00209"></a>00209     <span class="comment">// is this new sibling the first?</span>
<a name="l00210"></a>00210     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> == NULL) {
<a name="l00211"></a>00211         inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a> = <span class="keyword">this</span>;
<a name="l00212"></a>00212         <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = inSibling;
<a name="l00213"></a>00213         <span class="comment">// adjust first child of parent</span>
<a name="l00214"></a>00214         <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>-&gt;mFirstChild = inSibling;
<a name="l00215"></a>00215     } <span class="keywordflow">else</span> {
<a name="l00216"></a>00216         <span class="comment">// this node is neither the first or the last</span>
<a name="l00217"></a>00217         <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>-&gt;mNextSibling = inSibling;
<a name="l00218"></a>00218         inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a>;
<a name="l00219"></a>00219         inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a04f583ab7607580c61ce035f28239004" title="Pointer to next sibling node.">mNextSibling</a> = <span class="keyword">this</span>;
<a name="l00220"></a>00220         <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a24b310a643deaa72ca39cf9b5c57f056" title="Pointer to previous sibling node.">mPrevSibling</a> = inSibling;
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222     <span class="comment">// adjust parent pointer</span>
<a name="l00223"></a>00223     inSibling-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a> = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a216f93b39a91daca6aad1608195c477f" title="Pointer to parent node.">mParent</a>;
<a name="l00224"></a>00224     <span class="keywordflow">return</span> inSibling;
<a name="l00225"></a>00225 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0180add2f0a595baeae502607a74ea64"></a><!-- doxytag: member="PACC::SVG::Canvas::open" ref="a0180add2f0a595baeae502607a74ea64" args="(Protocol=eTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga3109f582afef6bc8e60e4bbf26fc0ac6">Socket::Protocol</a>&nbsp;</td>
          <td class="paramname"> <em>inProtocol</em> = <code>eTCP</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open new socket descriptor. </p>
<p>A socket descriptor is allocated using the protocol determined by parameter <code>inProtocol</code>. The <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> protocol is selected with value <code>eTCP</code> (default), while the <a class="el" href="class_p_a_c_c_1_1_socket_1_1_u_d_p.html" title="Portable UDP client.">UDP</a> protocol is chosen with value <code>eUDP</code>.</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00291">291</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00292"></a>00292 {
<a name="l00293"></a>00293 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">bool</span> lInitialized = <span class="keyword">false</span>;
<a name="l00295"></a>00295     <span class="keywordflow">if</span>(!lInitialized) {
<a name="l00296"></a>00296         WSADATA wsdata;
<a name="l00297"></a>00297         <span class="keywordflow">if</span> (WSAStartup(MAKEWORD(2,2), &amp;wsdata) != 0) {
<a name="l00298"></a>00298             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::open() failed to load WinSock2&quot;</span>);
<a name="l00299"></a>00299         }
<a name="l00300"></a>00300         lInitialized = <span class="keyword">true</span>;
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302 <span class="preprocessor">#endif</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span>    <span class="comment">// first close socket if already open</span>
<a name="l00304"></a>00304     <span class="keywordflow">if</span>(!INVALID_SOCKET) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00305"></a>00305     <span class="comment">// select protocol and create new socket descriptor</span>
<a name="l00306"></a>00306     <span class="keywordflow">if</span>(inProtocol == <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a058e23bb541cf7bdc7f6975d987c477d" title="Transfer Control Protocol.">eTCP</a>) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> = ::socket(AF_INET, SOCK_STREAM, 0);
<a name="l00307"></a>00307     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(inProtocol == <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a9caf36aa3cd32acd779c55f0f8e1ff54" title="User Datagram Protocol.">eUDP</a>) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> = ::socket(AF_INET, SOCK_DGRAM, 0);
<a name="l00308"></a>00308     <span class="keywordflow">else</span> <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::open() unsupported socket protocol&quot;</span>);
<a name="l00309"></a>00309     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) {
<a name="l00310"></a>00310         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::open() unable to allocate socket descriptor&quot;</span>);
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a48493203d020c08ebbd44bd98f09d43c"></a><!-- doxytag: member="PACC::SVG::Canvas::parse" ref="a48493203d020c08ebbd44bd98f09d43c" args="(Tokenizer &amp;inTokenizer, const set&lt; string &gt; &amp;inNoParseTags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html">XML::Node</a> * XML::Node::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_tokenizer.html">PACC::Tokenizer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inTokenizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>inNoParseTags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse next tag using stream tokenizer <code>inTokenizer</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A node pointer to the parsed element. Any tag name defined in <code>inNoParseTags</code> will be treated as if its content is a string token (content will not be parsed). </dd></dl>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00230">230</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00231"></a>00231 {
<a name="l00232"></a>00232     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a" title="Construct empty root node.">Node</a>* lNode = NULL;
<a name="l00233"></a>00233     <span class="comment">// look for start tag</span>
<a name="l00234"></a>00234     <span class="keywordtype">string</span> lToken;
<a name="l00235"></a>00235     inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&lt;&quot;</span>);
<a name="l00236"></a>00236     <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken)) <span class="keywordflow">return</span> 0;
<a name="l00237"></a>00237     <span class="comment">// remove any leading white space</span>
<a name="l00238"></a>00238     size_type lPos = lToken.find_first_not_of(<span class="stringliteral">&quot; \t\r\n&quot;</span>);
<a name="l00239"></a>00239     <span class="keywordflow">if</span>(lPos == string::npos) {
<a name="l00240"></a>00240         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken)) <span class="keywordflow">return</span> 0;
<a name="l00241"></a>00241     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lPos &gt; 0) lToken.erase(0, lPos);
<a name="l00242"></a>00242     <span class="keywordflow">if</span>(lToken[0] == <span class="charliteral">&apos;&lt;&apos;</span>) {
<a name="l00243"></a>00243         <span class="comment">// check for end tag</span>
<a name="l00244"></a>00244         <span class="keywordflow">if</span>(inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad30595ff4eceac8815ca139934033888" title="Return the next character from the default input stream.">peekNextChar</a>() == <span class="charliteral">&apos;/&apos;</span>) {
<a name="l00245"></a>00245             <span class="comment">// found end tag; </span>
<a name="l00246"></a>00246             inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>);
<a name="l00247"></a>00247             inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken);
<a name="l00248"></a>00248             <span class="keywordflow">return</span> 0;
<a name="l00249"></a>00249         }
<a name="l00250"></a>00250         <span class="comment">// found start tag</span>
<a name="l00251"></a>00251         lNode = <span class="keyword">new</span> <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a" title="Construct empty root node.">Node</a>;
<a name="l00252"></a>00252         lNode-&gt;parseStartTag(inTokenizer, lToken);
<a name="l00253"></a>00253         <span class="keywordflow">if</span>(lToken[0] == <span class="charliteral">&apos;/&apos;</span>) {
<a name="l00254"></a>00254             <span class="comment">// found end tag; next token must be &apos;&gt;&apos;</span>
<a name="l00255"></a>00255             inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00256"></a>00256             <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken)) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00257"></a>00257             <span class="keywordflow">if</span>(lToken[0] != <span class="charliteral">&apos;&gt;&apos;</span>) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;invalid start tag&quot;</span>);
<a name="l00258"></a>00258         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lNode-&gt;getType() == <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a62511869bb50207683e31806b802c576" title="Regular data markup element.">eData</a>) {
<a name="l00259"></a>00259             <span class="comment">// either read or parse tag content</span>
<a name="l00260"></a>00260             <span class="keywordflow">if</span>(inNoParseTags.find((*lNode)[<span class="stringliteral">&quot;&quot;</span>]) != inNoParseTags.end()) {
<a name="l00261"></a>00261                 lNode-&gt;readContentAsString(inTokenizer);
<a name="l00262"></a>00262             } <span class="keywordflow">else</span> {
<a name="l00263"></a>00263                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a" title="Construct empty root node.">Node</a>* lChild;
<a name="l00264"></a>00264                 <span class="comment">// parse all child</span>
<a name="l00265"></a>00265                 <span class="keywordflow">while</span>((lChild=<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a48493203d020c08ebbd44bd98f09d43c" title="Parse next tag using stream tokenizer inTokenizer.">parse</a>(inTokenizer, inNoParseTags)) != NULL) lNode-&gt;insertAsLastChild(lChild);
<a name="l00266"></a>00266                 <span class="comment">// test for valid end tag</span>
<a name="l00267"></a>00267                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot; \t\n\r&gt;&quot;</span>);
<a name="l00268"></a>00268                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken)) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00269"></a>00269                 <span class="keywordflow">if</span>(lToken != (*lNode)[<span class="stringliteral">&quot;&quot;</span>]) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;invalid end tag&quot;</span>);
<a name="l00270"></a>00270             }
<a name="l00271"></a>00271             <span class="comment">// next token must be &apos;&gt;&apos;</span>
<a name="l00272"></a>00272             inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot; \t\n\r&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00273"></a>00273             <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(lToken)) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00274"></a>00274             <span class="keywordflow">if</span>(lToken[0] != <span class="charliteral">&apos;&gt;&apos;</span>) lNode-&gt;throwError(inTokenizer, <span class="stringliteral">&quot;invalid end tag&quot;</span>);
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276         <span class="comment">// else node is not markup</span>
<a name="l00277"></a>00277     } <span class="keywordflow">else</span> {
<a name="l00278"></a>00278         <span class="comment">// found a simple string node</span>
<a name="l00279"></a>00279         lNode = <span class="keyword">new</span> <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a81cadd2778d4c444bb510fea1458fb0a" title="Construct empty root node.">Node</a>;
<a name="l00280"></a>00280         lNode-&gt;mType = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a02125ab9eed124fe7ff63344f2f3c507" title="Literal string.">eString</a>;
<a name="l00281"></a>00281         <span class="comment">// remove any ending white space</span>
<a name="l00282"></a>00282         lPos = lToken.find_last_not_of(<span class="stringliteral">&quot; \t\r\n&quot;</span>);
<a name="l00283"></a>00283         <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(lPos != string::npos, <span class="stringliteral">&quot;Internal error!&quot;</span>);
<a name="l00284"></a>00284         <span class="keywordflow">if</span>(lPos &lt; lToken.size()-1) lToken.resize(lPos+1);
<a name="l00285"></a>00285         <span class="comment">// convert basic quotes</span>
<a name="l00286"></a>00286         (*lNode)[<span class="stringliteral">&quot;&quot;</span>] = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5227d2bef95e7dda97f2b63d617a3724" title="Convert basic xml quotes into ascii characters.">convertFromQuotes</a>(lToken);
<a name="l00287"></a>00287     }
<a name="l00288"></a>00288     <span class="keywordflow">return</span> lNode;
<a name="l00289"></a>00289 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae3112e9f79d990cb581e97179496003d"></a><!-- doxytag: member="PACC::SVG::Canvas::parseAttributeList" ref="ae3112e9f79d990cb581e97179496003d" args="(Tokenizer &amp;inTokenizer, string &amp;outToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XML::Node::parseAttributeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_tokenizer.html">PACC::Tokenizer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inTokenizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&nbsp;</td>
          <td class="paramname"> <em>outToken</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse the attribute list using stream tokenizer <code>inTokenizer</code>. </p>
<p>Ending token is returned through argument <code>outToken</code>. </p>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00294">294</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00295"></a>00295 {
<a name="l00296"></a>00296     inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot; \t\n\r&quot;</span>, <span class="stringliteral">&quot;=/?&gt;&quot;</span>);
<a name="l00297"></a>00297     <span class="comment">// next token should be an attribute name</span>
<a name="l00298"></a>00298     <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00299"></a>00299     <span class="comment">// parse all attributes</span>
<a name="l00300"></a>00300     <span class="keywordflow">while</span>(outToken[0] != <span class="charliteral">&apos;&gt;&apos;</span> &amp;&amp; outToken[0] != <span class="charliteral">&apos;/&apos;</span> &amp;&amp; outToken[0] != <span class="charliteral">&apos;?&apos;</span>)
<a name="l00301"></a>00301     {
<a name="l00302"></a>00302         <span class="keywordflow">if</span>(outToken[0] == <span class="charliteral">&apos;=&apos;</span>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;missing attribute name&quot;</span>);
<a name="l00303"></a>00303         <span class="comment">// ok, found an attribute name!</span>
<a name="l00304"></a>00304         <span class="keywordtype">string</span> lName = outToken;
<a name="l00305"></a>00305         <span class="comment">// next token should be &apos;=&apos;</span>
<a name="l00306"></a>00306         inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot; \t\n\r&quot;</span>, <span class="stringliteral">&quot;=&quot;</span>);
<a name="l00307"></a>00307         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken) || outToken[0] != <span class="charliteral">&apos;=&apos;</span>) 
<a name="l00308"></a>00308             <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;invalid attribute&quot;</span>);
<a name="l00309"></a>00309         inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot; \t\n\r&quot;</span>, <span class="stringliteral">&quot;&apos;\&quot;&quot;</span>);
<a name="l00310"></a>00310         <span class="comment">// next token must be &apos;&quot;&apos; or &quot;&apos;&quot;</span>
<a name="l00311"></a>00311         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00312"></a>00312         <span class="keywordtype">string</span> lValue;
<a name="l00313"></a>00313         <span class="keywordflow">switch</span>(outToken[0]) {
<a name="l00314"></a>00314             <span class="keywordflow">case</span> <span class="charliteral">&apos;\&apos;&apos;</span>:
<a name="l00315"></a>00315                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&apos;&quot;</span>);
<a name="l00316"></a>00316                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00317"></a>00317                     <span class="keywordflow">if</span>(outToken[0] != <span class="charliteral">&apos;\&apos;&apos;</span>) {
<a name="l00318"></a>00318                         lValue = outToken;
<a name="l00319"></a>00319                         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00320"></a>00320                     }
<a name="l00321"></a>00321                         <span class="keywordflow">break</span>;
<a name="l00322"></a>00322             <span class="keywordflow">case</span> <span class="charliteral">&apos;&quot;&apos;</span>:
<a name="l00323"></a>00323                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\&quot;&quot;</span>);
<a name="l00324"></a>00324                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00325"></a>00325                     <span class="keywordflow">if</span>(outToken[0] != <span class="charliteral">&apos;&quot;&apos;</span>) {
<a name="l00326"></a>00326                         lValue = outToken;
<a name="l00327"></a>00327                         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00328"></a>00328                     }
<a name="l00329"></a>00329                         <span class="keywordflow">break</span>;
<a name="l00330"></a>00330             <span class="keywordflow">default</span>:
<a name="l00331"></a>00331                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;invalid attribute value&quot;</span>);
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333         <span class="comment">// insert attribute</span>
<a name="l00334"></a>00334         (*this)[lName] = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a5227d2bef95e7dda97f2b63d617a3724" title="Convert basic xml quotes into ascii characters.">convertFromQuotes</a>(lValue);
<a name="l00335"></a>00335         inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot; \t\n\r&quot;</span>, <span class="stringliteral">&quot;=/?&gt;&quot;</span>);
<a name="l00336"></a>00336         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00337"></a>00337     }
<a name="l00338"></a>00338 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5610f5b7d3efb7d5f8914ca37e1ae241"></a><!-- doxytag: member="PACC::SVG::Canvas::parseStartTag" ref="a5610f5b7d3efb7d5f8914ca37e1ae241" args="(Tokenizer &amp;inTokenizer, string &amp;outToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XML::Node::parseStartTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_tokenizer.html">PACC::Tokenizer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inTokenizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&nbsp;</td>
          <td class="paramname"> <em>outToken</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse in stream tokenizer <code>inTokenizer</code> the start tag of this node. </p>
<p>This method assumes that token "&lt;" has already been read. It returns the ending token through argument <code>outToken</code>. </p>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00343">343</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00344"></a>00344 {
<a name="l00345"></a>00345     <span class="comment">// parse tag name</span>
<a name="l00346"></a>00346     inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot; \t\n\r/&gt;&quot;</span>);
<a name="l00347"></a>00347     <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00348"></a>00348     <span class="keywordflow">if</span>(outToken.find_first_of(<span class="stringliteral">&quot; \t\n\r/&gt;&quot;</span>) != string::npos) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;invalid start tag&quot;</span>);
<a name="l00349"></a>00349     <span class="keywordtype">string</span>&amp; lValue = (*this)[<span class="stringliteral">&quot;&quot;</span>];
<a name="l00350"></a>00350     <span class="keywordflow">switch</span>(outToken[0]) {
<a name="l00351"></a>00351         <span class="keywordflow">case</span> <span class="charliteral">&apos;!&apos;</span>:
<a name="l00352"></a>00352             <span class="keywordflow">if</span>(outToken.size() &gt;= 3 &amp;&amp; outToken[1] == <span class="charliteral">&apos;-&apos;</span> &amp;&amp; outToken[2] == <span class="charliteral">&apos;-&apos;</span>) {
<a name="l00353"></a>00353                 <span class="comment">// process comment</span>
<a name="l00354"></a>00354                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814aca7d2f335cd554b1c57bc9c0a44cd46d" title="Comment ().">eComment</a>;
<a name="l00355"></a>00355                 outToken.erase(0, 3);
<a name="l00356"></a>00356                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00357"></a>00357                 <span class="keywordflow">do</span> {
<a name="l00358"></a>00358                     <span class="keywordtype">int</span> lSize = outToken.size();
<a name="l00359"></a>00359                     <span class="keywordflow">if</span>(lSize &gt; 2 &amp;&amp; outToken[lSize-2] == <span class="charliteral">&apos;-&apos;</span> &amp;&amp; outToken[lSize-1] == <span class="charliteral">&apos;-&apos;</span>) {
<a name="l00360"></a>00360                         lValue += outToken.erase(lSize-2, 2);
<a name="l00361"></a>00361                         <span class="keywordflow">break</span>;
<a name="l00362"></a>00362                     } <span class="keywordflow">else</span> lValue += outToken;
<a name="l00363"></a>00363                 } <span class="keywordflow">while</span>(inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken));
<a name="l00364"></a>00364                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00365"></a>00365             } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(outToken.size() &gt;= 8 &amp;&amp; memcmp(outToken.data()+1, <span class="stringliteral">&quot;[CDATA[&quot;</span>, 7) == 0) {
<a name="l00366"></a>00366                 <span class="comment">// process cdata section</span>
<a name="l00367"></a>00367                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a3af269fb25b96d387de378e0249c4fa9" title="CDATA section (&amp;lt;![CDATA[ ... ]]&amp;gt;).">eCDATA</a>;
<a name="l00368"></a>00368                 outToken.erase(0, 8);
<a name="l00369"></a>00369                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00370"></a>00370                 <span class="keywordflow">do</span> {
<a name="l00371"></a>00371                     <span class="keywordtype">int</span> lSize = outToken.size();
<a name="l00372"></a>00372                     <span class="keywordflow">if</span>(lSize &gt;= 2 &amp;&amp; outToken[lSize-2] == <span class="charliteral">&apos;]&apos;</span> &amp;&amp; outToken[lSize-1] == <span class="charliteral">&apos;]&apos;</span>) {
<a name="l00373"></a>00373                         lValue += outToken.erase(lSize-2, 2);
<a name="l00374"></a>00374                         <span class="keywordflow">break</span>;
<a name="l00375"></a>00375                     } <span class="keywordflow">else</span> lValue += outToken;
<a name="l00376"></a>00376                 } <span class="keywordflow">while</span>(inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken));
<a name="l00377"></a>00377                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00378"></a>00378             } <span class="keywordflow">else</span> {
<a name="l00379"></a>00379                 <span class="comment">// process special element (doctype, attribute, etc.)</span>
<a name="l00380"></a>00380                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a4a0d08873453878b747a733b33ee4f81" title="Special element (&amp;lt;! ... &amp;gt;).">eSpecial</a>;
<a name="l00381"></a>00381                 lValue = outToken.erase(0, 1);
<a name="l00382"></a>00382                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00383"></a>00383                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00384"></a>00384                 <span class="keywordflow">if</span>(outToken[0] != <span class="charliteral">&apos;&gt;&apos;</span>) {
<a name="l00385"></a>00385                     lValue += outToken;
<a name="l00386"></a>00386                     <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00387"></a>00387                 }
<a name="l00388"></a>00388             }
<a name="l00389"></a>00389             <span class="keywordflow">break</span>;
<a name="l00390"></a>00390         <span class="keywordflow">case</span> <span class="charliteral">&apos;?&apos;</span>:
<a name="l00391"></a>00391             <span class="keywordflow">if</span>(outToken == <span class="stringliteral">&quot;?xml&quot;</span>) {
<a name="l00392"></a>00392                 <span class="comment">// process xml declaration</span>
<a name="l00393"></a>00393                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a1349bbd6e6b8571961f80800dc3059eb" title="XML declaration (&amp;lt;?xml ... ?&amp;gt;).">eDecl</a>;
<a name="l00394"></a>00394                 lValue = outToken.erase(0, 1);
<a name="l00395"></a>00395                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ae3112e9f79d990cb581e97179496003d" title="Parse the attribute list using stream tokenizer inTokenizer.">parseAttributeList</a>(inTokenizer, outToken);
<a name="l00396"></a>00396                 <span class="keywordflow">if</span>(outToken[0] != <span class="charliteral">&apos;?&apos;</span>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;invalid xml declaration&quot;</span>);
<a name="l00397"></a>00397                 <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00398"></a>00398                 <span class="keywordflow">if</span>(outToken[0] != <span class="charliteral">&apos;&gt;&apos;</span>) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;invalid xml declaration&quot;</span>);
<a name="l00399"></a>00399             } <span class="keywordflow">else</span> {
<a name="l00400"></a>00400                 <span class="comment">// process special processing instruction</span>
<a name="l00401"></a>00401                 <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814ac2833f6aa343cf425ab0f4aede27c73f" title="Processing instruction (&amp;lt;? ... ?&amp;gt;).">ePI</a>;
<a name="l00402"></a>00402                 lValue = outToken.substr(1, outToken.size()-1);
<a name="l00403"></a>00403                 inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#a8e37cbb52f67b952d4e697c57d734f3a" title="Set the white space delimiters to the characters of inWhiteSpace, and the single...">setDelimiters</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;?&gt;&quot;</span>);
<a name="l00404"></a>00404                 <span class="keywordflow">while</span>(inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) {
<a name="l00405"></a>00405                     <span class="keywordflow">if</span>(outToken[0] == <span class="charliteral">&apos;?&apos;</span>) {
<a name="l00406"></a>00406                         <span class="keywordflow">if</span>(!inTokenizer.<a class="code" href="class_p_a_c_c_1_1_tokenizer.html#ad2de8f503fee4d80364895ac4804c705" title="Parse next token of default input stream.">getNextToken</a>(outToken)) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00407"></a>00407                         <span class="keywordflow">if</span>(outToken[0] == <span class="charliteral">&apos;&gt;&apos;</span>) <span class="keywordflow">break</span>;
<a name="l00408"></a>00408                         <span class="keywordflow">else</span> lValue += <span class="charliteral">&apos;?&apos;</span>;
<a name="l00409"></a>00409                     } 
<a name="l00410"></a>00410                     lValue += outToken;
<a name="l00411"></a>00411                 }
<a name="l00412"></a>00412                 <span class="keywordflow">if</span>(outToken.empty()) <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#a97a9b5684ee34f60996ddb5686f40e86" title="Throw runtime error with message inMessage using tokenizer inTokenizer.">throwError</a>(inTokenizer, <span class="stringliteral">&quot;unexpected eof&quot;</span>);
<a name="l00413"></a>00413             }
<a name="l00414"></a>00414             <span class="keywordflow">break</span>;
<a name="l00415"></a>00415         <span class="keywordflow">default</span>:
<a name="l00416"></a>00416             <span class="comment">// process data markup</span>
<a name="l00417"></a>00417             <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a> = <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a62511869bb50207683e31806b802c576" title="Regular data markup element.">eData</a>;
<a name="l00418"></a>00418             lValue = outToken;
<a name="l00419"></a>00419             <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ae3112e9f79d990cb581e97179496003d" title="Parse the attribute list using stream tokenizer inTokenizer.">parseAttributeList</a>(inTokenizer, outToken);
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa2bfb38c81fc0695d99f51cc8e7291c6"></a><!-- doxytag: member="PACC::SVG::Canvas::receive" ref="aa2bfb38c81fc0695d99f51cc8e7291c6" args="(char *outBuffer, unsigned inMaxCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Socket::Port::receive </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>inMaxCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive data from connected socket. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of received characters.</dd></dl>
<p>This function waits until some data is received through the socket, or until the timeout period expires. The received data is returned through output parameter <code>outBuffer</code> which must be large enough to contain up to <code>inMaxCount</code> characters. Note that this ouput buffer is NOT null terminated. The function returns the effective number of read characters contained in the output buffer. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, if the other party closes the connection (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> sockets), an exception is thrown with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a>, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if nothing is received before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">Socket::eRecvTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00319">319</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00320"></a>00320 {
<a name="l00321"></a>00321     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::receive() invalid socket&quot;</span>);
<a name="l00322"></a>00322     void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00323"></a>00323     <span class="keywordtype">int</span> lRecv = ::recv(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, outBuffer, inMaxCount, 0);
<a name="l00324"></a>00324     ::signal(SIGPIPE, lPipeMethod);
<a name="l00325"></a>00325     <span class="keywordflow">if</span>(lRecv &lt; 0) {
<a name="l00326"></a>00326         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00327"></a>00327     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lRecv == 0) {
<a name="l00328"></a>00328         <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00329"></a>00329         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331     <span class="keywordflow">return</span> lRecv;
<a name="l00332"></a>00332 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a51c6ac893e8b8d3ebeb6578de0243fad"></a><!-- doxytag: member="PACC::SVG::Canvas::receive" ref="a51c6ac893e8b8d3ebeb6578de0243fad" args="(char *inBuffer, unsigned int inCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Cafe::receive </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive <code>inCount</code> bytes from socket. </p>
<p>WARNING: in order to enable message compression, this class needs to be compiled with variable PACC_ZLIB set.</p>
<p>This method will wait until the specified amount of bytes in received from the socket. It assumes that buffer <code>inBuffer</code> is large enough to accept <code>inCount</code> bytes. Any error (e.g. timeouts or broken connection) will throw a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_cafe_8cpp_source.html#l00093">93</a> of file <a class="el" href="_cafe_8cpp_source.html">Cafe.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00094"></a>00094 {
<a name="l00095"></a>00095     PACC::UInt32 lTotalReceived = 0;
<a name="l00096"></a>00096     <span class="keywordflow">while</span>(lTotalReceived &lt; inCount) {
<a name="l00097"></a>00097         PACC::UInt32 lRecv = <a class="code" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a51c6ac893e8b8d3ebeb6578de0243fad" title="Receive inCount bytes from socket.">Port::receive</a>(inBuffer+lTotalReceived, inCount-lTotalReceived);
<a name="l00098"></a>00098         lTotalReceived += lRecv;;
<a name="l00099"></a>00099     }
<a name="l00100"></a>00100 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abc30f2043f597dc71e7113528824b42b"></a><!-- doxytag: member="PACC::SVG::Canvas::receiveFrom" ref="abc30f2043f597dc71e7113528824b42b" args="(char *outBuffer, unsigned inMaxCount, Address &amp;outPeer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Socket::Port::receiveFrom </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>inMaxCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outPeer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive data from unconnected socket. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of received characters .</dd></dl>
<p>This function waits until some data is received through the socket, or until the timeout period expires. The received data is returned through output parameter <code>outBuffer</code> which must be large enough to contain up to <code>inMaxCount</code> characters. Note that this ouput buffer is NOT null terminated. The function returns the effective number of read characters contained in the output buffer. The peer socket address is also returned through output parameter <code>outPeer</code>. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, if the other party closes the connection (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> sockets), an exception is thrown with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a>, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if nothing is received before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">Socket::eRecvTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00339">339</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00340"></a>00340 {
<a name="l00341"></a>00341     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::receiveFrom() invalid socket&quot;</span>);
<a name="l00342"></a>00342     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00343"></a>00343     socklen_t lSize = <span class="keyword">sizeof</span>(lSock);
<a name="l00344"></a>00344     void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00345"></a>00345     <span class="keywordtype">int</span> lRecv = ::recvfrom(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, outBuffer, inMaxCount, 0, (<span class="keyword">struct </span>sockaddr*) &amp;lSock, &amp;lSize);
<a name="l00346"></a>00346     ::signal(SIGPIPE, lPipeMethod);
<a name="l00347"></a>00347     <span class="keywordflow">if</span>(lRecv &lt; 0) {
<a name="l00348"></a>00348         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00349"></a>00349     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lRecv == 0) {
<a name="l00350"></a>00350         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352     <span class="comment">// transfer peer address</span>
<a name="l00353"></a>00353     outPeer = Address(ntohs(lSock.sin_port), inet_ntoa(lSock.sin_addr));
<a name="l00354"></a>00354     <span class="keywordflow">return</span> lRecv;
<a name="l00355"></a>00355 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a05f1172f301e049288c059e1b7353544"></a><!-- doxytag: member="PACC::SVG::Canvas::receiveMessage" ref="a05f1172f301e049288c059e1b7353544" args="(string &amp;outMessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Cafe::receiveMessage </td>
          <td>(</td>
          <td class="paramtype">string &amp;&nbsp;</td>
          <td class="paramname"> <em>outMessage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive string message from connected server using the 0cafe protocol. </p>
<p>This function waits for a valid message according to the <a class="el" href="class_p_a_c_c_1_1_socket_1_1_cafe.html" title="Cafe protocol.">Cafe</a> protocol, or until time out. It returns the received message through output parameter <code>OutMessage</code>. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party before message end, with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a3c996a0b6c165b7884542bf0d0a64492" title="Message signature is invalid.">Socket::eBadMessage</a> if the protocol signature is invalid, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the timeout period expires before reception of a cmoplete message. The timeout period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">Socket::eRecvTimeOut</a>. </p>

<p>Reimplemented from <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#a7213a4475b86817b0396e6cf87c917d1">PACC::Socket::TCP</a>.</p>

<p>Definition at line <a class="el" href="_cafe_8cpp_source.html#l00112">112</a> of file <a class="el" href="_cafe_8cpp_source.html">Cafe.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00113"></a>00113 {
<a name="l00114"></a>00114     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> &lt; 0) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Cafe::receiveMessage() invalid socket&quot;</span>);
<a name="l00115"></a>00115     <span class="comment">// check message signature</span>
<a name="l00116"></a>00116     PACC::UInt32 lSignature = 0;
<a name="l00117"></a>00117     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a51c6ac893e8b8d3ebeb6578de0243fad" title="Receive inCount bytes from socket.">receive</a>((<span class="keywordtype">char</span>*)&amp;lSignature, <span class="keyword">sizeof</span>(lSignature));
<a name="l00118"></a>00118     <span class="keywordflow">switch</span>(ntohl(lSignature)) 
<a name="l00119"></a>00119     {
<a name="l00120"></a>00120         <span class="keywordflow">case</span> 0xCAFE: <span class="comment">// uncompressed Cafe</span>
<a name="l00121"></a>00121         {
<a name="l00122"></a>00122             <span class="comment">// read message size</span>
<a name="l00123"></a>00123             PACC::UInt32 lMessageSize = 0;
<a name="l00124"></a>00124             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a51c6ac893e8b8d3ebeb6578de0243fad" title="Receive inCount bytes from socket.">receive</a>((<span class="keywordtype">char</span>*)&amp;lMessageSize, <span class="keyword">sizeof</span>(lMessageSize));
<a name="l00125"></a>00125             lMessageSize = ntohl(lMessageSize);
<a name="l00126"></a>00126             <span class="comment">// resize output string</span>
<a name="l00127"></a>00127             outMessage.resize(lMessageSize);
<a name="l00128"></a>00128             <span class="comment">// read message body</span>
<a name="l00129"></a>00129             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a51c6ac893e8b8d3ebeb6578de0243fad" title="Receive inCount bytes from socket.">receive</a>(&amp;outMessage[0], lMessageSize);
<a name="l00130"></a>00130             <span class="keywordflow">break</span>;
<a name="l00131"></a>00131         }
<a name="l00132"></a>00132         <span class="keywordflow">case</span> 0xCCAFE: <span class="comment">// compressed Cafe</span>
<a name="l00133"></a>00133         {
<a name="l00134"></a>00134 <span class="preprocessor">#ifdef PACC_ZLIB</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>            <span class="comment">// read message size</span>
<a name="l00136"></a>00136             PACC::UInt32 lMessageSize = 0;
<a name="l00137"></a>00137             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a51c6ac893e8b8d3ebeb6578de0243fad" title="Receive inCount bytes from socket.">receive</a>((<span class="keywordtype">char</span>*)&amp;lMessageSize, <span class="keyword">sizeof</span>(lMessageSize));
<a name="l00138"></a>00138             lMessageSize = ntohl(lMessageSize);
<a name="l00139"></a>00139             <span class="comment">// resize output string</span>
<a name="l00140"></a>00140             outMessage.resize(lMessageSize);
<a name="l00141"></a>00141             <span class="comment">//read uncompressed size</span>
<a name="l00142"></a>00142             PACC::UInt32 lUncompressedSize = 0;
<a name="l00143"></a>00143             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a51c6ac893e8b8d3ebeb6578de0243fad" title="Receive inCount bytes from socket.">receive</a>((<span class="keywordtype">char</span>*)&amp;lUncompressedSize, <span class="keyword">sizeof</span>(lUncompressedSize));
<a name="l00144"></a>00144             lUncompressedSize = ntohl(lUncompressedSize);           
<a name="l00145"></a>00145             <span class="comment">// read message body</span>
<a name="l00146"></a>00146             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a51c6ac893e8b8d3ebeb6578de0243fad" title="Receive inCount bytes from socket.">receive</a>(&amp;outMessage[0], lMessageSize);
<a name="l00147"></a>00147             <span class="comment">//decompress message </span>
<a name="l00148"></a>00148             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#abe889cfda9bf200f415161f4bba3e754" title="Uncompress string ioMessage knowing that the uncompressed message length is inUncompressedSize...">uncompress</a>(outMessage, lUncompressedSize);
<a name="l00149"></a>00149             <span class="keywordflow">break</span>;
<a name="l00150"></a>00150 <span class="preprocessor">#else</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span>            <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Cafe::receiveMessage() class needs to be compiled with variable PACC_ZLIB set, in order to enable message decompression&quot;</span>);
<a name="l00152"></a>00152 <span class="preprocessor">#endif</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span>        }
<a name="l00154"></a>00154         <span class="keywordflow">default</span>: <span class="comment">// unknown</span>
<a name="l00155"></a>00155             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a3c996a0b6c165b7884542bf0d0a64492" title="Message signature is invalid.">eBadMessage</a>, <span class="stringliteral">&quot;Cafe::receiveMessage() invalid signature&quot;</span>);
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7e0f88dff3eacee95675eb0fcc9cc740"></a><!-- doxytag: member="PACC::SVG::Canvas::send" ref="a7e0f88dff3eacee95675eb0fcc9cc740" args="(const char *inBuffer, unsigned int inCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::send </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send data to connected socket. </p>
<p>This function sends to its peer socket the <code>inCount</code> characters of data contained in buffer <code>inBuffer</code> (socket is assumed connected). Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party during message transmission, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the message cannot be sent before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">Socket::eSendTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00360">360</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00361"></a>00361 {
<a name="l00362"></a>00362     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::send() invalid socket&quot;</span>);
<a name="l00363"></a>00363     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lTotalSent = 0;
<a name="l00364"></a>00364     <span class="comment">// send all data</span>
<a name="l00365"></a>00365     <span class="keywordflow">while</span>(lTotalSent &lt; inCount) {
<a name="l00366"></a>00366         void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00367"></a>00367         <span class="keywordtype">int</span> lSent =<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket."> ::send</a>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, inBuffer+lTotalSent, inCount-lTotalSent, 0);
<a name="l00368"></a>00368         ::signal(SIGPIPE, lPipeMethod);
<a name="l00369"></a>00369         <span class="keywordflow">if</span>(lSent &lt; 0) {
<a name="l00370"></a>00370             <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00371"></a>00371         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lSent &lt; 1) {
<a name="l00372"></a>00372             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00373"></a>00373             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375         lTotalSent += lSent;
<a name="l00376"></a>00376     }
<a name="l00377"></a>00377 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adc5fb826b4851b5314c9248ed94620e9"></a><!-- doxytag: member="PACC::SVG::Canvas::sendMessage" ref="adc5fb826b4851b5314c9248ed94620e9" args="(const string &amp;inMessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::TCP::sendMessage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>inMessage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send string message to connected (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a>) server. </p>
<p>This function sends message string <code>inMessage</code> to the connected peer socket. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party during message transmission, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the message cannot be sent before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">Socket::eSendTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_t_c_p_8cpp_source.html#l00060">60</a> of file <a class="el" href="_t_c_p_8cpp_source.html">TCP.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00061"></a>00061 {
<a name="l00062"></a>00062     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket.">send</a>(inMessage.data(), inMessage.size());
<a name="l00063"></a>00063 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6211c7829f7a55ce68fcaffdaed7a513"></a><!-- doxytag: member="PACC::SVG::Canvas::sendMessage" ref="a6211c7829f7a55ce68fcaffdaed7a513" args="(const string &amp;inMessage, unsigned int inCompressionLevel=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Cafe::sendMessage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>inMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inCompressionLevel</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send string message <code>inMessage</code> to connected server using the cafe protocol. </p>
<p>This function sends a message string using either of the two <a class="el" href="class_p_a_c_c_1_1_socket_1_1_cafe.html" title="Cafe protocol.">Cafe</a> protocols. The user can specify a compression level using argument <code>inCompressionLevel</code>. However, this argument is ignored by default and messages are not compressed in any way. To enable compression, the class must be compiled with variable PACC_ZLIB set, and the executable must be linked with the zlib library &lt;<a href="http://www.gzip.org/zlib">http://www.gzip.org/zlib</a>&gt;.</p>
<p>Compression level must range from 0 to 9. A nul compression level means no compression, while a level of 9 specifies maximum compression. The message is sent compressed only if smaller than the original.</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party during message transmission, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the message cannot be sent before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">Socket::eSendTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_cafe_8cpp_source.html#l00177">177</a> of file <a class="el" href="_cafe_8cpp_source.html">Cafe.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00178"></a>00178 {
<a name="l00179"></a>00179     <span class="keywordflow">if</span>(inCompressionLevel &gt; 9)
<a name="l00180"></a>00180     {
<a name="l00181"></a>00181         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Cafe::sendMessage() invalid compression level!&quot;</span>);
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183 <span class="preprocessor">#ifdef PACC_ZLIB</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(inCompressionLevel &gt; 0)
<a name="l00185"></a>00185     {
<a name="l00186"></a>00186         <span class="comment">// try to compress message</span>
<a name="l00187"></a>00187         <span class="keywordtype">string</span> lCompressedMessage;
<a name="l00188"></a>00188         <a class="code" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a8ef4276b27831a7de99867dfbbe1710f" title="Compress string inMessage using compression level inCompressionLevel, and return...">compress</a>(inMessage, lCompressedMessage, inCompressionLevel);
<a name="l00189"></a>00189         <span class="keywordflow">if</span>(lCompressedMessage.size() &lt; inMessage.size()) 
<a name="l00190"></a>00190         {
<a name="l00191"></a>00191             <span class="comment">// send compressed message only if smaller</span>
<a name="l00192"></a>00192             <span class="comment">// assume MTU is 1500 bytes - IP headers</span>
<a name="l00193"></a>00193             <span class="keywordtype">char</span> lBuffer[1460]; 
<a name="l00194"></a>00194             PACC::UInt32* lHeader = (PACC::UInt32*) lBuffer;
<a name="l00195"></a>00195             lHeader[0] = htonl(0xCCAFE);
<a name="l00196"></a>00196             lHeader[1] = htonl(lCompressedMessage.size());
<a name="l00197"></a>00197             lHeader[2] = htonl(inMessage.size());
<a name="l00198"></a>00198             <span class="comment">// copy start of compressed message to header</span>
<a name="l00199"></a>00199             memcpy(lBuffer+12, lCompressedMessage.data(), (lCompressedMessage.size()&lt;<span class="keyword">sizeof</span>(lBuffer)-12?lCompressedMessage.size():<span class="keyword">sizeof</span>(lBuffer)-12));
<a name="l00200"></a>00200             <span class="comment">// write header and compressed message</span>
<a name="l00201"></a>00201             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket.">send</a>(lBuffer, (lCompressedMessage.size()&lt;<span class="keyword">sizeof</span>(lBuffer)-12?lCompressedMessage.size()+12:<span class="keyword">sizeof</span>(lBuffer)));
<a name="l00202"></a>00202             <span class="keywordflow">if</span>(lCompressedMessage.size() &gt; <span class="keyword">sizeof</span>(lBuffer)-12) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket.">send</a>(lCompressedMessage.data()+<span class="keyword">sizeof</span>(lBuffer)-12, lCompressedMessage.size()-<span class="keyword">sizeof</span>(lBuffer)+12);
<a name="l00203"></a>00203         } <span class="keywordflow">else</span> {
<a name="l00204"></a>00204             <span class="comment">// send uncompressed message</span>
<a name="l00205"></a>00205             <span class="comment">// assume MTU is 1500 bytes - IP headers</span>
<a name="l00206"></a>00206             <span class="keywordtype">char</span> lBuffer[1460]; 
<a name="l00207"></a>00207             PACC::UInt32* lHeader = (PACC::UInt32*) lBuffer;
<a name="l00208"></a>00208             lHeader[0] = htonl(0xCAFE);
<a name="l00209"></a>00209             lHeader[1] = htonl(inMessage.size());
<a name="l00210"></a>00210             <span class="comment">// copy start of uncompressed message to header</span>
<a name="l00211"></a>00211             memcpy(lBuffer+8, inMessage.data(), (inMessage.size()&lt;<span class="keyword">sizeof</span>(lBuffer)-8?inMessage.size():<span class="keyword">sizeof</span>(lBuffer)-8));
<a name="l00212"></a>00212             <span class="comment">// write header and uncompressed message</span>
<a name="l00213"></a>00213             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket.">send</a>(lBuffer, (inMessage.size()&lt;<span class="keyword">sizeof</span>(lBuffer)-8?inMessage.size()+8:<span class="keyword">sizeof</span>(lBuffer)));
<a name="l00214"></a>00214             <span class="keywordflow">if</span>(inMessage.size() &gt; <span class="keyword">sizeof</span>(lBuffer)-8) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket.">send</a>(inMessage.data()+<span class="keyword">sizeof</span>(lBuffer)-8, inMessage.size()-<span class="keyword">sizeof</span>(lBuffer)+8);
<a name="l00215"></a>00215         }
<a name="l00216"></a>00216     } <span class="keywordflow">else</span>
<a name="l00217"></a>00217 <span class="preprocessor">#endif</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span>    {
<a name="l00219"></a>00219         <span class="comment">// send uncompressed message (compression is disabled)</span>
<a name="l00220"></a>00220         <span class="comment">// assume MTU is 1500 bytes - IP headers</span>
<a name="l00221"></a>00221         <span class="keywordtype">char</span> lBuffer[1460]; 
<a name="l00222"></a>00222         PACC::UInt32* lHeader = (PACC::UInt32*) lBuffer;
<a name="l00223"></a>00223         lHeader[0] = htonl(0xCAFE);
<a name="l00224"></a>00224         lHeader[1] = htonl(inMessage.size());
<a name="l00225"></a>00225         <span class="comment">// copy start of message to header</span>
<a name="l00226"></a>00226         memcpy(lBuffer+8, inMessage.data(), (inMessage.size()&lt;<span class="keyword">sizeof</span>(lBuffer)-8?inMessage.size():<span class="keyword">sizeof</span>(lBuffer)-8));
<a name="l00227"></a>00227         <span class="comment">// write header and message</span>
<a name="l00228"></a>00228         <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket.">send</a>(lBuffer, (inMessage.size()&lt;<span class="keyword">sizeof</span>(lBuffer)-8?inMessage.size()+8:<span class="keyword">sizeof</span>(lBuffer)));
<a name="l00229"></a>00229         <span class="keywordflow">if</span>(inMessage.size() &gt; <span class="keyword">sizeof</span>(lBuffer)-8) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket.">send</a>(inMessage.data()+<span class="keyword">sizeof</span>(lBuffer)-8, inMessage.size()-<span class="keyword">sizeof</span>(lBuffer)+8);
<a name="l00230"></a>00230     }
<a name="l00231"></a>00231 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac9c7959ca0afef4d5fa57a28fba3b4d8"></a><!-- doxytag: member="PACC::SVG::Canvas::sendTo" ref="ac9c7959ca0afef4d5fa57a28fba3b4d8" args="(const char *inBuffer, unsigned int inCount, const Address &amp;inPeer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::sendTo </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inPeer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send data to unconnected socket. </p>
<p>This function sends to peer <code>inPeer</code> the data contained in buffer <code>inBuffer</code> (total of <code>inCount</code> characters). Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party during message transmission, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the message cannot be sent before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">Socket::eSendTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00382">382</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00383"></a>00383 {
<a name="l00384"></a>00384     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::sendTo() invalid socket&quot;</span>);
<a name="l00385"></a>00385     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00386"></a>00386     lSock.sin_family = AF_INET;
<a name="l00387"></a>00387     lSock.sin_port = htons(inPeer.getPortNumber());
<a name="l00388"></a>00388     lSock.sin_addr.s_addr = inet_addr(inPeer.getIPAddress().c_str());
<a name="l00389"></a>00389     memset(&amp;lSock.sin_zero, 0, 8);
<a name="l00390"></a>00390     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lTotalSent = 0;
<a name="l00391"></a>00391     <span class="comment">// send all data</span>
<a name="l00392"></a>00392     <span class="keywordflow">while</span>(lTotalSent &lt; inCount) {
<a name="l00393"></a>00393         void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00394"></a>00394         <span class="keywordtype">int</span> lSent = ::sendto(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, inBuffer+lTotalSent, inCount-lTotalSent, 0, (<span class="keyword">struct </span>sockaddr*) &amp;lSock, <span class="keyword">sizeof</span>(lSock));
<a name="l00395"></a>00395         ::signal(SIGPIPE, lPipeMethod);
<a name="l00396"></a>00396         <span class="keywordflow">if</span>(lSent &lt; 0) {
<a name="l00397"></a>00397             <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00398"></a>00398         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lSent &lt; 1) {
<a name="l00399"></a>00399             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00400"></a>00400             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402         lTotalSent += lSent;
<a name="l00403"></a>00403     }
<a name="l00404"></a>00404 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad4435832826f4874ee8b59be84267c75"></a><!-- doxytag: member="PACC::SVG::Canvas::serialize" ref="ad4435832826f4874ee8b59be84267c75" args="(Streamer &amp;outStream, bool inIndent=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XML::Node::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html">XML::Streamer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inIndent</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serialize this node into XML streamer <code>outStream</code>. </p>
<p>Argument <code>inIndent</code> is used to control indentation. By default (<code>inIndent=true</code>), the sub-tree rooted by this node will be serialized with indentation. If <code>inIndent=false</code>, then the node will be serialized without any form of indentation (including line feeds). </p>

<p>Definition at line <a class="el" href="_node_8cpp_source.html#l00469">469</a> of file <a class="el" href="_node_8cpp_source.html">Node.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00470"></a>00470 {
<a name="l00471"></a>00471     <span class="keywordflow">switch</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#abb7445cdb7523a95a35ec8adc38bfed0" title="Type of node.">mType</a>)
<a name="l00472"></a>00472     {
<a name="l00473"></a>00473         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a3af269fb25b96d387de378e0249c4fa9" title="CDATA section (&amp;lt;![CDATA[ ... ]]&amp;gt;).">eCDATA</a>:
<a name="l00474"></a>00474         {
<a name="l00475"></a>00475             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a376b16781253a31bfec62a6ef90411f3" title="Insert CDATA section inCDATA (cannot contain any &amp;quot;]]&amp;gt;&amp;quot; substring).">insertCDATA</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>());
<a name="l00476"></a>00476             <span class="keywordflow">break</span>;
<a name="l00477"></a>00477         }
<a name="l00478"></a>00478         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814aca7d2f335cd554b1c57bc9c0a44cd46d" title="Comment ().">eComment</a>: 
<a name="l00479"></a>00479         {
<a name="l00480"></a>00480             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a57398c80e707d17f9cd9b558c8ff1a03" title="Insert comment inComment (cannot contain any &amp;quot;--&amp;quot; substring).">insertComment</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>());
<a name="l00481"></a>00481             <span class="keywordflow">break</span>;
<a name="l00482"></a>00482         }
<a name="l00483"></a>00483         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a62511869bb50207683e31806b802c576" title="Regular data markup element.">eData</a>:
<a name="l00484"></a>00484         {
<a name="l00485"></a>00485             <span class="comment">// check for tag with single string content</span>
<a name="l00486"></a>00486             ConstIterator lChild = <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#aa47492f75a11e700e53b4e7dcd01a0b0" title="Return an iterator pointing to the first child of this node.">getFirstChild</a>();
<a name="l00487"></a>00487             <span class="keywordflow">if</span>(lChild &amp;&amp; lChild-&gt;mType == <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a02125ab9eed124fe7ff63344f2f3c507" title="Literal string.">eString</a> &amp;&amp; !lChild-&gt;getNextSibling()) {
<a name="l00488"></a>00488                 <span class="comment">// disable indentation</span>
<a name="l00489"></a>00489                 outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#ab7ababa7f01e1864cbb4abe0d0951e20" title="Open new markup tag using name inName.">openTag</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>(), <span class="keyword">false</span>);
<a name="l00490"></a>00490             } <span class="keywordflow">else</span> {
<a name="l00491"></a>00491                 outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#ab7ababa7f01e1864cbb4abe0d0951e20" title="Open new markup tag using name inName.">openTag</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>(), inIndent);
<a name="l00492"></a>00492             }
<a name="l00493"></a>00493             <span class="comment">// serialize attribute list</span>
<a name="l00494"></a>00494             <span class="keywordflow">for</span>(map&lt;string,string&gt;::const_iterator i = begin(); i != end(); ++i) {
<a name="l00495"></a>00495                 <span class="keywordflow">if</span>(i-&gt;first != <span class="stringliteral">&quot;&quot;</span>) outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a3aca8bdecc18f88a8492d1ed1364108f" title="Insert a string attribute with name inName and value inValue into the current start...">insertAttribute</a>(i-&gt;first, i-&gt;second);
<a name="l00496"></a>00496             }
<a name="l00497"></a>00497             <span class="comment">// serialize child nodes</span>
<a name="l00498"></a>00498             <span class="keywordflow">while</span>(lChild) (lChild++)-&gt;<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#ad4435832826f4874ee8b59be84267c75" title="Serialize this node into XML streamer outStream.">serialize</a>(outStream, inIndent);
<a name="l00499"></a>00499             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#aadb172b379622236139be0c95bed55de" title="Close the last opened markup tag.">closeTag</a>();
<a name="l00500"></a>00500             <span class="keywordflow">break</span>;
<a name="l00501"></a>00501         }
<a name="l00502"></a>00502         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a8c37164a8f4d0a8e2271aa763e6b3237" title="Unparsed markup content.">eNoParse</a>:
<a name="l00503"></a>00503         {
<a name="l00504"></a>00504             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a4e6c054f8032d5d03d6614b75656f547" title="Insert string inString as content of current markup.">insertStringContent</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>(), <span class="keyword">false</span>);
<a name="l00505"></a>00505             <span class="keywordflow">break</span>;
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814ac2833f6aa343cf425ab0f4aede27c73f" title="Processing instruction (&amp;lt;? ... ?&amp;gt;).">ePI</a>: 
<a name="l00508"></a>00508         {
<a name="l00509"></a>00509             <span class="keywordtype">string</span> lValue = string(<span class="stringliteral">&quot;&lt;?&quot;</span>) + <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>() + string(<span class="stringliteral">&quot;?&gt;&quot;</span>);
<a name="l00510"></a>00510             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a4e6c054f8032d5d03d6614b75656f547" title="Insert string inString as content of current markup.">insertStringContent</a>(lValue, <span class="keyword">false</span>);
<a name="l00511"></a>00511             <span class="keywordflow">break</span>;
<a name="l00512"></a>00512         }
<a name="l00513"></a>00513         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a4a0d08873453878b747a733b33ee4f81" title="Special element (&amp;lt;! ... &amp;gt;).">eSpecial</a>:
<a name="l00514"></a>00514         {
<a name="l00515"></a>00515             <span class="keywordtype">string</span> lValue = string(<span class="stringliteral">&quot;&lt;!&quot;</span>) + <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>() + string(<span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00516"></a>00516             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a4e6c054f8032d5d03d6614b75656f547" title="Insert string inString as content of current markup.">insertStringContent</a>(lValue, <span class="keyword">false</span>);
<a name="l00517"></a>00517             <span class="keywordflow">break</span>;
<a name="l00518"></a>00518         }
<a name="l00519"></a>00519         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a02125ab9eed124fe7ff63344f2f3c507" title="Literal string.">eString</a>:
<a name="l00520"></a>00520         {
<a name="l00521"></a>00521             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a4e6c054f8032d5d03d6614b75656f547" title="Insert string inString as content of current markup.">insertStringContent</a>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_node.html#acff683537a292b3f8292f0299de53fb5" title="Returns the node value (tag name for NodeType::eData).">getValue</a>(), <span class="keyword">true</span>);
<a name="l00522"></a>00522             <span class="keywordflow">break</span>;
<a name="l00523"></a>00523         }
<a name="l00524"></a>00524         <span class="keywordflow">case</span> <a class="code" href="group___x_m_l.html#ggaee55fe15d14e7ff7da9b834404055814a1349bbd6e6b8571961f80800dc3059eb" title="XML declaration (&amp;lt;?xml ... ?&amp;gt;).">eDecl</a>: 
<a name="l00525"></a>00525         {
<a name="l00526"></a>00526             <span class="keywordtype">string</span> lValue = <span class="stringliteral">&quot;&lt;?xml version=\&quot;&quot;</span>;
<a name="l00527"></a>00527             <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa71362e83a9722288a8e4474aa2b7643" title="Test wheter attribute name inName exists in this list.">isDefined</a>(<span class="stringliteral">&quot;version&quot;</span>)) lValue += <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa329c59996a8338d1097e2d51d598c13" title="Return value of attribute inName, or empty string if it doesn&amp;#39;t exist.">getAttribute</a>(<span class="stringliteral">&quot;version&quot;</span>);
<a name="l00528"></a>00528             <span class="keywordflow">else</span> lValue += <span class="stringliteral">&quot;1.0&quot;</span>;
<a name="l00529"></a>00529             lValue += <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l00530"></a>00530             <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa71362e83a9722288a8e4474aa2b7643" title="Test wheter attribute name inName exists in this list.">isDefined</a>(<span class="stringliteral">&quot;encoding&quot;</span>)) lValue += <span class="stringliteral">&quot; encoding=\&quot;&quot;</span> + <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#aa329c59996a8338d1097e2d51d598c13" title="Return value of attribute inName, or empty string if it doesn&amp;#39;t exist.">getAttribute</a>(<span class="stringliteral">&quot;encoding&quot;</span>) + <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l00531"></a>00531             lValue += <span class="stringliteral">&quot;?&gt;&quot;</span>;
<a name="l00532"></a>00532             outStream.<a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_streamer.html#a4e6c054f8032d5d03d6614b75656f547" title="Insert string inString as content of current markup.">insertStringContent</a>(lValue, <span class="keyword">false</span>);
<a name="l00533"></a>00533             <span class="keywordflow">break</span>;
<a name="l00534"></a>00534         }
<a name="l00535"></a>00535         <span class="keywordflow">default</span>:
<a name="l00536"></a>00536         {
<a name="l00537"></a>00537             <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(<span class="keyword">false</span>, <span class="stringliteral">&quot;Unknown node type!&quot;</span>);
<a name="l00538"></a>00538         }
<a name="l00539"></a>00539     }
<a name="l00540"></a>00540 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a89c3460c2013d6b1fce550a378963693"></a><!-- doxytag: member="PACC::SVG::Canvas::setID" ref="a89c3460c2013d6b1fce550a378963693" args="(const string &amp;inID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVG::Primitive::setID </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>inID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set id of primitive. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inID</em>&nbsp;</td><td>Id of primitive. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_primitives_8cpp_source.html#l00075">75</a> of file <a class="el" href="_primitives_8cpp_source.html">Primitives.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00076"></a>00076 {
<a name="l00077"></a>00077     <a class="code" href="class_p_a_c_c_1_1_x_m_l_1_1_attribute_list.html#a70b83d7d50f2b40eb6656891cf7d8557" title="Set attribute inName to value inValue.">setAttribute</a>(<span class="stringliteral">&quot;id&quot;</span>, inID);
<a name="l00078"></a>00078 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0f8abcce1ad096ea617c88b4d366e367"></a><!-- doxytag: member="PACC::SVG::Canvas::setSockOpt" ref="a0f8abcce1ad096ea617c88b4d366e367" args="(Option inName, double inValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::setSockOpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Option</a>&nbsp;</td>
          <td class="paramname"> <em>inName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set socket option <code>inName</code> to value <code>inValue</code>. </p>
<p>Options are: </p>
<ul>
<li>
eKeepAlive: keep connection alive (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eLinger: time to linger on close (in seconds; <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eNoDelay: Disable the Nagle algorithm for packet coalescing (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eReuseAddress: allow reuse of address </li>
<li>
eRecvBufSize: size of receive buffer (in bytes) </li>
<li>
eSendBufSize: size of send buffer (in bytes) </li>
<li>
eRecvTimeOut: time out period for receive operations (in seconds) </li>
<li>
eSendTimeOut: time out period for send operations (in seconds) </li>
</ul>
<p>Note that for option <code>eLinger</code>, a negative value means don't linger. For options <code>eRecvTimeOut</code> and <code>eSendTimeOut</code>, a negative or nul value means dont't timeout, and a positive value of less than 1 msec will be equivalent to 1 msec. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00420">420</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00421"></a>00421 {
<a name="l00422"></a>00422     <span class="keywordtype">int</span> lBuffer[2] = {0, 0};
<a name="l00423"></a>00423     socklen_t lSize;
<a name="l00424"></a>00424     <span class="keywordflow">switch</span>(inName) {
<a name="l00425"></a>00425         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fad094f0c703765e462059f4c8a92b7292" title="Keep connection alive.">eKeepAlive</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa1839a506c945f06a24ded765b5ece67a" title="Allow reuse of a TCP address without delay.">eReuseAddress</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faf5ee4bfe5d2341a7875edb7ff10ff1c2" title="Size of send buffer (in number of chars).">eSendBufSize</a>:
<a name="l00426"></a>00426             lBuffer[0] = (int) inValue;
<a name="l00427"></a>00427             lSize = <span class="keyword">sizeof</span>(int);
<a name="l00428"></a>00428             <span class="keywordflow">break</span>;
<a name="l00429"></a>00429         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fae0dcf7836a0dbfe6de1d8de7f5c1aa47" title="Time to linger on close (in seconds).">eLinger</a>:
<a name="l00430"></a>00430         {
<a name="l00431"></a>00431             <span class="comment">// warning: the linger structure is not the same size on windows and unix!</span>
<a name="l00432"></a>00432             <span class="keyword">struct </span>linger* lPtr = (<span class="keyword">struct </span>linger*) lBuffer;
<a name="l00433"></a>00433 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span>            lPtr-&gt;l_onoff = (u_short) (inValue &gt;= 0);
<a name="l00435"></a>00435             lPtr-&gt;l_linger = (u_short) (inValue &gt;= 0 ? inValue : 0);
<a name="l00436"></a>00436 <span class="preprocessor">#else</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span>            lPtr-&gt;l_onoff = (int) (inValue &gt;= 0);
<a name="l00438"></a>00438             lPtr-&gt;l_linger = (int) (inValue &gt;= 0 ? inValue : 0);
<a name="l00439"></a>00439 <span class="preprocessor">#endif</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span>        }
<a name="l00441"></a>00441             lSize = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>linger);
<a name="l00442"></a>00442             <span class="keywordflow">break</span>;
<a name="l00443"></a>00443         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">eRecvTimeOut</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">eSendTimeOut</a>:
<a name="l00444"></a>00444             <span class="keywordflow">if</span>(inValue &lt; 0) inValue = 0;
<a name="l00445"></a>00445             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(inValue &gt; 0 &amp;&amp; inValue &lt; 0.001) inValue = 0.001;
<a name="l00446"></a>00446 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span>                <span class="comment">// on windows, timeout must be specified in milliseconds</span>
<a name="l00448"></a>00448                 lBuffer[0] = (int) (1000*inValue);
<a name="l00449"></a>00449             lSize = <span class="keyword">sizeof</span>(int);
<a name="l00450"></a>00450 <span class="preprocessor">#else</span>
<a name="l00451"></a>00451 <span class="preprocessor"></span>            <span class="comment">// on unix, timeout must be specified with timeval structure</span>
<a name="l00452"></a>00452             {
<a name="l00453"></a>00453                 <span class="keyword">struct </span>timeval* lPtr = (<span class="keyword">struct </span>timeval*) lBuffer;
<a name="l00454"></a>00454                 lPtr-&gt;tv_sec = (int32_t) inValue;
<a name="l00455"></a>00455                 lPtr-&gt;tv_usec = (int32_t) ((inValue-lPtr-&gt;tv_sec)*1000000);
<a name="l00456"></a>00456                 lSize = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>timeval);
<a name="l00457"></a>00457             }
<a name="l00458"></a>00458 <span class="preprocessor">#endif</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span>                <span class="keywordflow">break</span>;
<a name="l00460"></a>00460         <span class="keywordflow">default</span>:
<a name="l00461"></a>00461             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::setSockOpt() unsupported socket option&quot;</span>);
<a name="l00462"></a>00462     }
<a name="l00463"></a>00463     <span class="keywordflow">if</span>(::setsockopt(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (inName==<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>?IPPROTO_TCP:SOL_SOCKET), <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a3d153806aea01830530f4ea04c0f338b" title="Convert socket option inName to native socket option code.">convertToNativeOption</a>(inName), (<span class="keywordtype">char</span>*)lBuffer, lSize) != 0)
<a name="l00464"></a>00464     {
<a name="l00465"></a>00465         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::setSockOpt() unable to set socket option&quot;</span>);
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a27ed19ee09dc2503886c071edc813cc8"></a><!-- doxytag: member="PACC::SVG::Canvas::waitForActivity" ref="a27ed19ee09dc2503886c071edc813cc8" args="(double inSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Socket::Port::waitForActivity </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inSeconds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for activity. </p>
<p>This function waits for any socket activity for up to <code>inSeconds</code> seconds. The three types of activities are: ready for read, ready for write, and pending errors. It returns true if an activity is detected before timeout, and false otherwise. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00472">472</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00473"></a>00473 {
<a name="l00474"></a>00474     fd_set lRead, lWrite, lError;
<a name="l00475"></a>00475     FD_ZERO(&amp;lRead);
<a name="l00476"></a>00476     FD_SET(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lRead);
<a name="l00477"></a>00477     FD_ZERO(&amp;lWrite);
<a name="l00478"></a>00478     FD_SET(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lWrite);
<a name="l00479"></a>00479     FD_ZERO(&amp;lError);
<a name="l00480"></a>00480     FD_SET(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lError);
<a name="l00481"></a>00481     <span class="keyword">struct </span>timeval lTime;
<a name="l00482"></a>00482     lTime.tv_sec = (long) inSeconds;
<a name="l00483"></a>00483     lTime.tv_usec = (long) ((inSeconds-lTime.tv_sec)*1000000);
<a name="l00484"></a>00484     <span class="keywordflow">return</span> select(FD_SETSIZE, &amp;lRead, &amp;lWrite, &amp;lError, &amp;lTime) == 1;
<a name="l00485"></a>00485 }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PACC/SVG/<a class="el" href="_canvas_8hpp_source.html">Canvas.hpp</a></li>
<li>PACC/SVG/<a class="el" href="_canvas_8cpp_source.html">Canvas.cpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jan 31 15:10:21 2010 for PACC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
