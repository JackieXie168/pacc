<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PACC: PACC::Threading::SlaveThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_c_c.html">PACC</a>::<a class="el" href="namespace_p_a_c_c_1_1_threading.html">Threading</a>::<a class="el" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html">SlaveThread</a>
  </div>
</div>
<div class="contents">
<h1>PACC::Threading::SlaveThread Class Reference<br/>
<small>
[<a class="el" href="group___threading.html">Threading: portable thread management</a>]</small>
</h1><!-- doxytag: class="PACC::Threading::SlaveThread" --><!-- doxytag: inherits="PACC::Threading::Thread" -->
<p>Slave thread for the portable thread pool.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_thread_pool_8hpp_source.html">ThreadPool.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PACC::Threading::SlaveThread:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_p_a_c_c_1_1_threading_1_1_slave_thread.gif" usemap="#PACC::Threading::SlaveThread_map" alt=""/>
  <map id="PACC::Threading::SlaveThread_map" name="PACC::Threading::SlaveThread_map">
<area href="class_p_a_c_c_1_1_threading_1_1_thread.html" alt="PACC::Threading::Thread" shape="rect" coords="0,112,188,136"/>
<area href="class_p_a_c_c_1_1_threading_1_1_condition.html" alt="PACC::Threading::Condition" shape="rect" coords="0,56,188,80"/>
<area href="class_p_a_c_c_1_1_threading_1_1_mutex.html" alt="PACC::Threading::Mutex" shape="rect" coords="0,0,188,24"/>
</map>
 </div>
</div>

<p><a href="class_p_a_c_c_1_1_threading_1_1_slave_thread-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a417420e2ecb42f9f4bf2269dff7e0797"></a><!-- doxytag: member="PACC::Threading::SlaveThread::SlaveThread" ref="a417420e2ecb42f9f4bf2269dff7e0797" args="(ThreadPool *inPool)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#a417420e2ecb42f9f4bf2269dff7e0797">SlaveThread</a> (<a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread_pool.html">ThreadPool</a> *inPool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a slave thread for a thread pool. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6712fe9a4a8ab8a4af282b246e797cd9"></a><!-- doxytag: member="PACC::Threading::SlaveThread::~SlaveThread" ref="a6712fe9a4a8ab8a4af282b246e797cd9" args="(void)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#a6712fe9a4a8ab8a4af282b246e797cd9">~SlaveThread</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete slave thread; wait for thread termination. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aee017bb71dd63da6f4dc95b7edbc5e53">cancel</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel execution of thread.  <a href="#aee017bb71dd63da6f4dc95b7edbc5e53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a11a768f0e39d46debe24799b569b7181">isRunning</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check wheter or not the thread is currently running.  <a href="#a11a768f0e39d46debe24799b569b7181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abffb7a8b1f0bcf8c71d86130e9a91579"></a><!-- doxytag: member="PACC::Threading::SlaveThread::isSelf" ref="abffb7a8b1f0bcf8c71d86130e9a91579" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#abffb7a8b1f0bcf8c71d86130e9a91579">isSelf</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether the calling thread is the same as this thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ab38b3bdd86b8c1e75f7e9e0d9b4555ea">run</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and startup thread.  <a href="#ab38b3bdd86b8c1e75f7e9e0d9b4555ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946">wait</a> (bool inLock=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for thread termination.  <a href="#ac79a458c34d93c08d4cb5f00dbb09946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a678ef989bf3d6a806907fc2632ad3a60">wait</a> (double inMaxTime=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait up to <code>inMaxTime</code> seconds for the condition to be signaled (or broadcasted).  <a href="#a678ef989bf3d6a806907fc2632ad3a60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a5103716b4853043b7e68a9ace2193a22">broadcast</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broadcast a wake up signal to all waiting threads.  <a href="#a5103716b4853043b7e68a9ace2193a22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#aa1c0ab62547bc517761df1ddcde8faed">signal</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal a single waiting thread to wake up (which waiting thread wakes up is undetermined).  <a href="#aa1c0ab62547bc517761df1ddcde8faed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8">lock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the mutex.  <a href="#a614784b931143e8ccb460e2a4ac9a3e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a831807e017053475f53203505168548d">tryLock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to lock the mutex without blocking.  <a href="#a831807e017053475f53203505168548d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d">unlock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the mutex.  <a href="#ac56644852bc8f3afa80372491045955d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a7fdc459d74d538dba730d2c09cb56dda">sleep</a> (double inSeconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sleep calling thread for <code>inSeconds</code> seconds.  <a href="#a7fdc459d74d538dba730d2c09cb56dda"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#ab32671f2aaaa7c270b84281051679014">main</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a pending task.  <a href="#ab32671f2aaaa7c270b84281051679014"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a74093833bc523c83dea2d62981cc5a39">makeCancellationPoint</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create cancellation point.  <a href="#a74093833bc523c83dea2d62981cc5a39"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59990b7ca32164428ccccac6f55a9d5b"></a><!-- doxytag: member="PACC::Threading::SlaveThread::mPool" ref="a59990b7ca32164428ccccac6f55a9d5b" args="" -->
<a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread_pool.html">ThreadPool</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#a59990b7ca32164428ccccac6f55a9d5b">mPool</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to parent thread pool. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa16693f58797d092bc80001039b2f040"></a><!-- doxytag: member="PACC::Threading::SlaveThread::mThread" ref="aa16693f58797d092bc80001039b2f040" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040">mThread</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e3d695ada216ddcc42d433f4606e349"></a><!-- doxytag: member="PACC::Threading::SlaveThread::mCancel" ref="a0e3d695ada216ddcc42d433f4606e349" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349">mCancel</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should be canceled flag. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9788ffad4188072b492cf13bdf722f62"></a><!-- doxytag: member="PACC::Threading::SlaveThread::mRunning" ref="a9788ffad4188072b492cf13bdf722f62" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62">mRunning</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is running flag. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a522f03215ec1b3dc7e49f14da402f21b"></a><!-- doxytag: member="PACC::Threading::SlaveThread::mCondition" ref="a522f03215ec1b3dc7e49f14da402f21b" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b">mCondition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native condition. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a3148fa4affbe20e96b7f0593c06e89"></a><!-- doxytag: member="PACC::Threading::SlaveThread::mMutex" ref="a6a3148fa4affbe20e96b7f0593c06e89" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89">mMutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native mutex. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Slave thread for the portable thread pool. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Marc Parizeau, Laboratoire de vision et syst&egrave;mes num&eacute;riques, Universit&eacute; Laval</dd></dl>
<p>This class defines a specialized thread for executing thread pool tasks. A slave thread simply sleeps until awakened by its parent thread pool when the later needs to execute a pending <a class="el" href="class_p_a_c_c_1_1_threading_1_1_task.html" title="Task for thread pool execution.">Task</a> (see <a class="el" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#ab32671f2aaaa7c270b84281051679014" title="Execute a pending task.">SlaveThread::main</a> for more details). </p>

<p>Definition at line <a class="el" href="_thread_pool_8hpp_source.html#l00058">58</a> of file <a class="el" href="_thread_pool_8hpp_source.html">ThreadPool.hpp</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5103716b4853043b7e68a9ace2193a22"></a><!-- doxytag: member="PACC::Threading::SlaveThread::broadcast" ref="a5103716b4853043b7e68a9ace2193a22" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Condition::broadcast </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Broadcast a wake up signal to all waiting threads. </p>
<p>This method assumes that the embedded mutex has already been LOCKED by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>). It allows the caller to execute some thread critical operations like setting an external condition prior to broadcasting. If no thread is waiting, the signal is simply ignored. Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">lCondition.lock();
<span class="comment">// set some external condition</span>
...
lCondition.broadcast();
lCondition.unlock();
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00113">113</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00114"></a>00114 {
<a name="l00115"></a>00115     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00116"></a>00116 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00118"></a>00118     <span class="keywordflow">if</span>(lCondition-&gt;mWaiters &gt; 0) {
<a name="l00119"></a>00119         lCondition-&gt;mBroadcast = <span class="keyword">true</span>;
<a name="l00120"></a>00120         <span class="comment">// wake up the waiting threads atomically</span>
<a name="l00121"></a>00121         <span class="keywordflow">if</span>(!::ReleaseSemaphore(lCondition-&gt;mSemaphore, lCondition-&gt;mWaiters, 0)) {
<a name="l00122"></a>00122             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00123"></a>00123             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() unable to release semaphore!&quot;</span>);
<a name="l00124"></a>00124         }
<a name="l00125"></a>00125         <span class="comment">// wait for threads to acquire the counting semaphore</span>
<a name="l00126"></a>00126         LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00127"></a>00127         <span class="keywordflow">if</span>(::WaitForSingleObject(lCondition-&gt;mDone, INFINITE) != WAIT_OBJECT_0) {
<a name="l00128"></a>00128             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00129"></a>00129             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() invalid event!&quot;</span>);
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131         lCondition-&gt;mBroadcast = <span class="keyword">false</span>;
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133     <span class="keywordflow">else</span> LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00134"></a>00134 <span class="preprocessor">#else</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::pthread_cond_broadcast(lCondition) != 0) {
<a name="l00136"></a>00136         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00137"></a>00137         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() invalid condition!&quot;</span>);
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139 <span class="preprocessor">#endif</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="aee017bb71dd63da6f4dc95b7edbc5e53"></a><!-- doxytag: member="PACC::Threading::SlaveThread::cancel" ref="aee017bb71dd63da6f4dc95b7edbc5e53" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Thread::cancel </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel execution of thread. </p>
<p>The cancellation process requested by this function runs asynchronously with the calling thread. The latter can call function <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946" title="Wait for thread termination.">Thread::wait</a> in order to wait for thread termination. The cancelled thread will not terminate before it reaches its next cancellation point, or before it terminates by itself. Before deleting a cancelled thread, the caller should always wait for thread termination.</p>
<p>The caller should always lock the thread (using the lock method) prior to asking for cancellation. If it wishes to wait immediately for thread termination, it should keep the thread locked and call the wait method with argument false (see <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946" title="Wait for thread termination.">Thread::wait</a>). </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00111">111</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00112"></a>00112 {
<a name="l00113"></a>00113     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349" title="Should be canceled flag.">mCancel</a> = <span class="keyword">true</span>;
<a name="l00114"></a>00114 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a11a768f0e39d46debe24799b569b7181"></a><!-- doxytag: member="PACC::Threading::SlaveThread::isRunning" ref="a11a768f0e39d46debe24799b569b7181" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Thread::isRunning </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check wheter or not the thread is currently running. </p>
<p>The caller should always lock the thread (using the lock method) prior to checking the running flag. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00120">120</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00121"></a>00121 {
<a name="l00122"></a>00122     <span class="keywordflow">return</span> <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a>;
<a name="l00123"></a>00123 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a614784b931143e8ccb460e2a4ac9a3e8"></a><!-- doxytag: member="PACC::Threading::SlaveThread::lock" ref="a614784b931143e8ccb460e2a4ac9a3e8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Mutex::lock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock the mutex. </p>
<p>A thread should never lock a mutex twice consecutively (without calling method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">Mutex::unlock</a>). Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00087">87</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00088"></a>00088 {
<a name="l00089"></a>00089     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00090"></a>00090 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::WaitForSingleObject(*lMutex, INFINITE) != WAIT_OBJECT_0)
<a name="l00092"></a>00092 #<span class="keywordflow">else</span>
<a name="l00093"></a>00093         <span class="keywordflow">if</span>(::pthread_mutex_lock(lMutex) != 0) 
<a name="l00094"></a>00094 #endif
<a name="l00095"></a>00095             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afba3c013a24ae9803571dbbe6651fc65a7a" title="Operation would produce a dead lock.">eWouldDeadLock</a>, <span class="stringliteral">&quot;Mutex::lock() can&apos;t lock!&quot;</span>);
<a name="l00096"></a>00096 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab32671f2aaaa7c270b84281051679014"></a><!-- doxytag: member="PACC::Threading::SlaveThread::main" ref="ab32671f2aaaa7c270b84281051679014" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::SlaveThread::main </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute a pending task. </p>
<p>When awakened by its parent thread pool, this method removes the next task from the head of the queue and starts executing it immediately. It also broadcasts a signal to all waiting threads for this task, both prior to task execution and after task completion. </p>

<p>Implements <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a92d700d8f73300ea118e0bbcf4f57f21">PACC::Threading::Thread</a>.</p>

<p>Definition at line <a class="el" href="_thread_pool_8cpp_source.html#l00046">46</a> of file <a class="el" href="_thread_pool_8cpp_source.html">ThreadPool.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00047"></a>00047 {
<a name="l00048"></a>00048     <span class="keywordflow">while</span>(!<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349" title="Should be canceled flag.">mCancel</a>)
<a name="l00049"></a>00049     {
<a name="l00050"></a>00050         <span class="comment">// wait for available task</span>
<a name="l00051"></a>00051         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#a59990b7ca32164428ccccac6f55a9d5b" title="Pointer to parent thread pool.">mPool</a>-&gt;lock();
<a name="l00052"></a>00052         <span class="keywordflow">while</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#a59990b7ca32164428ccccac6f55a9d5b" title="Pointer to parent thread pool.">mPool</a>-&gt;mTasks.empty() &amp;&amp; !<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349" title="Should be canceled flag.">mCancel</a>) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#a59990b7ca32164428ccccac6f55a9d5b" title="Pointer to parent thread pool.">mPool</a>-&gt;wait();
<a name="l00053"></a>00053         <span class="keywordflow">if</span>(!<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349" title="Should be canceled flag.">mCancel</a>)
<a name="l00054"></a>00054         {
<a name="l00055"></a>00055             <span class="comment">// dequeu next task</span>
<a name="l00056"></a>00056             Task* lTask = <a class="code" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#a59990b7ca32164428ccccac6f55a9d5b" title="Pointer to parent thread pool.">mPool</a>-&gt;mTasks.front();
<a name="l00057"></a>00057             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#a59990b7ca32164428ccccac6f55a9d5b" title="Pointer to parent thread pool.">mPool</a>-&gt;mTasks.pop();
<a name="l00058"></a>00058             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#a59990b7ca32164428ccccac6f55a9d5b" title="Pointer to parent thread pool.">mPool</a>-&gt;unlock();
<a name="l00059"></a>00059             <span class="comment">// signal all that task is running</span>
<a name="l00060"></a>00060             lTask-&gt;lock();
<a name="l00061"></a>00061             lTask-&gt;mRunning = <span class="keyword">true</span>;
<a name="l00062"></a>00062             lTask-&gt;broadcast();
<a name="l00063"></a>00063             lTask-&gt;unlock();
<a name="l00064"></a>00064             <span class="comment">// run task</span>
<a name="l00065"></a>00065             lTask-&gt;main();
<a name="l00066"></a>00066             <span class="comment">// signal all that task is completed</span>
<a name="l00067"></a>00067             lTask-&gt;lock();
<a name="l00068"></a>00068             lTask-&gt;mRunning = <span class="keyword">false</span>;
<a name="l00069"></a>00069             lTask-&gt;mCompleted = <span class="keyword">true</span>;
<a name="l00070"></a>00070             lTask-&gt;broadcast();
<a name="l00071"></a>00071             lTask-&gt;unlock();
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073         <span class="keywordflow">else</span> <a class="code" href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html#a59990b7ca32164428ccccac6f55a9d5b" title="Pointer to parent thread pool.">mPool</a>-&gt;unlock();
<a name="l00074"></a>00074     }
<a name="l00075"></a>00075 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a74093833bc523c83dea2d62981cc5a39"></a><!-- doxytag: member="PACC::Threading::SlaveThread::makeCancellationPoint" ref="a74093833bc523c83dea2d62981cc5a39" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Thread::makeCancellationPoint </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create cancellation point. </p>
<p>This function should be called by <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a92d700d8f73300ea118e0bbcf4f57f21" title="Implements main procedure of thread.">Thread::main</a> as often as possible in order to enable thread cancellation. A <a class="el" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aee017bb71dd63da6f4dc95b7edbc5e53" title="Cancel execution of thread.">Thread::cancel</a> request can only be honored at a future cancellation point. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00145">145</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00146"></a>00146 {
<a name="l00147"></a>00147     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">lock</a>();
<a name="l00148"></a>00148     <span class="comment">// exit thread if cancellation was requested</span>
<a name="l00149"></a>00149     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349" title="Should be canceled flag.">mCancel</a>) {
<a name="l00150"></a>00150         <span class="comment">// signal all that thread has terminated</span>
<a name="l00151"></a>00151         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a> = <span class="keyword">false</span>;
<a name="l00152"></a>00152         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a5103716b4853043b7e68a9ace2193a22" title="Broadcast a wake up signal to all waiting threads.">broadcast</a>();
<a name="l00153"></a>00153         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00154"></a>00154         <span class="comment">// now exit thread</span>
<a name="l00155"></a>00155 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span>        ::ExitThread(0);
<a name="l00157"></a>00157 <span class="preprocessor">#else // Unix...</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span>        ::pthread_exit(0);
<a name="l00159"></a>00159 <span class="preprocessor">#endif</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>    }
<a name="l00161"></a>00161     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00162"></a>00162 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab38b3bdd86b8c1e75f7e9e0d9b4555ea"></a><!-- doxytag: member="PACC::Threading::SlaveThread::run" ref="ab38b3bdd86b8c1e75f7e9e0d9b4555ea" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Thread::run </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create and startup thread. </p>
<p>This function allocates memory for the native thread structure, and then creates the thread which starts up asynchronously. The calling thread will block until this thread as actually started to run.</p>
<p>Any error will raise a <a class="el" href="namespace_p_a_c_c_1_1_threading.html" title="Portable thread management classes.">Threading</a>:<a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Exception</a>. In particular, this method should not be called if the thread is already running. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00170">170</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00171"></a>00171 {
<a name="l00172"></a>00172     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">lock</a>();
<a name="l00173"></a>00173     <span class="comment">// check that thread is not already running</span>
<a name="l00174"></a>00174     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a>) {
<a name="l00175"></a>00175         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00176"></a>00176         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afba655cedbfb54eefdb53c332bb56511968" title="Thread is already running.">eRunning</a>, <span class="stringliteral">&quot;Thread::run() thread is already running!&quot;</span>);
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a0e3d695ada216ddcc42d433f4606e349" title="Should be canceled flag.">mCancel</a> = <span class="keyword">false</span>;
<a name="l00179"></a>00179     <span class="comment">// allocate native structure</span>
<a name="l00180"></a>00180     <span class="keywordflow">if</span>(!<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040" title="Opaque structure of native thread.">mThread</a>) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040" title="Opaque structure of native thread.">mThread</a> = <span class="keyword">new</span> ThreadStruct;
<a name="l00181"></a>00181     ThreadStruct* lThread = (ThreadStruct*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#aa16693f58797d092bc80001039b2f040" title="Opaque structure of native thread.">mThread</a>;
<a name="l00182"></a>00182     <span class="comment">// create thread</span>
<a name="l00183"></a>00183 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>    <span class="keywordflow">if</span>((lThread-&gt;mHandle = ::CreateThread(0, 0, (LPTHREAD_START_ROUTINE)startup, <span class="keyword">this</span>, 0, &amp;lThread-&gt;mId)) == 0)
<a name="l00185"></a>00185 #<span class="keywordflow">else</span> <span class="comment">// Unix</span>
<a name="l00186"></a>00186     <span class="keywordflow">if</span>(::pthread_create(lThread, 0, startup, <span class="keyword">this</span>) != 0)  
<a name="l00187"></a>00187 #endif
<a name="l00188"></a>00188     {
<a name="l00189"></a>00189         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00190"></a>00190         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Thread::run() can&apos;t create thread!&quot;</span>);
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192     <span class="comment">// wait for thread to start up</span>
<a name="l00193"></a>00193     <span class="keywordflow">if</span>(!<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a>) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946" title="Wait for thread termination.">Condition::wait</a>();
<a name="l00194"></a>00194     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00195"></a>00195 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa1c0ab62547bc517761df1ddcde8faed"></a><!-- doxytag: member="PACC::Threading::SlaveThread::signal" ref="aa1c0ab62547bc517761df1ddcde8faed" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Condition::signal </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal a single waiting thread to wake up (which waiting thread wakes up is undetermined). </p>
<p>This method assumes that the embedded mutex has already been locked by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>). It allows the caller to execute some thread critical operations, like setting or resetting external conditions. If no thread is waiting, the signal is simply ignored. Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">lCondition.lock();
<span class="comment">// set some external condition</span>
...
lCondition.signal();
lCondition.unlock();
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00156">156</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00157"></a>00157 {
<a name="l00158"></a>00158     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00159"></a>00159 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00161"></a>00161     <span class="keywordtype">int</span> lWaiters = lCondition-&gt;mWaiters;
<a name="l00162"></a>00162     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00163"></a>00163     <span class="comment">// wake up a single waiting thread if any waiters</span>
<a name="l00164"></a>00164     <span class="keywordflow">if</span>(lWaiters &gt; 0 &amp;&amp; ::ReleaseSemaphore(lCondition-&gt;mSemaphore, 1, 0) == 0)
<a name="l00165"></a>00165 <span class="preprocessor">#else</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(::pthread_cond_signal(lCondition) != 0)
<a name="l00167"></a>00167 <span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>        {
<a name="l00169"></a>00169             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00170"></a>00170             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::signal() invalid condition!&quot;</span>);
<a name="l00171"></a>00171         }
<a name="l00172"></a>00172 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7fdc459d74d538dba730d2c09cb56dda"></a><!-- doxytag: member="PACC::Threading::SlaveThread::sleep" ref="a7fdc459d74d538dba730d2c09cb56dda" args="(double inSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Thread::sleep </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inSeconds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sleep calling thread for <code>inSeconds</code> seconds. </p>
<p>A negative value will throw a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00201">201</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00202"></a>00202 {
<a name="l00203"></a>00203     <span class="keywordflow">if</span>(inSeconds &lt; 0) <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Thread::sleep() invalid time&quot;</span>);
<a name="l00204"></a>00204 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span>    <span class="comment">// argument must be in milliseconds for windows</span>
<a name="l00206"></a>00206     ::Sleep((DWORD)(1000*inSeconds));
<a name="l00207"></a>00207 <span class="preprocessor">#else // Unix...</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(inSeconds &lt; 1000) {
<a name="l00209"></a>00209         <span class="comment">// use microsecond sleep</span>
<a name="l00210"></a>00210         <span class="keywordflow">if</span>(::usleep((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(1000000*inSeconds)) != 0) {
<a name="l00211"></a>00211             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Thread::sleep() can&apos;t sleep&quot;</span>);
<a name="l00212"></a>00212         }
<a name="l00213"></a>00213     } <span class="keywordflow">else</span> {
<a name="l00214"></a>00214         <span class="comment">// use regular sleep</span>
<a name="l00215"></a>00215         <span class="keywordflow">if</span>(::<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a7fdc459d74d538dba730d2c09cb56dda" title="Sleep calling thread for inSeconds seconds.">sleep</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(inSeconds)) != 0) {
<a name="l00216"></a>00216             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Thread::sleep() can&apos;t sleep&quot;</span>);
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219 <span class="preprocessor">#endif</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a831807e017053475f53203505168548d"></a><!-- doxytag: member="PACC::Threading::SlaveThread::tryLock" ref="a831807e017053475f53203505168548d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Mutex::tryLock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to lock the mutex without blocking. </p>
<p>Return's true if successful; false otherwise.</p>
<p>Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00104">104</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00105"></a>00105 {
<a name="l00106"></a>00106     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00107"></a>00107 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>    <span class="keywordtype">int</span> lValue = ::WaitForSingleObject(*lMutex, 0);
<a name="l00109"></a>00109     <span class="keywordflow">if</span>(lValue == WAIT_TIMEOUT) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00110"></a>00110     <span class="keywordflow">if</span>(lValue != WAIT_OBJECT_0)
<a name="l00111"></a>00111 <span class="preprocessor">#else</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>        <span class="keywordtype">int</span> lValue = ::pthread_mutex_trylock(lMutex);
<a name="l00113"></a>00113     <span class="keywordflow">if</span>(lValue == EBUSY) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00114"></a>00114     <span class="keywordflow">if</span>(lValue != 0) 
<a name="l00115"></a>00115 <span class="preprocessor">#endif</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>        <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Mutex::trylock() can&apos;t trylock!&quot;</span>);
<a name="l00117"></a>00117     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00118"></a>00118 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac56644852bc8f3afa80372491045955d"></a><!-- doxytag: member="PACC::Threading::SlaveThread::unlock" ref="ac56644852bc8f3afa80372491045955d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Mutex::unlock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the mutex. </p>
<p>A thread should never unlock a mutex twice consecutively (without calling method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Mutex::lock</a>). Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00125">125</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00126"></a>00126 {
<a name="l00127"></a>00127     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00128"></a>00128 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::ReleaseMutex(*lMutex) == 0)
<a name="l00130"></a>00130 #<span class="keywordflow">else</span>
<a name="l00131"></a>00131         <span class="keywordflow">if</span>(::pthread_mutex_unlock(lMutex) != 0)
<a name="l00132"></a>00132 #endif
<a name="l00133"></a>00133             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afba158cbdf072ad8c387b006134f3d32e75" title="Mutex not own by calling thread.">eMutexNotOwned</a>, <span class="stringliteral">&quot;Mutex::unlock() can&apos;t unlock!&quot;</span>);
<a name="l00134"></a>00134 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a678ef989bf3d6a806907fc2632ad3a60"></a><!-- doxytag: member="PACC::Threading::SlaveThread::wait" ref="a678ef989bf3d6a806907fc2632ad3a60" args="(double inMaxTime=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Condition::wait </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inMaxTime</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait up to <code>inMaxTime</code> seconds for the condition to be signaled (or broadcasted). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if condition was signaled (or broadcasted), false if timed out.</dd></dl>
<p>This method assumes that the embedded mutex has already been locked by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>), and will also return with the mutex locked. A negative or null time out (default) means that the method should wait indefinitely.</p>
<p>Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">...
lCondition.lock();
<span class="keywordflow">if</span>(external_condition == <span class="keyword">false</span>) {
    <span class="comment">// wait indefinitely...</span>
    lCondition.wait();
    <span class="comment">// reset external condition</span>
    ...
}
lCondition.unlock();
...
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00196">196</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00197"></a>00197 {
<a name="l00198"></a>00198     <span class="keywordtype">bool</span> lReturn;
<a name="l00199"></a>00199     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00200"></a>00200 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00202"></a>00202     <span class="comment">// increment number of waiters</span>
<a name="l00203"></a>00203     lCondition-&gt;mWaiters += 1;
<a name="l00204"></a>00204     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00205"></a>00205     <span class="comment">// wait for the semaphore after atomically unlocking the mutex</span>
<a name="l00206"></a>00206     HANDLE* lMutex = (HANDLE*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00207"></a>00207     DWORD lRes = ::SignalObjectAndWait(*lMutex, lCondition-&gt;mSemaphore, (inMaxTime &lt;= 0 ? INFINITE : (DWORD)(inMaxTime*1000)), <span class="keyword">false</span>);
<a name="l00208"></a>00208     <span class="keywordflow">if</span>((lReturn = (lRes != WAIT_TIMEOUT)) &amp;&amp; lRes != WAIT_OBJECT_0) {
<a name="l00209"></a>00209         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00210"></a>00210         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid semaphore!&quot;</span>);
<a name="l00211"></a>00211     }   
<a name="l00212"></a>00212     EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00213"></a>00213     <span class="comment">// we&apos;re no longer waiting, decrement number of waiters</span>
<a name="l00214"></a>00214     lCondition-&gt;mWaiters -= 1;
<a name="l00215"></a>00215     <span class="keywordtype">bool</span> lLastWaiter = lCondition-&gt;mBroadcast &amp;&amp; lCondition-&gt;mWaiters == 0;
<a name="l00216"></a>00216     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00217"></a>00217     <span class="keywordflow">if</span>(lLastWaiter) {
<a name="l00218"></a>00218         <span class="comment">// wait for the mutex after atomically signaling the broadcaster that all threads have awakened</span>
<a name="l00219"></a>00219         <span class="keywordflow">if</span>(::SignalObjectAndWait(lCondition-&gt;mDone, *lMutex, INFINITE, <span class="keyword">false</span>) != WAIT_OBJECT_0)
<a name="l00220"></a>00220         {
<a name="l00221"></a>00221             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00222"></a>00222             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid mutex!&quot;</span>);
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(::WaitForSingleObject(*lMutex, INFINITE) != WAIT_OBJECT_0) {
<a name="l00226"></a>00226         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00227"></a>00227         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid mutex!&quot;</span>);
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 <span class="preprocessor">#else</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span>    <span class="keywordtype">int</span> lRes;
<a name="l00231"></a>00231     <span class="comment">// pthread_cond_wait atomically unlocks the mutex, waits on the condition, and locks the mutex again</span>
<a name="l00232"></a>00232     <span class="keywordflow">if</span>(inMaxTime &lt;= 0) lRes = ::pthread_cond_wait(lCondition, (pthread_mutex_t*)<a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>);
<a name="l00233"></a>00233     <span class="keywordflow">else</span> {
<a name="l00234"></a>00234         <span class="comment">// get time of day and add specified time out</span>
<a name="l00235"></a>00235         <span class="keyword">struct </span>timeval lVal;
<a name="l00236"></a>00236         ::gettimeofday(&amp;lVal, 0);
<a name="l00237"></a>00237         <span class="keyword">struct </span>timespec lSpec;
<a name="l00238"></a>00238         lSpec.tv_sec = lVal.tv_sec + (long) inMaxTime;
<a name="l00239"></a>00239         lSpec.tv_nsec = lVal.tv_usec*1000 + (long) ((inMaxTime - floor(inMaxTime)) * 1000000000);
<a name="l00240"></a>00240         <span class="comment">// check that the number of nanoseconds is less than 1 sec</span>
<a name="l00241"></a>00241         <span class="keywordflow">if</span>(lSpec.tv_nsec &gt;= 1000000000)
<a name="l00242"></a>00242         {
<a name="l00243"></a>00243             <span class="comment">// otherwise adjust...</span>
<a name="l00244"></a>00244             lSpec.tv_nsec -= 1000000000;
<a name="l00245"></a>00245             lSpec.tv_sec += 1;
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247         <span class="comment">// pthread_cond_timedwait atomically unlocks the mutex, waits on the condition, and locks the mutex again</span>
<a name="l00248"></a>00248         lRes = ::pthread_cond_timedwait(lCondition, (pthread_mutex_t*)<a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>, &amp;lSpec);
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250     <span class="keywordflow">if</span>((lReturn = (lRes != ETIMEDOUT)) &amp;&amp; lRes != 0)
<a name="l00251"></a>00251     {
<a name="l00252"></a>00252         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00253"></a>00253         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid condition!&quot;</span>);
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255 <span class="preprocessor">#endif</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span>    <span class="keywordflow">return</span> lReturn;
<a name="l00257"></a>00257 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac79a458c34d93c08d4cb5f00dbb09946"></a><!-- doxytag: member="PACC::Threading::SlaveThread::wait" ref="ac79a458c34d93c08d4cb5f00dbb09946" args="(bool inLock=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Thread::wait </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inLock</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for thread termination. </p>
<p>This method will wait for thread termination. If argument <code>inLock</code> is true (default), it will first lock the thread mutex before checking wheter or not the thread is still running. If the thread has already terminated, it will promptly return after unlocking the mutex. Otherwise, it will wait for the thread to terminate by itself.</p>
<p>If argument <code>inLock</code> is false, this method assumes that the caller has already locked the mutex (using <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Thread::lock</a>) and is responsible for unlocking it. </p>

<p>Definition at line <a class="el" href="_thread_8cpp_source.html#l00250">250</a> of file <a class="el" href="_thread_8cpp_source.html">Thread.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00251"></a>00251 {
<a name="l00252"></a>00252     <span class="keywordflow">if</span>(inLock) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">lock</a>();
<a name="l00253"></a>00253     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#a9788ffad4188072b492cf13bdf722f62" title="Is running flag.">mRunning</a>) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_thread.html#ac79a458c34d93c08d4cb5f00dbb09946" title="Wait for thread termination.">Condition::wait</a>();
<a name="l00254"></a>00254     <span class="keywordflow">if</span>(inLock) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00255"></a>00255 }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PACC/Threading/<a class="el" href="_thread_pool_8hpp_source.html">ThreadPool.hpp</a></li>
<li>PACC/Threading/<a class="el" href="_thread_pool_8cpp_source.html">ThreadPool.cpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jan 31 15:10:22 2010 for PACC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
