<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PACC: PACC::Threading::Semaphore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_c_c.html">PACC</a>::<a class="el" href="namespace_p_a_c_c_1_1_threading.html">Threading</a>::<a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html">Semaphore</a>
  </div>
</div>
<div class="contents">
<h1>PACC::Threading::Semaphore Class Reference<br/>
<small>
[<a class="el" href="group___threading.html">Threading: portable thread management</a>]</small>
</h1><!-- doxytag: class="PACC::Threading::Semaphore" --><!-- doxytag: inherits="PACC::Threading::Condition" -->
<p>Semaphore for thread synchronization.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_semaphore_8hpp_source.html">Semaphore.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PACC::Threading::Semaphore:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_p_a_c_c_1_1_threading_1_1_semaphore.gif" usemap="#PACC::Threading::Semaphore_map" alt=""/>
  <map id="PACC::Threading::Semaphore_map" name="PACC::Threading::Semaphore_map">
<area href="class_p_a_c_c_1_1_threading_1_1_condition.html" alt="PACC::Threading::Condition" shape="rect" coords="0,56,180,80"/>
<area href="class_p_a_c_c_1_1_threading_1_1_mutex.html" alt="PACC::Threading::Mutex" shape="rect" coords="0,0,180,24"/>
</map>
 </div>
</div>

<p><a href="class_p_a_c_c_1_1_threading_1_1_semaphore-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac71b8a754961b37960a3a884715b1941"></a><!-- doxytag: member="PACC::Threading::Semaphore::Semaphore" ref="ac71b8a754961b37960a3a884715b1941" args="(unsigned int inCount=0)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#ac71b8a754961b37960a3a884715b1941">Semaphore</a> (unsigned int inCount=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct semaphore with initial count <code>inCount</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2117d3d8ea874de21ebdf6fb4ab058e"></a><!-- doxytag: member="PACC::Threading::Semaphore::getCount" ref="aa2117d3d8ea874de21ebdf6fb4ab058e" args="(void) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#aa2117d3d8ea874de21ebdf6fb4ab058e">getCount</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return count of semaphore (semaphore should be locked prior to call). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a22ffcceb8afd379ce4dcd770886a7035">post</a> (bool inLock=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post a signal that another ressource is now avalable.  <a href="#a22ffcceb8afd379ce4dcd770886a7035"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a0c8ddfabe9cba2bd444025fcdb6c37"></a><!-- doxytag: member="PACC::Threading::Semaphore::setCount" ref="a5a0c8ddfabe9cba2bd444025fcdb6c37" args="(unsigned int inCount)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a5a0c8ddfabe9cba2bd444025fcdb6c37">setCount</a> (unsigned int inCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set count of semaphore (semaphore should be locked prior to call). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a9e3396aa2781369236282c5ddd64a74f">tryWait</a> (bool inLock=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to acquire one ressource, but don't block if ressources are exhausted.  <a href="#a9e3396aa2781369236282c5ddd64a74f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a62a41b45070c058cd98fc13fb78a3581">wait</a> (double inMaxTime=0, bool inLock=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait up to <code>inMaxTime</code> seconds to acquire one resource.  <a href="#a62a41b45070c058cd98fc13fb78a3581"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a5103716b4853043b7e68a9ace2193a22">broadcast</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broadcast a wake up signal to all waiting threads.  <a href="#a5103716b4853043b7e68a9ace2193a22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#aa1c0ab62547bc517761df1ddcde8faed">signal</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal a single waiting thread to wake up (which waiting thread wakes up is undetermined).  <a href="#aa1c0ab62547bc517761df1ddcde8faed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a678ef989bf3d6a806907fc2632ad3a60">wait</a> (double inMaxTime=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait up to <code>inMaxTime</code> seconds for the condition to be signaled (or broadcasted).  <a href="#a678ef989bf3d6a806907fc2632ad3a60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8">lock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the mutex.  <a href="#a614784b931143e8ccb460e2a4ac9a3e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a831807e017053475f53203505168548d">tryLock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to lock the mutex without blocking.  <a href="#a831807e017053475f53203505168548d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d">unlock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the mutex.  <a href="#ac56644852bc8f3afa80372491045955d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a3671f1b105232d67f54bde542fd5ad"></a><!-- doxytag: member="PACC::Threading::Semaphore::mCount" ref="a6a3671f1b105232d67f54bde542fd5ad" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a6a3671f1b105232d67f54bde542fd5ad">mCount</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current count of semaphore. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a7ad0559da2413fbad467b3cfe75c61"></a><!-- doxytag: member="PACC::Threading::Semaphore::mWaiters" ref="a2a7ad0559da2413fbad467b3cfe75c61" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a2a7ad0559da2413fbad467b3cfe75c61">mWaiters</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current number of waiting threads. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a522f03215ec1b3dc7e49f14da402f21b"></a><!-- doxytag: member="PACC::Threading::Semaphore::mCondition" ref="a522f03215ec1b3dc7e49f14da402f21b" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b">mCondition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native condition. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a3148fa4affbe20e96b7f0593c06e89"></a><!-- doxytag: member="PACC::Threading::Semaphore::mMutex" ref="a6a3148fa4affbe20e96b7f0593c06e89" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89">mMutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native mutex. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Semaphore for thread synchronization. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Marc Parizeau, Laboratoire de vision et syst&egrave;mes num&eacute;riques, Universit&eacute; Laval</dd></dl>
<p>This class incapsulates a counting semaphore with classic <a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a22ffcceb8afd379ce4dcd770886a7035" title="Post a signal that another ressource is now avalable.">Semaphore::post</a>, <a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a9e3396aa2781369236282c5ddd64a74f" title="Try to acquire one ressource, but don&#39;t block if ressources are exhausted.">Semaphore::tryWait</a>, and <a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a62a41b45070c058cd98fc13fb78a3581" title="Wait up to inMaxTime seconds to acquire one resource.">Semaphore::wait</a> methods. The semaphore is initialized with a count of <code>inCount</code> ressources (see constructor). A post increments the count while a wait decrements it. A count of 0 means that no more ressources are available. Subsequent calls to wait will block until future post releases some of the allocated ressources. When several threads have blocked because of exhausted ressources, the order in which they will be released is undetermined (FIFO should not be assumed).</p>
<p>This class does not contain any OS dependant code. However, it is built over classes <a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html" title="Condition for thread synchronization.">Condition</a> and <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html" title="Mutual exclusion for thread synchronization.">Mutex</a> which may not be fully cross-platform (see documentation of these classes for more details). </p>

<p>Definition at line <a class="el" href="_semaphore_8hpp_source.html#l00054">54</a> of file <a class="el" href="_semaphore_8hpp_source.html">Semaphore.hpp</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5103716b4853043b7e68a9ace2193a22"></a><!-- doxytag: member="PACC::Threading::Semaphore::broadcast" ref="a5103716b4853043b7e68a9ace2193a22" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Condition::broadcast </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Broadcast a wake up signal to all waiting threads. </p>
<p>This method assumes that the embedded mutex has already been LOCKED by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>). It allows the caller to execute some thread critical operations like setting an external condition prior to broadcasting. If no thread is waiting, the signal is simply ignored. Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">lCondition.lock();
<span class="comment">// set some external condition</span>
...
lCondition.broadcast();
lCondition.unlock();
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00113">113</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00114"></a>00114 {
<a name="l00115"></a>00115     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00116"></a>00116 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00118"></a>00118     <span class="keywordflow">if</span>(lCondition-&gt;mWaiters &gt; 0) {
<a name="l00119"></a>00119         lCondition-&gt;mBroadcast = <span class="keyword">true</span>;
<a name="l00120"></a>00120         <span class="comment">// wake up the waiting threads atomically</span>
<a name="l00121"></a>00121         <span class="keywordflow">if</span>(!::ReleaseSemaphore(lCondition-&gt;mSemaphore, lCondition-&gt;mWaiters, 0)) {
<a name="l00122"></a>00122             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00123"></a>00123             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() unable to release semaphore!&quot;</span>);
<a name="l00124"></a>00124         }
<a name="l00125"></a>00125         <span class="comment">// wait for threads to acquire the counting semaphore</span>
<a name="l00126"></a>00126         LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00127"></a>00127         <span class="keywordflow">if</span>(::WaitForSingleObject(lCondition-&gt;mDone, INFINITE) != WAIT_OBJECT_0) {
<a name="l00128"></a>00128             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00129"></a>00129             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() invalid event!&quot;</span>);
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131         lCondition-&gt;mBroadcast = <span class="keyword">false</span>;
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133     <span class="keywordflow">else</span> LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00134"></a>00134 <span class="preprocessor">#else</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::pthread_cond_broadcast(lCondition) != 0) {
<a name="l00136"></a>00136         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00137"></a>00137         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() invalid condition!&quot;</span>);
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139 <span class="preprocessor">#endif</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a614784b931143e8ccb460e2a4ac9a3e8"></a><!-- doxytag: member="PACC::Threading::Semaphore::lock" ref="a614784b931143e8ccb460e2a4ac9a3e8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Mutex::lock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock the mutex. </p>
<p>A thread should never lock a mutex twice consecutively (without calling method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">Mutex::unlock</a>). Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00087">87</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00088"></a>00088 {
<a name="l00089"></a>00089     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00090"></a>00090 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::WaitForSingleObject(*lMutex, INFINITE) != WAIT_OBJECT_0)
<a name="l00092"></a>00092 #<span class="keywordflow">else</span>
<a name="l00093"></a>00093         <span class="keywordflow">if</span>(::pthread_mutex_lock(lMutex) != 0) 
<a name="l00094"></a>00094 #endif
<a name="l00095"></a>00095             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afba3c013a24ae9803571dbbe6651fc65a7a" title="Operation would produce a dead lock.">eWouldDeadLock</a>, <span class="stringliteral">&quot;Mutex::lock() can&apos;t lock!&quot;</span>);
<a name="l00096"></a>00096 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a22ffcceb8afd379ce4dcd770886a7035"></a><!-- doxytag: member="PACC::Threading::Semaphore::post" ref="a22ffcceb8afd379ce4dcd770886a7035" args="(bool inLock=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Semaphore::post </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inLock</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Post a signal that another ressource is now avalable. </p>
<p>This method increments the semaphore count and signals a single waiting thread if one exists. If argument <code>inLock</code> is true (default), it will first lock the embedded mutex (using the lock method) to protect the internal count. Otherwise, it assumes that the caller has already locked the mutex (using <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Semaphore::lock</a>) and that it is responsible for unlocking it. </p>

<p>Definition at line <a class="el" href="_semaphore_8cpp_source.html#l00045">45</a> of file <a class="el" href="_semaphore_8cpp_source.html">Semaphore.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00046"></a>00046 {
<a name="l00047"></a>00047     <span class="comment">// acquire exclusive access to count</span>
<a name="l00048"></a>00048     <span class="keywordflow">if</span>(inLock) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">lock</a>();
<a name="l00049"></a>00049     <span class="comment">// increment count</span>
<a name="l00050"></a>00050     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a6a3671f1b105232d67f54bde542fd5ad" title="Current count of semaphore.">mCount</a> += 1;
<a name="l00051"></a>00051     <span class="comment">// if waiting threads exist, signal one of them to wake up</span>
<a name="l00052"></a>00052     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a2a7ad0559da2413fbad467b3cfe75c61" title="Current number of waiting threads.">mWaiters</a> &gt; 0) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#aa1c0ab62547bc517761df1ddcde8faed" title="Signal a single waiting thread to wake up (which waiting thread wakes up is undetermined)...">Condition::signal</a>();
<a name="l00053"></a>00053     <span class="comment">// release access to count</span>
<a name="l00054"></a>00054     <span class="keywordflow">if</span>(inLock) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00055"></a>00055 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa1c0ab62547bc517761df1ddcde8faed"></a><!-- doxytag: member="PACC::Threading::Semaphore::signal" ref="aa1c0ab62547bc517761df1ddcde8faed" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Condition::signal </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal a single waiting thread to wake up (which waiting thread wakes up is undetermined). </p>
<p>This method assumes that the embedded mutex has already been locked by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>). It allows the caller to execute some thread critical operations, like setting or resetting external conditions. If no thread is waiting, the signal is simply ignored. Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">lCondition.lock();
<span class="comment">// set some external condition</span>
...
lCondition.signal();
lCondition.unlock();
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00156">156</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00157"></a>00157 {
<a name="l00158"></a>00158     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00159"></a>00159 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00161"></a>00161     <span class="keywordtype">int</span> lWaiters = lCondition-&gt;mWaiters;
<a name="l00162"></a>00162     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00163"></a>00163     <span class="comment">// wake up a single waiting thread if any waiters</span>
<a name="l00164"></a>00164     <span class="keywordflow">if</span>(lWaiters &gt; 0 &amp;&amp; ::ReleaseSemaphore(lCondition-&gt;mSemaphore, 1, 0) == 0)
<a name="l00165"></a>00165 <span class="preprocessor">#else</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(::pthread_cond_signal(lCondition) != 0)
<a name="l00167"></a>00167 <span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>        {
<a name="l00169"></a>00169             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00170"></a>00170             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::signal() invalid condition!&quot;</span>);
<a name="l00171"></a>00171         }
<a name="l00172"></a>00172 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a831807e017053475f53203505168548d"></a><!-- doxytag: member="PACC::Threading::Semaphore::tryLock" ref="a831807e017053475f53203505168548d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Mutex::tryLock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to lock the mutex without blocking. </p>
<p>Return's true if successful; false otherwise.</p>
<p>Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00104">104</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00105"></a>00105 {
<a name="l00106"></a>00106     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00107"></a>00107 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>    <span class="keywordtype">int</span> lValue = ::WaitForSingleObject(*lMutex, 0);
<a name="l00109"></a>00109     <span class="keywordflow">if</span>(lValue == WAIT_TIMEOUT) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00110"></a>00110     <span class="keywordflow">if</span>(lValue != WAIT_OBJECT_0)
<a name="l00111"></a>00111 <span class="preprocessor">#else</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>        <span class="keywordtype">int</span> lValue = ::pthread_mutex_trylock(lMutex);
<a name="l00113"></a>00113     <span class="keywordflow">if</span>(lValue == EBUSY) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00114"></a>00114     <span class="keywordflow">if</span>(lValue != 0) 
<a name="l00115"></a>00115 <span class="preprocessor">#endif</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>        <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Mutex::trylock() can&apos;t trylock!&quot;</span>);
<a name="l00117"></a>00117     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00118"></a>00118 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9e3396aa2781369236282c5ddd64a74f"></a><!-- doxytag: member="PACC::Threading::Semaphore::tryWait" ref="a9e3396aa2781369236282c5ddd64a74f" args="(bool inLock=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Semaphore::tryWait </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inLock</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to acquire one ressource, but don't block if ressources are exhausted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if resource was acquired, false otherwise.</dd></dl>
<p>This method decrements a positive semaphore count and returns true. If count is negative or null, it returns false immediately, without waiting for an available resource. If argument <code>inLock</code> is true (default), it will first lock the embedded mutex (using the lock method) to protect the internal count. Otherwise, it assumes that the caller has already locked the mutex (using <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Semaphore::lock</a>) and that it is responsible for unlocking it. </p>

<p>Definition at line <a class="el" href="_semaphore_8cpp_source.html#l00062">62</a> of file <a class="el" href="_semaphore_8cpp_source.html">Semaphore.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00063"></a>00063 {
<a name="l00064"></a>00064     <span class="keywordtype">bool</span> lReturn = <span class="keyword">true</span>;
<a name="l00065"></a>00065     <span class="comment">// acquire exclusive access to count</span>
<a name="l00066"></a>00066     <span class="keywordflow">if</span>(inLock) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">lock</a>();
<a name="l00067"></a>00067     <span class="comment">// if ressource is exhausted, return false</span>
<a name="l00068"></a>00068     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a6a3671f1b105232d67f54bde542fd5ad" title="Current count of semaphore.">mCount</a> &lt;= 0) lReturn = <span class="keyword">false</span>;
<a name="l00069"></a>00069     <span class="comment">// decrement count only if ressource is available</span>
<a name="l00070"></a>00070     <span class="keywordflow">if</span>(lReturn) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a6a3671f1b105232d67f54bde542fd5ad" title="Current count of semaphore.">mCount</a> -= 1;
<a name="l00071"></a>00071     <span class="comment">// release access to count</span>
<a name="l00072"></a>00072     <span class="keywordflow">if</span>(inLock) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00073"></a>00073     <span class="keywordflow">return</span> lReturn;
<a name="l00074"></a>00074 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac56644852bc8f3afa80372491045955d"></a><!-- doxytag: member="PACC::Threading::Semaphore::unlock" ref="ac56644852bc8f3afa80372491045955d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Mutex::unlock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the mutex. </p>
<p>A thread should never unlock a mutex twice consecutively (without calling method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Mutex::lock</a>). Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00125">125</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00126"></a>00126 {
<a name="l00127"></a>00127     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00128"></a>00128 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::ReleaseMutex(*lMutex) == 0)
<a name="l00130"></a>00130 #<span class="keywordflow">else</span>
<a name="l00131"></a>00131         <span class="keywordflow">if</span>(::pthread_mutex_unlock(lMutex) != 0)
<a name="l00132"></a>00132 #endif
<a name="l00133"></a>00133             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afba158cbdf072ad8c387b006134f3d32e75" title="Mutex not own by calling thread.">eMutexNotOwned</a>, <span class="stringliteral">&quot;Mutex::unlock() can&apos;t unlock!&quot;</span>);
<a name="l00134"></a>00134 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a678ef989bf3d6a806907fc2632ad3a60"></a><!-- doxytag: member="PACC::Threading::Semaphore::wait" ref="a678ef989bf3d6a806907fc2632ad3a60" args="(double inMaxTime=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Condition::wait </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inMaxTime</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait up to <code>inMaxTime</code> seconds for the condition to be signaled (or broadcasted). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if condition was signaled (or broadcasted), false if timed out.</dd></dl>
<p>This method assumes that the embedded mutex has already been locked by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>), and will also return with the mutex locked. A negative or null time out (default) means that the method should wait indefinitely.</p>
<p>Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">...
lCondition.lock();
<span class="keywordflow">if</span>(external_condition == <span class="keyword">false</span>) {
    <span class="comment">// wait indefinitely...</span>
    lCondition.wait();
    <span class="comment">// reset external condition</span>
    ...
}
lCondition.unlock();
...
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00196">196</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00197"></a>00197 {
<a name="l00198"></a>00198     <span class="keywordtype">bool</span> lReturn;
<a name="l00199"></a>00199     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00200"></a>00200 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00202"></a>00202     <span class="comment">// increment number of waiters</span>
<a name="l00203"></a>00203     lCondition-&gt;mWaiters += 1;
<a name="l00204"></a>00204     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00205"></a>00205     <span class="comment">// wait for the semaphore after atomically unlocking the mutex</span>
<a name="l00206"></a>00206     HANDLE* lMutex = (HANDLE*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00207"></a>00207     DWORD lRes = ::SignalObjectAndWait(*lMutex, lCondition-&gt;mSemaphore, (inMaxTime &lt;= 0 ? INFINITE : (DWORD)(inMaxTime*1000)), <span class="keyword">false</span>);
<a name="l00208"></a>00208     <span class="keywordflow">if</span>((lReturn = (lRes != WAIT_TIMEOUT)) &amp;&amp; lRes != WAIT_OBJECT_0) {
<a name="l00209"></a>00209         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00210"></a>00210         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid semaphore!&quot;</span>);
<a name="l00211"></a>00211     }   
<a name="l00212"></a>00212     EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00213"></a>00213     <span class="comment">// we&apos;re no longer waiting, decrement number of waiters</span>
<a name="l00214"></a>00214     lCondition-&gt;mWaiters -= 1;
<a name="l00215"></a>00215     <span class="keywordtype">bool</span> lLastWaiter = lCondition-&gt;mBroadcast &amp;&amp; lCondition-&gt;mWaiters == 0;
<a name="l00216"></a>00216     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00217"></a>00217     <span class="keywordflow">if</span>(lLastWaiter) {
<a name="l00218"></a>00218         <span class="comment">// wait for the mutex after atomically signaling the broadcaster that all threads have awakened</span>
<a name="l00219"></a>00219         <span class="keywordflow">if</span>(::SignalObjectAndWait(lCondition-&gt;mDone, *lMutex, INFINITE, <span class="keyword">false</span>) != WAIT_OBJECT_0)
<a name="l00220"></a>00220         {
<a name="l00221"></a>00221             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00222"></a>00222             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid mutex!&quot;</span>);
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(::WaitForSingleObject(*lMutex, INFINITE) != WAIT_OBJECT_0) {
<a name="l00226"></a>00226         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00227"></a>00227         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid mutex!&quot;</span>);
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 <span class="preprocessor">#else</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span>    <span class="keywordtype">int</span> lRes;
<a name="l00231"></a>00231     <span class="comment">// pthread_cond_wait atomically unlocks the mutex, waits on the condition, and locks the mutex again</span>
<a name="l00232"></a>00232     <span class="keywordflow">if</span>(inMaxTime &lt;= 0) lRes = ::pthread_cond_wait(lCondition, (pthread_mutex_t*)<a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>);
<a name="l00233"></a>00233     <span class="keywordflow">else</span> {
<a name="l00234"></a>00234         <span class="comment">// get time of day and add specified time out</span>
<a name="l00235"></a>00235         <span class="keyword">struct </span>timeval lVal;
<a name="l00236"></a>00236         ::gettimeofday(&amp;lVal, 0);
<a name="l00237"></a>00237         <span class="keyword">struct </span>timespec lSpec;
<a name="l00238"></a>00238         lSpec.tv_sec = lVal.tv_sec + (long) inMaxTime;
<a name="l00239"></a>00239         lSpec.tv_nsec = lVal.tv_usec*1000 + (long) ((inMaxTime - floor(inMaxTime)) * 1000000000);
<a name="l00240"></a>00240         <span class="comment">// check that the number of nanoseconds is less than 1 sec</span>
<a name="l00241"></a>00241         <span class="keywordflow">if</span>(lSpec.tv_nsec &gt;= 1000000000)
<a name="l00242"></a>00242         {
<a name="l00243"></a>00243             <span class="comment">// otherwise adjust...</span>
<a name="l00244"></a>00244             lSpec.tv_nsec -= 1000000000;
<a name="l00245"></a>00245             lSpec.tv_sec += 1;
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247         <span class="comment">// pthread_cond_timedwait atomically unlocks the mutex, waits on the condition, and locks the mutex again</span>
<a name="l00248"></a>00248         lRes = ::pthread_cond_timedwait(lCondition, (pthread_mutex_t*)<a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>, &amp;lSpec);
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250     <span class="keywordflow">if</span>((lReturn = (lRes != ETIMEDOUT)) &amp;&amp; lRes != 0)
<a name="l00251"></a>00251     {
<a name="l00252"></a>00252         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00253"></a>00253         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid condition!&quot;</span>);
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255 <span class="preprocessor">#endif</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span>    <span class="keywordflow">return</span> lReturn;
<a name="l00257"></a>00257 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a62a41b45070c058cd98fc13fb78a3581"></a><!-- doxytag: member="PACC::Threading::Semaphore::wait" ref="a62a41b45070c058cd98fc13fb78a3581" args="(double inMaxTime=0, bool inLock=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Semaphore::wait </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inMaxTime</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inLock</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait up to <code>inMaxTime</code> seconds to acquire one resource. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if resource was acquired, false if timed out.</dd></dl>
<p>This method decrements a positive semaphore count and returns true. When count is negative or null, it waits up to <code>inMaxTime</code> seconds for a resource to become available. If one becomes available before time out, then the method returns true. Otherwise, it returns false.</p>
<p>If argument <code>inLock</code> is true (default), it will first lock the embedded mutex (using the lock method) to protect the internal count. Otherwise, it assumes that the caller has already locked the mutex (using <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Semaphore::lock</a>) and that it is responsible for unlocking it.</p>
<p>A negative or null time out (default) means that the method should wait indefinitely (for a null time out, use method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a9e3396aa2781369236282c5ddd64a74f" title="Try to acquire one ressource, but don&#39;t block if ressources are exhausted.">Semaphore::tryWait</a>). </p>

<p>Definition at line <a class="el" href="_semaphore_8cpp_source.html#l00085">85</a> of file <a class="el" href="_semaphore_8cpp_source.html">Semaphore.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00086"></a>00086 {
<a name="l00087"></a>00087     <span class="keywordtype">bool</span> lReturn = <span class="keyword">true</span>;
<a name="l00088"></a>00088     <span class="comment">// acquire exclusive access to count</span>
<a name="l00089"></a>00089     <span class="keywordflow">if</span>(inLock) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">lock</a>();
<a name="l00090"></a>00090     <span class="comment">// increment number of waiters</span>
<a name="l00091"></a>00091     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a2a7ad0559da2413fbad467b3cfe75c61" title="Current number of waiting threads.">mWaiters</a> += 1;
<a name="l00092"></a>00092     <span class="comment">// if ressource is exhausted wait for ressource</span>
<a name="l00093"></a>00093     <span class="keywordflow">while</span>(<a class="code" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a6a3671f1b105232d67f54bde542fd5ad" title="Current count of semaphore.">mCount</a> &lt;= 0 &amp;&amp; lReturn) lReturn = <a class="code" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a62a41b45070c058cd98fc13fb78a3581" title="Wait up to inMaxTime seconds to acquire one resource.">Condition::wait</a>(inMaxTime);
<a name="l00094"></a>00094     <span class="comment">// decrement count only if condition was signaled (not timed out)</span>
<a name="l00095"></a>00095     <span class="keywordflow">if</span>(lReturn) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a6a3671f1b105232d67f54bde542fd5ad" title="Current count of semaphore.">mCount</a> -= 1;
<a name="l00096"></a>00096     <span class="comment">// decrement number of waiters</span>
<a name="l00097"></a>00097     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_semaphore.html#a2a7ad0559da2413fbad467b3cfe75c61" title="Current number of waiting threads.">mWaiters</a> -= 1;
<a name="l00098"></a>00098     <span class="comment">// release access to count</span>
<a name="l00099"></a>00099     <span class="keywordflow">if</span>(inLock) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00100"></a>00100     <span class="keywordflow">return</span> lReturn;
<a name="l00101"></a>00101 }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PACC/Threading/<a class="el" href="_semaphore_8hpp_source.html">Semaphore.hpp</a></li>
<li>PACC/Threading/<a class="el" href="_semaphore_8cpp_source.html">Semaphore.cpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jan 31 15:10:22 2010 for PACC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
