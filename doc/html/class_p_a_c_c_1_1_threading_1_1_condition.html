<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PACC: PACC::Threading::Condition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_c_c.html">PACC</a>::<a class="el" href="namespace_p_a_c_c_1_1_threading.html">Threading</a>::<a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html">Condition</a>
  </div>
</div>
<div class="contents">
<h1>PACC::Threading::Condition Class Reference<br/>
<small>
[<a class="el" href="group___threading.html">Threading: portable thread management</a>]</small>
</h1><!-- doxytag: class="PACC::Threading::Condition" --><!-- doxytag: inherits="PACC::Threading::Mutex" -->
<p>Condition for thread synchronization.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_condition_8hpp_source.html">Condition.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PACC::Threading::Condition:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_p_a_c_c_1_1_threading_1_1_condition.gif" usemap="#PACC::Threading::Condition_map" alt=""/>
  <map id="PACC::Threading::Condition_map" name="PACC::Threading::Condition_map">
<area href="class_p_a_c_c_1_1_threading_1_1_mutex.html" alt="PACC::Threading::Mutex" shape="rect" coords="297,0,485,24"/>
<area href="class_p_a_c_c_1_1_threading_1_1_semaphore.html" alt="PACC::Threading::Semaphore" shape="rect" coords="0,112,188,136"/>
<area href="class_p_a_c_c_1_1_threading_1_1_task.html" alt="PACC::Threading::Task" shape="rect" coords="198,112,386,136"/>
<area href="class_p_a_c_c_1_1_threading_1_1_thread.html" alt="PACC::Threading::Thread" shape="rect" coords="396,112,584,136"/>
<area href="class_p_a_c_c_1_1_threading_1_1_thread_pool.html" alt="PACC::Threading::ThreadPool" shape="rect" coords="594,112,782,136"/>
<area href="class_p_a_c_c_1_1_socket_1_1_server_thread.html" alt="PACC::Socket::ServerThread" shape="rect" coords="297,168,485,192"/>
<area href="class_p_a_c_c_1_1_threading_1_1_slave_thread.html" alt="PACC::Threading::SlaveThread" shape="rect" coords="495,168,683,192"/>
</map>
 </div>
</div>

<p><a href="class_p_a_c_c_1_1_threading_1_1_condition-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a4ea8528abbd8b97f7b09cfee69e6c244">Condition</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate native structure and create condition.  <a href="#a4ea8528abbd8b97f7b09cfee69e6c244"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab2cef53745ce9102d99c3ff9fcabc27"></a><!-- doxytag: member="PACC::Threading::Condition::~Condition" ref="aab2cef53745ce9102d99c3ff9fcabc27" args="(void)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#aab2cef53745ce9102d99c3ff9fcabc27">~Condition</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy condition and free allocated native structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a5103716b4853043b7e68a9ace2193a22">broadcast</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broadcast a wake up signal to all waiting threads.  <a href="#a5103716b4853043b7e68a9ace2193a22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#aa1c0ab62547bc517761df1ddcde8faed">signal</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal a single waiting thread to wake up (which waiting thread wakes up is undetermined).  <a href="#aa1c0ab62547bc517761df1ddcde8faed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a678ef989bf3d6a806907fc2632ad3a60">wait</a> (double inMaxTime=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait up to <code>inMaxTime</code> seconds for the condition to be signaled (or broadcasted).  <a href="#a678ef989bf3d6a806907fc2632ad3a60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8">lock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the mutex.  <a href="#a614784b931143e8ccb460e2a4ac9a3e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a831807e017053475f53203505168548d">tryLock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to lock the mutex without blocking.  <a href="#a831807e017053475f53203505168548d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d">unlock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the mutex.  <a href="#ac56644852bc8f3afa80372491045955d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a522f03215ec1b3dc7e49f14da402f21b"></a><!-- doxytag: member="PACC::Threading::Condition::mCondition" ref="a522f03215ec1b3dc7e49f14da402f21b" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b">mCondition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native condition. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a3148fa4affbe20e96b7f0593c06e89"></a><!-- doxytag: member="PACC::Threading::Condition::mMutex" ref="a6a3148fa4affbe20e96b7f0593c06e89" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89">mMutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native mutex. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Condition for thread synchronization. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Marc Parizeau, Laboratoire de vision et syst&egrave;mes num&eacute;riques, Universit&eacute; Laval</dd></dl>
<p>This class incapsulates a cross-platform POSIX condition with classic <a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a5103716b4853043b7e68a9ace2193a22" title="Broadcast a wake up signal to all waiting threads.">Condition::broadcast</a>, <a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#aa1c0ab62547bc517761df1ddcde8faed" title="Signal a single waiting thread to wake up (which waiting thread wakes up is undetermined)...">Condition::signal</a>, and <a class="el" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a678ef989bf3d6a806907fc2632ad3a60" title="Wait up to inMaxTime seconds for the condition to be signaled (or broadcasted).">Condition::wait</a> methods. It should be compatible with any flavour of Unix that supports POSIX threads. It is also compatible with any version of Windows that support the SignalObjectAndWait method (introduced with NT4).</p>
<p>This class has been tested under Linux, MacOS X and Windows 2000/XP. </p>

<p>Definition at line <a class="el" href="_condition_8hpp_source.html#l00053">53</a> of file <a class="el" href="_condition_8hpp_source.html">Condition.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4ea8528abbd8b97f7b09cfee69e6c244"></a><!-- doxytag: member="PACC::Threading::Condition::Condition" ref="a4ea8528abbd8b97f7b09cfee69e6c244" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Threading::Condition::Condition </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate native structure and create condition. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00067">67</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00068"></a>00068 {
<a name="l00069"></a>00069     pthread_cond_t* lCondition = <span class="keyword">new</span> pthread_cond_t;
<a name="l00070"></a>00070 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>    lCondition-&gt;mWaiters = 0;
<a name="l00072"></a>00072     lCondition-&gt;mBroadcast = <span class="keyword">false</span>;
<a name="l00073"></a>00073     ::InitializeCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00074"></a>00074     lCondition-&gt;mSemaphore = ::CreateSemaphore(0, 0, 0x7fffffff, 0);
<a name="l00075"></a>00075     lCondition-&gt;mDone = ::CreateEvent(0, <span class="keyword">false</span>, <span class="keyword">false</span>, 0);
<a name="l00076"></a>00076     <span class="keywordflow">if</span>(lCondition-&gt;mSemaphore == 0 || lCondition-&gt;mDone == 0)
<a name="l00077"></a>00077 <span class="preprocessor">#else</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(::pthread_cond_init(lCondition, 0) != 0)
<a name="l00079"></a>00079 #endif
<a name="l00080"></a>00080             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Threading::Condition() can&apos;t create!&quot;</span>);
<a name="l00081"></a>00081     <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a> = lCondition;
<a name="l00082"></a>00082 }
</pre></div></p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5103716b4853043b7e68a9ace2193a22"></a><!-- doxytag: member="PACC::Threading::Condition::broadcast" ref="a5103716b4853043b7e68a9ace2193a22" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Condition::broadcast </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Broadcast a wake up signal to all waiting threads. </p>
<p>This method assumes that the embedded mutex has already been LOCKED by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>). It allows the caller to execute some thread critical operations like setting an external condition prior to broadcasting. If no thread is waiting, the signal is simply ignored. Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">lCondition.lock();
<span class="comment">// set some external condition</span>
...
lCondition.broadcast();
lCondition.unlock();
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00113">113</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00114"></a>00114 {
<a name="l00115"></a>00115     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00116"></a>00116 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00118"></a>00118     <span class="keywordflow">if</span>(lCondition-&gt;mWaiters &gt; 0) {
<a name="l00119"></a>00119         lCondition-&gt;mBroadcast = <span class="keyword">true</span>;
<a name="l00120"></a>00120         <span class="comment">// wake up the waiting threads atomically</span>
<a name="l00121"></a>00121         <span class="keywordflow">if</span>(!::ReleaseSemaphore(lCondition-&gt;mSemaphore, lCondition-&gt;mWaiters, 0)) {
<a name="l00122"></a>00122             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00123"></a>00123             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() unable to release semaphore!&quot;</span>);
<a name="l00124"></a>00124         }
<a name="l00125"></a>00125         <span class="comment">// wait for threads to acquire the counting semaphore</span>
<a name="l00126"></a>00126         LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00127"></a>00127         <span class="keywordflow">if</span>(::WaitForSingleObject(lCondition-&gt;mDone, INFINITE) != WAIT_OBJECT_0) {
<a name="l00128"></a>00128             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00129"></a>00129             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() invalid event!&quot;</span>);
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131         lCondition-&gt;mBroadcast = <span class="keyword">false</span>;
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133     <span class="keywordflow">else</span> LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00134"></a>00134 <span class="preprocessor">#else</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::pthread_cond_broadcast(lCondition) != 0) {
<a name="l00136"></a>00136         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00137"></a>00137         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::broadcast() invalid condition!&quot;</span>);
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139 <span class="preprocessor">#endif</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a614784b931143e8ccb460e2a4ac9a3e8"></a><!-- doxytag: member="PACC::Threading::Condition::lock" ref="a614784b931143e8ccb460e2a4ac9a3e8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Mutex::lock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock the mutex. </p>
<p>A thread should never lock a mutex twice consecutively (without calling method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">Mutex::unlock</a>). Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00087">87</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00088"></a>00088 {
<a name="l00089"></a>00089     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00090"></a>00090 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::WaitForSingleObject(*lMutex, INFINITE) != WAIT_OBJECT_0)
<a name="l00092"></a>00092 #<span class="keywordflow">else</span>
<a name="l00093"></a>00093         <span class="keywordflow">if</span>(::pthread_mutex_lock(lMutex) != 0) 
<a name="l00094"></a>00094 #endif
<a name="l00095"></a>00095             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afba3c013a24ae9803571dbbe6651fc65a7a" title="Operation would produce a dead lock.">eWouldDeadLock</a>, <span class="stringliteral">&quot;Mutex::lock() can&apos;t lock!&quot;</span>);
<a name="l00096"></a>00096 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa1c0ab62547bc517761df1ddcde8faed"></a><!-- doxytag: member="PACC::Threading::Condition::signal" ref="aa1c0ab62547bc517761df1ddcde8faed" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Condition::signal </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal a single waiting thread to wake up (which waiting thread wakes up is undetermined). </p>
<p>This method assumes that the embedded mutex has already been locked by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>). It allows the caller to execute some thread critical operations, like setting or resetting external conditions. If no thread is waiting, the signal is simply ignored. Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">lCondition.lock();
<span class="comment">// set some external condition</span>
...
lCondition.signal();
lCondition.unlock();
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00156">156</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00157"></a>00157 {
<a name="l00158"></a>00158     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00159"></a>00159 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00161"></a>00161     <span class="keywordtype">int</span> lWaiters = lCondition-&gt;mWaiters;
<a name="l00162"></a>00162     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00163"></a>00163     <span class="comment">// wake up a single waiting thread if any waiters</span>
<a name="l00164"></a>00164     <span class="keywordflow">if</span>(lWaiters &gt; 0 &amp;&amp; ::ReleaseSemaphore(lCondition-&gt;mSemaphore, 1, 0) == 0)
<a name="l00165"></a>00165 <span class="preprocessor">#else</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(::pthread_cond_signal(lCondition) != 0)
<a name="l00167"></a>00167 <span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>        {
<a name="l00169"></a>00169             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00170"></a>00170             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::signal() invalid condition!&quot;</span>);
<a name="l00171"></a>00171         }
<a name="l00172"></a>00172 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a831807e017053475f53203505168548d"></a><!-- doxytag: member="PACC::Threading::Condition::tryLock" ref="a831807e017053475f53203505168548d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Mutex::tryLock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to lock the mutex without blocking. </p>
<p>Return's true if successful; false otherwise.</p>
<p>Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00104">104</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00105"></a>00105 {
<a name="l00106"></a>00106     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00107"></a>00107 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>    <span class="keywordtype">int</span> lValue = ::WaitForSingleObject(*lMutex, 0);
<a name="l00109"></a>00109     <span class="keywordflow">if</span>(lValue == WAIT_TIMEOUT) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00110"></a>00110     <span class="keywordflow">if</span>(lValue != WAIT_OBJECT_0)
<a name="l00111"></a>00111 <span class="preprocessor">#else</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>        <span class="keywordtype">int</span> lValue = ::pthread_mutex_trylock(lMutex);
<a name="l00113"></a>00113     <span class="keywordflow">if</span>(lValue == EBUSY) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00114"></a>00114     <span class="keywordflow">if</span>(lValue != 0) 
<a name="l00115"></a>00115 <span class="preprocessor">#endif</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>        <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Mutex::trylock() can&apos;t trylock!&quot;</span>);
<a name="l00117"></a>00117     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00118"></a>00118 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac56644852bc8f3afa80372491045955d"></a><!-- doxytag: member="PACC::Threading::Condition::unlock" ref="ac56644852bc8f3afa80372491045955d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threading::Mutex::unlock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the mutex. </p>
<p>A thread should never unlock a mutex twice consecutively (without calling method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Mutex::lock</a>). Any error will raise a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_mutex_8cpp_source.html#l00125">125</a> of file <a class="el" href="_mutex_8cpp_source.html">Mutex.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00126"></a>00126 {
<a name="l00127"></a>00127     pthread_mutex_t* lMutex = (pthread_mutex_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00128"></a>00128 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(::ReleaseMutex(*lMutex) == 0)
<a name="l00130"></a>00130 #<span class="keywordflow">else</span>
<a name="l00131"></a>00131         <span class="keywordflow">if</span>(::pthread_mutex_unlock(lMutex) != 0)
<a name="l00132"></a>00132 #endif
<a name="l00133"></a>00133             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afba158cbdf072ad8c387b006134f3d32e75" title="Mutex not own by calling thread.">eMutexNotOwned</a>, <span class="stringliteral">&quot;Mutex::unlock() can&apos;t unlock!&quot;</span>);
<a name="l00134"></a>00134 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a678ef989bf3d6a806907fc2632ad3a60"></a><!-- doxytag: member="PACC::Threading::Condition::wait" ref="a678ef989bf3d6a806907fc2632ad3a60" args="(double inMaxTime=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threading::Condition::wait </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inMaxTime</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait up to <code>inMaxTime</code> seconds for the condition to be signaled (or broadcasted). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if condition was signaled (or broadcasted), false if timed out.</dd></dl>
<p>This method assumes that the embedded mutex has already been locked by the calling thread (using method <a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8" title="Lock the mutex.">Condition::lock</a>), and will also return with the mutex locked. A negative or null time out (default) means that the method should wait indefinitely.</p>
<p>Here is an example of typical usage: </p>
<div class="fragment"><pre class="fragment">...
lCondition.lock();
<span class="keywordflow">if</span>(external_condition == <span class="keyword">false</span>) {
    <span class="comment">// wait indefinitely...</span>
    lCondition.wait();
    <span class="comment">// reset external condition</span>
    ...
}
lCondition.unlock();
...
</pre></div><p> WARNING: Calling this method without first locking the mutex may produce unexpected OS dependant results. And don't forget to unlock the mutex afterwards!</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_threading_1_1_exception.html" title="Multithread exception.">Threading::Exception</a>. </p>

<p>Definition at line <a class="el" href="_condition_8cpp_source.html#l00196">196</a> of file <a class="el" href="_condition_8cpp_source.html">Condition.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00197"></a>00197 {
<a name="l00198"></a>00198     <span class="keywordtype">bool</span> lReturn;
<a name="l00199"></a>00199     pthread_cond_t* lCondition = (pthread_cond_t*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_condition.html#a522f03215ec1b3dc7e49f14da402f21b" title="Opaque structure of native condition.">mCondition</a>;
<a name="l00200"></a>00200 <span class="preprocessor">#ifdef PACC_THREADS_WIN32</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>    EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00202"></a>00202     <span class="comment">// increment number of waiters</span>
<a name="l00203"></a>00203     lCondition-&gt;mWaiters += 1;
<a name="l00204"></a>00204     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00205"></a>00205     <span class="comment">// wait for the semaphore after atomically unlocking the mutex</span>
<a name="l00206"></a>00206     HANDLE* lMutex = (HANDLE*) <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>;
<a name="l00207"></a>00207     DWORD lRes = ::SignalObjectAndWait(*lMutex, lCondition-&gt;mSemaphore, (inMaxTime &lt;= 0 ? INFINITE : (DWORD)(inMaxTime*1000)), <span class="keyword">false</span>);
<a name="l00208"></a>00208     <span class="keywordflow">if</span>((lReturn = (lRes != WAIT_TIMEOUT)) &amp;&amp; lRes != WAIT_OBJECT_0) {
<a name="l00209"></a>00209         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00210"></a>00210         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid semaphore!&quot;</span>);
<a name="l00211"></a>00211     }   
<a name="l00212"></a>00212     EnterCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00213"></a>00213     <span class="comment">// we&apos;re no longer waiting, decrement number of waiters</span>
<a name="l00214"></a>00214     lCondition-&gt;mWaiters -= 1;
<a name="l00215"></a>00215     <span class="keywordtype">bool</span> lLastWaiter = lCondition-&gt;mBroadcast &amp;&amp; lCondition-&gt;mWaiters == 0;
<a name="l00216"></a>00216     LeaveCriticalSection(&amp;lCondition-&gt;mLock);
<a name="l00217"></a>00217     <span class="keywordflow">if</span>(lLastWaiter) {
<a name="l00218"></a>00218         <span class="comment">// wait for the mutex after atomically signaling the broadcaster that all threads have awakened</span>
<a name="l00219"></a>00219         <span class="keywordflow">if</span>(::SignalObjectAndWait(lCondition-&gt;mDone, *lMutex, INFINITE, <span class="keyword">false</span>) != WAIT_OBJECT_0)
<a name="l00220"></a>00220         {
<a name="l00221"></a>00221             <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00222"></a>00222             <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid mutex!&quot;</span>);
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(::WaitForSingleObject(*lMutex, INFINITE) != WAIT_OBJECT_0) {
<a name="l00226"></a>00226         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00227"></a>00227         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid mutex!&quot;</span>);
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 <span class="preprocessor">#else</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span>    <span class="keywordtype">int</span> lRes;
<a name="l00231"></a>00231     <span class="comment">// pthread_cond_wait atomically unlocks the mutex, waits on the condition, and locks the mutex again</span>
<a name="l00232"></a>00232     <span class="keywordflow">if</span>(inMaxTime &lt;= 0) lRes = ::pthread_cond_wait(lCondition, (pthread_mutex_t*)<a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>);
<a name="l00233"></a>00233     <span class="keywordflow">else</span> {
<a name="l00234"></a>00234         <span class="comment">// get time of day and add specified time out</span>
<a name="l00235"></a>00235         <span class="keyword">struct </span>timeval lVal;
<a name="l00236"></a>00236         ::gettimeofday(&amp;lVal, 0);
<a name="l00237"></a>00237         <span class="keyword">struct </span>timespec lSpec;
<a name="l00238"></a>00238         lSpec.tv_sec = lVal.tv_sec + (long) inMaxTime;
<a name="l00239"></a>00239         lSpec.tv_nsec = lVal.tv_usec*1000 + (long) ((inMaxTime - floor(inMaxTime)) * 1000000000);
<a name="l00240"></a>00240         <span class="comment">// check that the number of nanoseconds is less than 1 sec</span>
<a name="l00241"></a>00241         <span class="keywordflow">if</span>(lSpec.tv_nsec &gt;= 1000000000)
<a name="l00242"></a>00242         {
<a name="l00243"></a>00243             <span class="comment">// otherwise adjust...</span>
<a name="l00244"></a>00244             lSpec.tv_nsec -= 1000000000;
<a name="l00245"></a>00245             lSpec.tv_sec += 1;
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247         <span class="comment">// pthread_cond_timedwait atomically unlocks the mutex, waits on the condition, and locks the mutex again</span>
<a name="l00248"></a>00248         lRes = ::pthread_cond_timedwait(lCondition, (pthread_mutex_t*)<a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89" title="Opaque structure of native mutex.">mMutex</a>, &amp;lSpec);
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250     <span class="keywordflow">if</span>((lReturn = (lRes != ETIMEDOUT)) &amp;&amp; lRes != 0)
<a name="l00251"></a>00251     {
<a name="l00252"></a>00252         <a class="code" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d" title="Unlock the mutex.">unlock</a>();
<a name="l00253"></a>00253         <span class="keywordflow">throw</span> Exception(<a class="code" href="namespace_p_a_c_c_1_1_threading.html#a162ec0577f483147de2fdebae8f61afbaeca13402df7f31df6f14cd425b3bce32" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Condition::wait() invalid condition!&quot;</span>);
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255 <span class="preprocessor">#endif</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span>    <span class="keywordflow">return</span> lReturn;
<a name="l00257"></a>00257 }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PACC/Threading/<a class="el" href="_condition_8hpp_source.html">Condition.hpp</a></li>
<li>PACC/Threading/<a class="el" href="_condition_8cpp_source.html">Condition.cpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jan 31 15:10:21 2010 for PACC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
