<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PACC: PACC::Socket::TCPServer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_c_c.html">PACC</a>::<a class="el" href="namespace_p_a_c_c_1_1_socket.html">Socket</a>::<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html">TCPServer</a>
  </div>
</div>
<div class="contents">
<h1>PACC::Socket::TCPServer Class Reference<br/>
<small>
[<a class="el" href="group___socket.html">Socket: portable socket networking</a>]</small>
</h1><!-- doxytag: class="PACC::Socket::TCPServer" --><!-- doxytag: inherits="PACC::Socket::TCP,PACC::Threading::Mutex" -->
<p>Portable multithreaded TCP server.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_t_c_p_server_8hpp_source.html">TCPServer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PACC::Socket::TCPServer:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.gif" usemap="#PACC::Socket::TCPServer_map" alt=""/>
  <map id="PACC::Socket::TCPServer_map" name="PACC::Socket::TCPServer_map">
<area href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" alt="PACC::Socket::TCP" shape="rect" coords="0,56,160,80"/>
<area href="class_p_a_c_c_1_1_threading_1_1_mutex.html" alt="PACC::Threading::Mutex" shape="rect" coords="170,56,330,80"/>
<area href="class_p_a_c_c_1_1_socket_1_1_port.html" alt="PACC::Socket::Port" shape="rect" coords="0,0,160,24"/>
</map>
 </div>
</div>

<p><a href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#ae38de551129eb860ed8ebba741637169">TCPServer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an uninitialized default server.  <a href="#ae38de551129eb860ed8ebba741637169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a729c544d752d388869ca32f2df3d8c2a">TCPServer</a> (unsigned int inPortNumber, unsigned int inMinPending=10)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a server that binds to port <code>inPortNumber</code> with a queue of <code>inMinPending</code> connections.  <a href="#a729c544d752d388869ca32f2df3d8c2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#aa998a4b72d88860d30496f31af5e36fa">~TCPServer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the server thread pool.  <a href="#aa998a4b72d88860d30496f31af5e36fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#afbd9175d5265732474d0996f99faf9fe">setDefaultOptions</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set default server options.  <a href="#afbd9175d5265732474d0996f99faf9fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa9967ccc64a9b3bbb4f2184d1fb1ff6"></a><!-- doxytag: member="PACC::Socket::TCPServer::bind" ref="afa9967ccc64a9b3bbb4f2184d1fb1ff6" args="(unsigned int inPortNumber)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#afa9967ccc64a9b3bbb4f2184d1fb1ff6">bind</a> (unsigned int inPortNumber)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind server to port number <code>inPortNumber</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad957f876d2d242168a7576797f43206f"></a><!-- doxytag: member="PACC::Socket::TCPServer::close" ref="ad957f876d2d242168a7576797f43206f" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#ad957f876d2d242168a7576797f43206f">close</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the server socket. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3971dab0f695f1bd6b8dabc391a9b5ef"></a><!-- doxytag: member="PACC::Socket::TCPServer::listen" ref="a3971dab0f695f1bd6b8dabc391a9b5ef" args="(unsigned int inMinPending)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a3971dab0f695f1bd6b8dabc391a9b5ef">listen</a> (unsigned int inMinPending)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Listen for at least <code>inMinPending</code> pending connections. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a5f8d28a0c765c78701ce8932242db84e">halt</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop accepting incomming connections.  <a href="#a5f8d28a0c765c78701ce8932242db84e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46a52a2e84f048fec127090872341d62"></a><!-- doxytag: member="PACC::Socket::TCPServer::open" ref="a46a52a2e84f048fec127090872341d62" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a46a52a2e84f048fec127090872341d62">open</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a new socket. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a60b5069fbaef5fab03916792cc46dfdc">run</a> (unsigned int inThreads, double inMaxHaltDelay=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start accepting incomming connections.  <a href="#a60b5069fbaef5fab03916792cc46dfdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#ad703bbaa6f6220a338e78ebcc28b9f60">wait</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for server termination.  <a href="#ad703bbaa6f6220a338e78ebcc28b9f60"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#af8a5779f58d2c7aa1c1e526701b48ee7">main</a> (int inDescriptor, const <a class="el" href="class_p_a_c_c_1_1_socket_1_1_server_thread.html">ServerThread</a> *inThread)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main function of server.  <a href="#af8a5779f58d2c7aa1c1e526701b48ee7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24eb29f54290765a83e3e8b0469c78c2"></a><!-- doxytag: member="PACC::Socket::TCPServer::connect" ref="a24eb29f54290765a83e3e8b0469c78c2" args="(const Address &amp;inPeer)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#a24eb29f54290765a83e3e8b0469c78c2">connect</a> (const <a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;inPeer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to server <code>inPeer</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#a7213a4475b86817b0396e6cf87c917d1">receiveMessage</a> (string &amp;outMessage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive string message from connected (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a>) server.  <a href="#a7213a4475b86817b0396e6cf87c917d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html#adc5fb826b4851b5314c9248ed94620e9">sendMessage</a> (const string &amp;inMessage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send string message to connected (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a>) server.  <a href="#adc5fb826b4851b5314c9248ed94620e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a002078da6139f20def2af30c22984fcf"></a><!-- doxytag: member="PACC::Socket::TCPServer::getDescriptor" ref="a002078da6139f20def2af30c22984fcf" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a002078da6139f20def2af30c22984fcf">getDescriptor</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return socket descriptor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a41ecb8dddf4441185f0b893d9dce5514">getPeerAddress</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return address of peer socket host.  <a href="#a41ecb8dddf4441185f0b893d9dce5514"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___socket.html#ga3109f582afef6bc8e60e4bbf26fc0ac6">Protocol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#aaa2f2ae4b67d2dd00a0933f60c784e54">getProtocol</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return protocol of socket.  <a href="#aaa2f2ae4b67d2dd00a0933f60c784e54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a4abe927d07cf69d1048992c6c9ce8452">getSockAddress</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return address of socket host.  <a href="#a4abe927d07cf69d1048992c6c9ce8452"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a758a6afe098539a362de79a86b5f1f1d">getSockOpt</a> (<a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Option</a> inName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value of socket option <code>inName</code>.  <a href="#a758a6afe098539a362de79a86b5f1f1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367">setSockOpt</a> (<a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Option</a> inName, double inValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set socket option <code>inName</code> to value <code>inValue</code>.  <a href="#a0f8abcce1ad096ea617c88b4d366e367"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#ae7bac9446a6f94245a4d9f15a23d3847">accept</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept connection on bound port.  <a href="#ae7bac9446a6f94245a4d9f15a23d3847"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a3d153806aea01830530f4ea04c0f338b">convertToNativeOption</a> (<a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Option</a> inName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert socket option <code>inName</code> to native socket option code.  <a href="#a3d153806aea01830530f4ea04c0f338b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0180add2f0a595baeae502607a74ea64">open</a> (<a class="el" href="group___socket.html#ga3109f582afef6bc8e60e4bbf26fc0ac6">Protocol</a>=eTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open new socket descriptor.  <a href="#a0180add2f0a595baeae502607a74ea64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#aa2bfb38c81fc0695d99f51cc8e7291c6">receive</a> (char *outBuffer, unsigned inMaxCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive data from connected socket.  <a href="#aa2bfb38c81fc0695d99f51cc8e7291c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#abc30f2043f597dc71e7113528824b42b">receiveFrom</a> (char *outBuffer, unsigned inMaxCount, <a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;outPeer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive data from unconnected socket.  <a href="#abc30f2043f597dc71e7113528824b42b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740">send</a> (const char *inBuffer, unsigned int inCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send data to connected socket.  <a href="#a7e0f88dff3eacee95675eb0fcc9cc740"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#ac9c7959ca0afef4d5fa57a28fba3b4d8">sendTo</a> (const char *inBuffer, unsigned int inCount, const <a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;inPeer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send data to unconnected socket.  <a href="#ac9c7959ca0afef4d5fa57a28fba3b4d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a27ed19ee09dc2503886c071edc813cc8">waitForActivity</a> (double inSeconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for activity.  <a href="#a27ed19ee09dc2503886c071edc813cc8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bdb877b4c432bd7adb794fd4fa29fc4"></a><!-- doxytag: member="PACC::Socket::TCPServer::mThreadPool" ref="a1bdb877b4c432bd7adb794fd4fa29fc4" args="" -->
vector&lt; <a class="el" href="class_p_a_c_c_1_1_socket_1_1_server_thread.html">ServerThread</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4">mThreadPool</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pool of threads pointers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11b5de113c588e85c076ea8f7a42600c"></a><!-- doxytag: member="PACC::Socket::TCPServer::mDescriptor" ref="a11b5de113c588e85c076ea8f7a42600c" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c">mDescriptor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">socket descriptor <br/></td></tr>
<tr><td colspan="2"><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a614784b931143e8ccb460e2a4ac9a3e8">lock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the mutex.  <a href="#a614784b931143e8ccb460e2a4ac9a3e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a831807e017053475f53203505168548d">tryLock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to lock the mutex without blocking.  <a href="#a831807e017053475f53203505168548d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#ac56644852bc8f3afa80372491045955d">unlock</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the mutex.  <a href="#ac56644852bc8f3afa80372491045955d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a3148fa4affbe20e96b7f0593c06e89"></a><!-- doxytag: member="PACC::Socket::TCPServer::mMutex" ref="a6a3148fa4affbe20e96b7f0593c06e89" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_c_c_1_1_threading_1_1_mutex.html#a6a3148fa4affbe20e96b7f0593c06e89">mMutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque structure of native mutex. <br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99e1bc07ccbe495a79af4c532227519c"></a><!-- doxytag: member="PACC::Socket::TCPServer::ServerThread" ref="a99e1bc07ccbe495a79af4c532227519c" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>ServerThread</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Portable multithreaded TCP server. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Marc Parizeau, Laboratoire de vision et syst&egrave;mes num&eacute;riques, Universit&eacute; Laval</dd></dl>
<p>This class defines an abstract multithreaded TCP server that can bind and listen to a given port using a queue of pending connection, and process these connections using a pool of pre-allocated threads. Its <code>main</code> method needs to be overloaded in order to specify the server's function. Method <code><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a60b5069fbaef5fab03916792cc46dfdc" title="Start accepting incomming connections.">TCPServer::run</a></code> is used to launch and initialize the thread pool which will process incomming connection through calls to method <code><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#af8a5779f58d2c7aa1c1e526701b48ee7" title="Main function of server.">TCPServer::main</a></code>. A running server may be halted through a call to method <code><a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a5f8d28a0c765c78701ce8932242db84e" title="Stop accepting incomming connections.">TCPServer::halt</a></code>.</p>
<p>Any error during initialization raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. Exceptions during connections are first reported through std::cerr, and then ignored. </p>

<p>Definition at line <a class="el" href="_t_c_p_server_8hpp_source.html#l00081">81</a> of file <a class="el" href="_t_c_p_server_8hpp_source.html">TCPServer.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae38de551129eb860ed8ebba741637169"></a><!-- doxytag: member="PACC::Socket::TCPServer::TCPServer" ref="ae38de551129eb860ed8ebba741637169" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Socket::TCPServer::TCPServer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an uninitialized default server. </p>
<p>Upon return, the server is not binded to any port, nor listening to any connections. To initialize such a server the user must first call methods <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#afa9967ccc64a9b3bbb4f2184d1fb1ff6" title="Bind server to port number inPortNumber.">TCPServer::bind</a> and <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a3971dab0f695f1bd6b8dabc391a9b5ef" title="Listen for at least inMinPending pending connections.">TCPServer::listen</a> before calling <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a60b5069fbaef5fab03916792cc46dfdc" title="Start accepting incomming connections.">TCPServer::run</a>. This is the power user constructor!</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>If the user runs the server without binding and listening to a port, it will never accept any connection nor raise any error. Also note that this method calls the <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#afbd9175d5265732474d0996f99faf9fe" title="Set default server options.">TCPServer::setDefaultOptions</a> method. </dd></dl>

<p>Definition at line <a class="el" href="_t_c_p_server_8cpp_source.html#l00090">90</a> of file <a class="el" href="_t_c_p_server_8cpp_source.html">TCPServer.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00091"></a>00091 {
<a name="l00092"></a>00092     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#afbd9175d5265732474d0996f99faf9fe" title="Set default server options.">setDefaultOptions</a>();
<a name="l00093"></a>00093 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a729c544d752d388869ca32f2df3d8c2a"></a><!-- doxytag: member="PACC::Socket::TCPServer::TCPServer" ref="a729c544d752d388869ca32f2df3d8c2a" args="(unsigned int inPortNumber, unsigned int inMinPending=10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Socket::TCPServer::TCPServer </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inPortNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inMinPending</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a server that binds to port <code>inPortNumber</code> with a queue of <code>inMinPending</code> connections. </p>
<p>Upon return, the server is binded and listening to port <code>inPortNumber</code> using a queue of <code>inMinPending</code> pending connections. Note that the exact length of this queue may be operating system dependent (experience has shown that it is usually longer than specified on macosx and linux). For the server to start accepting these connections, the user must call method <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a60b5069fbaef5fab03916792cc46dfdc" title="Start accepting incomming connections.">TCPServer::run</a>.</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a> (for example, if the requested port number is unavailable). </p>

<p>Definition at line <a class="el" href="_t_c_p_server_8cpp_source.html#l00100">100</a> of file <a class="el" href="_t_c_p_server_8cpp_source.html">TCPServer.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00101"></a>00101 {
<a name="l00102"></a>00102     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#afbd9175d5265732474d0996f99faf9fe" title="Set default server options.">setDefaultOptions</a>();
<a name="l00103"></a>00103     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#afa9967ccc64a9b3bbb4f2184d1fb1ff6" title="Bind server to port number inPortNumber.">Port::bind</a>(inPortNumber);
<a name="l00104"></a>00104     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a3971dab0f695f1bd6b8dabc391a9b5ef" title="Listen for at least inMinPending pending connections.">Port::listen</a>(inMinPending);
<a name="l00105"></a>00105 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa998a4b72d88860d30496f31af5e36fa"></a><!-- doxytag: member="PACC::Socket::TCPServer::~TCPServer" ref="aa998a4b72d88860d30496f31af5e36fa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Socket::TCPServer::~TCPServer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the server thread pool. </p>
<p>Assuming that the caller has halted the server (using <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a5f8d28a0c765c78701ce8932242db84e" title="Stop accepting incomming connections.">TCPServer::halt</a>) and waited for the server threads to complete any pending connections (using <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#ad703bbaa6f6220a338e78ebcc28b9f60" title="Wait for server termination.">TCPServer::wait</a>), this method deletes the allocated thread pool. In debug mode, if any thread is found still running, the method aborts the application with a descriptive fatal error message.</p>
<p>A good strategy is to always define a destructor in the derived server class, and to make this destructor waits for server termination. For instance: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyServer : <span class="keyword">public</span> Socket::<a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#ae38de551129eb860ed8ebba741637169" title="Construct an uninitialized default server.">TCPServer</a> {
    ...
    ~MyServer(<span class="keywordtype">void</span>) {<a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#ad703bbaa6f6220a338e78ebcc28b9f60" title="Wait for server termination.">wait</a>();}
    ...
};
</pre></div><dl class="attention"><dt><b>Attention:</b></dt><dd>If the destructor in the derived server class (e.g. MyServer above) does not wait for thread termination, the potential hazardous situation is that the runtime system will have deleted all of its members before calling this destructor (in C++, class destructors are called in reversed sequence). Thus, a still running server thread could access deleted members with unpredictable end unexpected results. Moreover, if a new connection is accepted in the meantime, then the running thread will crash the application with a cryptic "pure virtual method called" message that results from a call to a main method that no longer exists in this object. So beware! </dd></dl>

<p>Definition at line <a class="el" href="_t_c_p_server_8cpp_source.html#l00121">121</a> of file <a class="el" href="_t_c_p_server_8cpp_source.html">TCPServer.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00122"></a>00122 {
<a name="l00123"></a>00123     <span class="comment">// delete every thread after making sure that they have stopped running</span>
<a name="l00124"></a>00124     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>.size(); ++i) {
<a name="l00125"></a>00125         <a class="code" href="_assert_8hpp.html#a43076e2e7de93ea104d52e57ad81e136" title="Unix assert macro.">PACC_AssertM</a>(!<a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>[i]-&gt;isRunning(), <span class="stringliteral">&quot;Destructor called without first halting the server and waiting for the threads to terminate. Please correct the situation because it is potentially very hazardous!&quot;</span>);
<a name="l00126"></a>00126         <span class="keyword">delete</span> <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>[i];
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>.clear();
<a name="l00129"></a>00129 }
</pre></div></p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae7bac9446a6f94245a4d9f15a23d3847"></a><!-- doxytag: member="PACC::Socket::TCPServer::accept" ref="ae7bac9446a6f94245a4d9f15a23d3847" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Socket::Port::accept </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept connection on bound port. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00089">89</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00090"></a>00090 {
<a name="l00091"></a>00091     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::accept() invalid socket&quot;</span>);
<a name="l00092"></a>00092     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00093"></a>00093     socklen_t lSize = <span class="keyword">sizeof</span>(lSock);
<a name="l00094"></a>00094     <span class="keywordtype">int</span> lDescriptor =<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#ae7bac9446a6f94245a4d9f15a23d3847" title="Accept connection on bound port."> ::accept</a>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (<span class="keyword">struct </span>sockaddr*) &amp;lSock, &amp;lSize);
<a name="l00095"></a>00095     <span class="keywordflow">if</span>(lDescriptor &lt; 0) {
<a name="l00096"></a>00096         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::acept() unable to accept connection&quot;</span>);
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098     <span class="keywordflow">return</span> lDescriptor;
<a name="l00099"></a>00099 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3d153806aea01830530f4ea04c0f338b"></a><!-- doxytag: member="PACC::Socket::TCPServer::convertToNativeOption" ref="a3d153806aea01830530f4ea04c0f338b" args="(Option inName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Socket::Port::convertToNativeOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Socket::Option</a>&nbsp;</td>
          <td class="paramname"> <em>inName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert socket option <code>inName</code> to native socket option code. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00166">166</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00167"></a>00167 {
<a name="l00168"></a>00168     <span class="keywordtype">int</span> lNativeOpt;
<a name="l00169"></a>00169     <span class="keywordflow">switch</span>(inName) {
<a name="l00170"></a>00170         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fad094f0c703765e462059f4c8a92b7292" title="Keep connection alive.">eKeepAlive</a>: lNativeOpt = SO_KEEPALIVE; <span class="keywordflow">break</span>;
<a name="l00171"></a>00171         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fae0dcf7836a0dbfe6de1d8de7f5c1aa47" title="Time to linger on close (in seconds).">eLinger</a>: lNativeOpt = SO_LINGER; <span class="keywordflow">break</span>;
<a name="l00172"></a>00172         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>: lNativeOpt = TCP_NODELAY; <span class="keywordflow">break</span>;
<a name="l00173"></a>00173         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faef38bf8dd0269ab968548ce17aeba64a" title="Socket protocol type">eProtocolType</a>: lNativeOpt = SO_TYPE; <span class="keywordflow">break</span>;
<a name="l00174"></a>00174         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa1839a506c945f06a24ded765b5ece67a" title="Allow reuse of a TCP address without delay.">eReuseAddress</a>: lNativeOpt = SO_REUSEADDR; <span class="keywordflow">break</span>;
<a name="l00175"></a>00175         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>: lNativeOpt = SO_RCVBUF; <span class="keywordflow">break</span>;
<a name="l00176"></a>00176         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faf5ee4bfe5d2341a7875edb7ff10ff1c2" title="Size of send buffer (in number of chars).">eSendBufSize</a>: lNativeOpt = SO_SNDBUF; <span class="keywordflow">break</span>;
<a name="l00177"></a>00177         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">eRecvTimeOut</a>: lNativeOpt = SO_RCVTIMEO; <span class="keywordflow">break</span>;
<a name="l00178"></a>00178         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">eSendTimeOut</a>: lNativeOpt = SO_SNDTIMEO; <span class="keywordflow">break</span>;
<a name="l00179"></a>00179         <span class="keywordflow">default</span>: <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::convertToNativeOption() unknown socket option&quot;</span>);
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181     <span class="keywordflow">return</span> lNativeOpt;
<a name="l00182"></a>00182 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a41ecb8dddf4441185f0b893d9dce5514"></a><!-- doxytag: member="PACC::Socket::TCPServer::getPeerAddress" ref="a41ecb8dddf4441185f0b893d9dce5514" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Socket::Address</a> Socket::Port::getPeerAddress </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return address of peer socket host. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00187">187</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00188"></a>00188 {
<a name="l00189"></a>00189     <span class="keyword">struct </span>sockaddr lSock;
<a name="l00190"></a>00190     socklen_t lLength = <span class="keyword">sizeof</span>(lSock);
<a name="l00191"></a>00191     <span class="keywordflow">if</span>(::getpeername(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lSock, &amp;lLength) != 0) {
<a name="l00192"></a>00192         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2af3e825a5abff84418308ed3ed6dd0c55" title="Socket is not connected.">eNotConnected</a>, <span class="stringliteral">&quot;Port::getPeerAddress() unable to retrieve peer address&quot;</span>);
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194     <span class="keywordflow">return</span> Address(ntohs(((sockaddr_in*)&amp;lSock)-&gt;sin_port), inet_ntoa(((sockaddr_in*)&amp;lSock)-&gt;sin_addr));
<a name="l00195"></a>00195 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaa2f2ae4b67d2dd00a0933f60c784e54"></a><!-- doxytag: member="PACC::Socket::TCPServer::getProtocol" ref="aaa2f2ae4b67d2dd00a0933f60c784e54" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___socket.html#ga3109f582afef6bc8e60e4bbf26fc0ac6">Socket::Protocol</a> Socket::Port::getProtocol </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return protocol of socket. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00200">200</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00201"></a>00201 {
<a name="l00202"></a>00202     
<a name="l00203"></a>00203     <span class="keywordtype">int</span> lProtocol = (int) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a758a6afe098539a362de79a86b5f1f1d" title="Return value of socket option inName.">getSockOpt</a>(<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faef38bf8dd0269ab968548ce17aeba64a" title="Socket protocol type">eProtocolType</a>);
<a name="l00204"></a>00204     <span class="keywordflow">if</span>(lProtocol == SOCK_STREAM) <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a058e23bb541cf7bdc7f6975d987c477d" title="Transfer Control Protocol.">eTCP</a>;
<a name="l00205"></a>00205     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lProtocol == SOCK_DGRAM) <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a9caf36aa3cd32acd779c55f0f8e1ff54" title="User Datagram Protocol.">eUDP</a>;
<a name="l00206"></a>00206     <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6aa028e8075f4cfd5365f252d682f1f7ab" title="Other protocol.">eOther</a>;
<a name="l00207"></a>00207 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4abe927d07cf69d1048992c6c9ce8452"></a><!-- doxytag: member="PACC::Socket::TCPServer::getSockAddress" ref="a4abe927d07cf69d1048992c6c9ce8452" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Socket::Address</a> Socket::Port::getSockAddress </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return address of socket host. </p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00212">212</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00213"></a>00213 {
<a name="l00214"></a>00214     <span class="keyword">struct </span>sockaddr lSock;
<a name="l00215"></a>00215     socklen_t lLength = <span class="keyword">sizeof</span>(lSock);
<a name="l00216"></a>00216     <span class="keywordflow">if</span>(::getsockname(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lSock, &amp;lLength) != 0) {
<a name="l00217"></a>00217         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::getSockAddress() unable to retrieve socket address&quot;</span>);
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219     <span class="keywordflow">return</span> Address(ntohs(((sockaddr_in*)&amp;lSock)-&gt;sin_port), inet_ntoa(((sockaddr_in*)&amp;lSock)-&gt;sin_addr));
<a name="l00220"></a>00220 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a758a6afe098539a362de79a86b5f1f1d"></a><!-- doxytag: member="PACC::Socket::TCPServer::getSockOpt" ref="a758a6afe098539a362de79a86b5f1f1d" args="(Option inName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Socket::Port::getSockOpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Socket::Option</a>&nbsp;</td>
          <td class="paramname"> <em>inName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return value of socket option <code>inName</code>. </p>
<p>Valid options are: </p>
<ul>
<li>
eKeepAlive: keep connection alive (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eLinger: time to linger on close (in seconds, <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eNoDelay: disable the Nagle algorithm for packet coalescing (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eProtocolType: socket protocol type </li>
<li>
eReuseAddress: allow reuse of address </li>
<li>
eRecvBufSize: size of receive buffer (in bytes) </li>
<li>
eSendBufSize: size of send buffer (in bytes) </li>
<li>
eRecvTimeOut: time out period for receive operations (in seconds) </li>
<li>
eSendTimeOut: time out period for send operations (in seconds) </li>
</ul>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00237">237</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00238"></a>00238 {
<a name="l00239"></a>00239     <span class="keywordtype">double</span> lValue;
<a name="l00240"></a>00240     <span class="keywordtype">int</span> lBuffer[2] = {0, 0};
<a name="l00241"></a>00241     socklen_t lSize = <span class="keyword">sizeof</span>(lBuffer);
<a name="l00242"></a>00242     <span class="keywordflow">if</span>(::getsockopt(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (inName==<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>?IPPROTO_TCP:SOL_SOCKET), <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a3d153806aea01830530f4ea04c0f338b" title="Convert socket option inName to native socket option code.">convertToNativeOption</a>(inName), (<span class="keywordtype">char</span>*)lBuffer, &amp;lSize) != 0)
<a name="l00243"></a>00243     {
<a name="l00244"></a>00244         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::getSockOpt() unable to retrieve socket option&quot;</span>);
<a name="l00245"></a>00245     }
<a name="l00246"></a>00246     <span class="keywordflow">switch</span>(inName) {
<a name="l00247"></a>00247         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fad094f0c703765e462059f4c8a92b7292" title="Keep connection alive.">eKeepAlive</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa1839a506c945f06a24ded765b5ece67a" title="Allow reuse of a TCP address without delay.">eReuseAddress</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faf5ee4bfe5d2341a7875edb7ff10ff1c2" title="Size of send buffer (in number of chars).">eSendBufSize</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faef38bf8dd0269ab968548ce17aeba64a" title="Socket protocol type">eProtocolType</a>:
<a name="l00248"></a>00248             lValue = lBuffer[0];
<a name="l00249"></a>00249             <span class="keywordflow">break</span>;
<a name="l00250"></a>00250         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fae0dcf7836a0dbfe6de1d8de7f5c1aa47" title="Time to linger on close (in seconds).">eLinger</a>:
<a name="l00251"></a>00251         {
<a name="l00252"></a>00252             <span class="comment">// warning: the linger structure is not the same size on windows and unix!</span>
<a name="l00253"></a>00253             <span class="keyword">struct </span>linger* lPtr = (<span class="keyword">struct </span>linger*) lBuffer;
<a name="l00254"></a>00254             <span class="keywordflow">if</span>(lPtr-&gt;l_onoff) lValue = lPtr-&gt;l_linger;
<a name="l00255"></a>00255             <span class="keywordflow">else</span> lValue = -1;
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257             <span class="keywordflow">break</span>;
<a name="l00258"></a>00258         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">eRecvTimeOut</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">eSendTimeOut</a>:
<a name="l00259"></a>00259 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>            <span class="comment">// on windows, timeout is specified in milliseconds</span>
<a name="l00261"></a>00261             lValue = (float)lBuffer[0]/1000.;
<a name="l00262"></a>00262 <span class="preprocessor">#else</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span>            <span class="comment">// on unix, timeout is specified with timeval structure</span>
<a name="l00264"></a>00264             {
<a name="l00265"></a>00265                 <span class="keyword">struct </span>timeval* lPtr = (<span class="keyword">struct </span>timeval*) lBuffer;
<a name="l00266"></a>00266                 lValue = (float)lPtr-&gt;tv_sec + lPtr-&gt;tv_usec/1000000.;
<a name="l00267"></a>00267             }
<a name="l00268"></a>00268 <span class="preprocessor">#endif</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span>                <span class="keywordflow">break</span>;
<a name="l00270"></a>00270         <span class="keywordflow">default</span>:
<a name="l00271"></a>00271             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::getSockOpt() unknown socket option&quot;</span>);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273     <span class="keywordflow">return</span> lValue;
<a name="l00274"></a>00274 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5f8d28a0c765c78701ce8932242db84e"></a><!-- doxytag: member="PACC::Socket::TCPServer::halt" ref="a5f8d28a0c765c78701ce8932242db84e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::TCPServer::halt </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop accepting incomming connections. </p>
<p>This method requests cancellation for every allocated server thread in order to make them stop accepting new connections. Threads termination is asynchronous; they terminate either after they complete their current connection or after the <code>inMaxHaltDelay</code> delay that was specified in the call to <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a60b5069fbaef5fab03916792cc46dfdc" title="Start accepting incomming connections.">TCPServer::run</a>.</p>
<p>In order to minimize halting delay, whenever it is safe to terminate a connection from within <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#af8a5779f58d2c7aa1c1e526701b48ee7" title="Main function of server.">TCPServer::main</a>, the user should make calls to method <a class="el" href="class_p_a_c_c_1_1_socket_1_1_server_thread.html#a11a19c8fd6b0beaa52703127a41f6d39">ServerThread::shouldTerminate</a> to determine whether it should close the connection and terminate execution early. </p>

<p>Definition at line <a class="el" href="_t_c_p_server_8cpp_source.html#l00136">136</a> of file <a class="el" href="_t_c_p_server_8cpp_source.html">TCPServer.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00137"></a>00137 {
<a name="l00138"></a>00138     <span class="comment">// request cancellation for all threads</span>
<a name="l00139"></a>00139     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>.size(); ++i) {
<a name="l00140"></a>00140         <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>[i]-&gt;lock();
<a name="l00141"></a>00141         <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>[i]-&gt;cancel();
<a name="l00142"></a>00142         <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>[i]-&gt;unlock();
<a name="l00143"></a>00143     }
<a name="l00144"></a>00144 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af8a5779f58d2c7aa1c1e526701b48ee7"></a><!-- doxytag: member="PACC::Socket::TCPServer::main" ref="af8a5779f58d2c7aa1c1e526701b48ee7" args="(int inDescriptor, const ServerThread *inThread)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PACC::Socket::TCPServer::main </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>inDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_c_c_1_1_socket_1_1_server_thread.html">ServerThread</a> *&nbsp;</td>
          <td class="paramname"> <em>inThread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main function of server. </p>
<p>Method should start by constructing an adequate protocol for socket descriptor <code>inDescriptor</code>. For instance, to make an echo server for the <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> protocol: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>PACC;
<span class="keyword">class </span>EchoTCP : <span class="keyword">public</span> Socket::<a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#ae38de551129eb860ed8ebba741637169" title="Construct an uninitialized default server.">TCPServer</a> {
 <span class="keyword">public</span>:
    EchoTCP(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inPort, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inMinPending) 
     : Socket::<a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#ae38de551129eb860ed8ebba741637169" title="Construct an uninitialized default server.">TCPServer</a>(inPort, inMinPending) {}
    ~EchoTCP(<span class="keywordtype">void</span>) {<a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#ad703bbaa6f6220a338e78ebcc28b9f60" title="Wait for server termination.">wait</a>();}
                
    <span class="keywordtype">void</span> <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#af8a5779f58d2c7aa1c1e526701b48ee7" title="Main function of server.">main</a>(<span class="keywordtype">int</span> inDescriptor, <span class="keyword">const</span> ServerThread* inThread) {
        <span class="keywordflow">try</span> {
            Socket::TCP lSocket(inDescriptor);
            lSocket.setSockOpt(<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">eRecvTimeOut</a>, 10);
            lSocket.setSockOpt(<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">eSendTimeOut</a>, 1.5);
            <span class="comment">// loop until thread receives a cancellation request</span>
            <span class="keywordflow">while</span>(!inThread-&gt;shouldTerminate()) {
                <span class="keywordtype">string</span> lMessage;
                <span class="comment">// receive message from client</span>
                lSocket.receiveMessage(lMessage);
                <span class="comment">// echo message to client</span>
                lSocket.sendMessage(lMessage);
            }
        } <span class="keywordflow">catch</span>(<span class="keyword">const</span> Socket::Exception&amp; inError) {
            <span class="comment">// output error message and exit</span>
            cerr &lt;&lt; inError.getMessage() &lt;&lt; endl;
        }
    }
};
</pre></div><p> In this example, the server constructs a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> socket, sets time outs of respectivelly 10 and 1.5 seconds for receives and sends, and enters a loop where every received message is echoed to the client. This loop will exit either when method <a class="el" href="class_p_a_c_c_1_1_socket_1_1_server_thread.html#a11a19c8fd6b0beaa52703127a41f6d39">ServerThread::shouldTerminate</a> returns true (typically after the server receives a halt request), when the client closes the connection (exception <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> will be raised), or when a time out expires (exception <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> will be raised). Note that the socket for this connection will be closed automatically by its destructor when control exits the try-clause. </p>

</div>
</div>
<a class="anchor" id="a0180add2f0a595baeae502607a74ea64"></a><!-- doxytag: member="PACC::Socket::TCPServer::open" ref="a0180add2f0a595baeae502607a74ea64" args="(Protocol=eTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga3109f582afef6bc8e60e4bbf26fc0ac6">Socket::Protocol</a>&nbsp;</td>
          <td class="paramname"> <em>inProtocol</em> = <code>eTCP</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open new socket descriptor. </p>
<p>A socket descriptor is allocated using the protocol determined by parameter <code>inProtocol</code>. The <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> protocol is selected with value <code>eTCP</code> (default), while the <a class="el" href="class_p_a_c_c_1_1_socket_1_1_u_d_p.html" title="Portable UDP client.">UDP</a> protocol is chosen with value <code>eUDP</code>.</p>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00291">291</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00292"></a>00292 {
<a name="l00293"></a>00293 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">bool</span> lInitialized = <span class="keyword">false</span>;
<a name="l00295"></a>00295     <span class="keywordflow">if</span>(!lInitialized) {
<a name="l00296"></a>00296         WSADATA wsdata;
<a name="l00297"></a>00297         <span class="keywordflow">if</span> (WSAStartup(MAKEWORD(2,2), &amp;wsdata) != 0) {
<a name="l00298"></a>00298             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::open() failed to load WinSock2&quot;</span>);
<a name="l00299"></a>00299         }
<a name="l00300"></a>00300         lInitialized = <span class="keyword">true</span>;
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302 <span class="preprocessor">#endif</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span>    <span class="comment">// first close socket if already open</span>
<a name="l00304"></a>00304     <span class="keywordflow">if</span>(!INVALID_SOCKET) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00305"></a>00305     <span class="comment">// select protocol and create new socket descriptor</span>
<a name="l00306"></a>00306     <span class="keywordflow">if</span>(inProtocol == <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a058e23bb541cf7bdc7f6975d987c477d" title="Transfer Control Protocol.">eTCP</a>) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> = ::socket(AF_INET, SOCK_STREAM, 0);
<a name="l00307"></a>00307     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(inProtocol == <a class="code" href="group___socket.html#gga3109f582afef6bc8e60e4bbf26fc0ac6a9caf36aa3cd32acd779c55f0f8e1ff54" title="User Datagram Protocol.">eUDP</a>) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> = ::socket(AF_INET, SOCK_DGRAM, 0);
<a name="l00308"></a>00308     <span class="keywordflow">else</span> <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::open() unsupported socket protocol&quot;</span>);
<a name="l00309"></a>00309     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) {
<a name="l00310"></a>00310         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::open() unable to allocate socket descriptor&quot;</span>);
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa2bfb38c81fc0695d99f51cc8e7291c6"></a><!-- doxytag: member="PACC::Socket::TCPServer::receive" ref="aa2bfb38c81fc0695d99f51cc8e7291c6" args="(char *outBuffer, unsigned inMaxCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Socket::Port::receive </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>inMaxCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive data from connected socket. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of received characters.</dd></dl>
<p>This function waits until some data is received through the socket, or until the timeout period expires. The received data is returned through output parameter <code>outBuffer</code> which must be large enough to contain up to <code>inMaxCount</code> characters. Note that this ouput buffer is NOT null terminated. The function returns the effective number of read characters contained in the output buffer. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, if the other party closes the connection (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> sockets), an exception is thrown with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a>, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if nothing is received before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">Socket::eRecvTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00319">319</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00320"></a>00320 {
<a name="l00321"></a>00321     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::receive() invalid socket&quot;</span>);
<a name="l00322"></a>00322     void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00323"></a>00323     <span class="keywordtype">int</span> lRecv = ::recv(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, outBuffer, inMaxCount, 0);
<a name="l00324"></a>00324     ::signal(SIGPIPE, lPipeMethod);
<a name="l00325"></a>00325     <span class="keywordflow">if</span>(lRecv &lt; 0) {
<a name="l00326"></a>00326         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00327"></a>00327     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lRecv == 0) {
<a name="l00328"></a>00328         <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00329"></a>00329         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331     <span class="keywordflow">return</span> lRecv;
<a name="l00332"></a>00332 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abc30f2043f597dc71e7113528824b42b"></a><!-- doxytag: member="PACC::Socket::TCPServer::receiveFrom" ref="abc30f2043f597dc71e7113528824b42b" args="(char *outBuffer, unsigned inMaxCount, Address &amp;outPeer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Socket::Port::receiveFrom </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>inMaxCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outPeer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive data from unconnected socket. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of received characters .</dd></dl>
<p>This function waits until some data is received through the socket, or until the timeout period expires. The received data is returned through output parameter <code>outBuffer</code> which must be large enough to contain up to <code>inMaxCount</code> characters. Note that this ouput buffer is NOT null terminated. The function returns the effective number of read characters contained in the output buffer. The peer socket address is also returned through output parameter <code>outPeer</code>. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, if the other party closes the connection (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> sockets), an exception is thrown with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a>, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if nothing is received before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">Socket::eRecvTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00339">339</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00340"></a>00340 {
<a name="l00341"></a>00341     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::receiveFrom() invalid socket&quot;</span>);
<a name="l00342"></a>00342     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00343"></a>00343     socklen_t lSize = <span class="keyword">sizeof</span>(lSock);
<a name="l00344"></a>00344     void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00345"></a>00345     <span class="keywordtype">int</span> lRecv = ::recvfrom(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, outBuffer, inMaxCount, 0, (<span class="keyword">struct </span>sockaddr*) &amp;lSock, &amp;lSize);
<a name="l00346"></a>00346     ::signal(SIGPIPE, lPipeMethod);
<a name="l00347"></a>00347     <span class="keywordflow">if</span>(lRecv &lt; 0) {
<a name="l00348"></a>00348         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00349"></a>00349     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lRecv == 0) {
<a name="l00350"></a>00350         <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::receive() operation incomplete&quot;</span>);
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352     <span class="comment">// transfer peer address</span>
<a name="l00353"></a>00353     outPeer = Address(ntohs(lSock.sin_port), inet_ntoa(lSock.sin_addr));
<a name="l00354"></a>00354     <span class="keywordflow">return</span> lRecv;
<a name="l00355"></a>00355 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7213a4475b86817b0396e6cf87c917d1"></a><!-- doxytag: member="PACC::Socket::TCPServer::receiveMessage" ref="a7213a4475b86817b0396e6cf87c917d1" args="(string &amp;outMessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::TCP::receiveMessage </td>
          <td>(</td>
          <td class="paramtype">string &amp;&nbsp;</td>
          <td class="paramname"> <em>outMessage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive string message from connected (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a>) server. </p>
<p>This function waits for a message from the connected peer socket, or until time out. It returns the received message through output parameter <code>OutMessage</code>. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party before message end, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the timeout period expires before reception of any message. The timeout period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">Socket::eRecvTimeOut</a>. </p>

<p>Reimplemented in <a class="el" href="class_p_a_c_c_1_1_socket_1_1_cafe.html#a05f1172f301e049288c059e1b7353544">PACC::Socket::Cafe</a>.</p>

<p>Definition at line <a class="el" href="_t_c_p_8cpp_source.html#l00045">45</a> of file <a class="el" href="_t_c_p_8cpp_source.html">TCP.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00046"></a>00046 {
<a name="l00047"></a>00047     <span class="comment">// reserve adequate buffer space (if needed)</span>
<a name="l00048"></a>00048     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lRecvBufSize = (<span class="keywordtype">unsigned</span> int) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a758a6afe098539a362de79a86b5f1f1d" title="Return value of socket option inName.">getSockOpt</a>(<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>);
<a name="l00049"></a>00049     <span class="keywordflow">if</span>(outMessage.size() &lt; lRecvBufSize) outMessage.resize(lRecvBufSize);
<a name="l00050"></a>00050     <span class="comment">// receive message</span>
<a name="l00051"></a>00051     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lRecv = <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#aa2bfb38c81fc0695d99f51cc8e7291c6" title="Receive data from connected socket.">receive</a>(&amp;outMessage[0], outMessage.size());
<a name="l00052"></a>00052     <span class="comment">// resize output string</span>
<a name="l00053"></a>00053     outMessage.resize(lRecv);
<a name="l00054"></a>00054 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a60b5069fbaef5fab03916792cc46dfdc"></a><!-- doxytag: member="PACC::Socket::TCPServer::run" ref="a60b5069fbaef5fab03916792cc46dfdc" args="(unsigned int inThreads, double inMaxHaltDelay=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::TCPServer::run </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inMaxHaltDelay</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start accepting incomming connections. </p>
<p>Upon return, this method has added <code>inThreads</code> new threads to the server's thread pool. These new threads start accepting incomming connections immediately, and until some thread calls method <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a5f8d28a0c765c78701ce8932242db84e" title="Stop accepting incomming connections.">TCPServer::halt</a>. Incomming connections are processed through calls to virtual function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#af8a5779f58d2c7aa1c1e526701b48ee7" title="Main function of server.">TCPServer::main</a> which needs to be overloaded in a sub-class. Halt requests will be honored at least every <code>inMaxHaltDelay</code> seconds (default=1), or after a connection terminates.</p>
<p>This method can be called any number of times to increase the size of the thread pool.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>if the server was constructed using the default constructor, methods <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#afa9967ccc64a9b3bbb4f2184d1fb1ff6" title="Bind server to port number inPortNumber.">TCPServer::bind</a> and <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a3971dab0f695f1bd6b8dabc391a9b5ef" title="Listen for at least inMinPending pending connections.">TCPServer::listen</a> must be called prior to calling this method. Otherwise, no incomming connection will ever be accepted, nor any error raised. Any error during the initialization of the new threads raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </dd></dl>

<p>Definition at line <a class="el" href="_t_c_p_server_8cpp_source.html#l00167">167</a> of file <a class="el" href="_t_c_p_server_8cpp_source.html">TCPServer.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00168"></a>00168 {
<a name="l00169"></a>00169     <span class="comment">// allocate new threads</span>
<a name="l00170"></a>00170     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inThreads; ++i) {
<a name="l00171"></a>00171         ServerThread* lThread = <span class="keyword">new</span> ServerThread(<span class="keyword">this</span>, inMaxHaltDelay);
<a name="l00172"></a>00172         <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>.push_back(lThread);
<a name="l00173"></a>00173     }
<a name="l00174"></a>00174 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7e0f88dff3eacee95675eb0fcc9cc740"></a><!-- doxytag: member="PACC::Socket::TCPServer::send" ref="a7e0f88dff3eacee95675eb0fcc9cc740" args="(const char *inBuffer, unsigned int inCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::send </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send data to connected socket. </p>
<p>This function sends to its peer socket the <code>inCount</code> characters of data contained in buffer <code>inBuffer</code> (socket is assumed connected). Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party during message transmission, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the message cannot be sent before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">Socket::eSendTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00360">360</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00361"></a>00361 {
<a name="l00362"></a>00362     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::send() invalid socket&quot;</span>);
<a name="l00363"></a>00363     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lTotalSent = 0;
<a name="l00364"></a>00364     <span class="comment">// send all data</span>
<a name="l00365"></a>00365     <span class="keywordflow">while</span>(lTotalSent &lt; inCount) {
<a name="l00366"></a>00366         void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00367"></a>00367         <span class="keywordtype">int</span> lSent =<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket."> ::send</a>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, inBuffer+lTotalSent, inCount-lTotalSent, 0);
<a name="l00368"></a>00368         ::signal(SIGPIPE, lPipeMethod);
<a name="l00369"></a>00369         <span class="keywordflow">if</span>(lSent &lt; 0) {
<a name="l00370"></a>00370             <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00371"></a>00371         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lSent &lt; 1) {
<a name="l00372"></a>00372             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00373"></a>00373             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375         lTotalSent += lSent;
<a name="l00376"></a>00376     }
<a name="l00377"></a>00377 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adc5fb826b4851b5314c9248ed94620e9"></a><!-- doxytag: member="PACC::Socket::TCPServer::sendMessage" ref="adc5fb826b4851b5314c9248ed94620e9" args="(const string &amp;inMessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::TCP::sendMessage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>inMessage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send string message to connected (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a>) server. </p>
<p>This function sends message string <code>inMessage</code> to the connected peer socket. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party during message transmission, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the message cannot be sent before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">Socket::eSendTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_t_c_p_8cpp_source.html#l00060">60</a> of file <a class="el" href="_t_c_p_8cpp_source.html">TCP.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00061"></a>00061 {
<a name="l00062"></a>00062     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a7e0f88dff3eacee95675eb0fcc9cc740" title="Send data to connected socket.">send</a>(inMessage.data(), inMessage.size());
<a name="l00063"></a>00063 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac9c7959ca0afef4d5fa57a28fba3b4d8"></a><!-- doxytag: member="PACC::Socket::TCPServer::sendTo" ref="ac9c7959ca0afef4d5fa57a28fba3b4d8" args="(const char *inBuffer, unsigned int inCount, const Address &amp;inPeer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::sendTo </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_c_c_1_1_socket_1_1_address.html">Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inPeer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send data to unconnected socket. </p>
<p>This function sends to peer <code>inPeer</code> the data contained in buffer <code>inBuffer</code> (total of <code>inCount</code> characters). Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. For instance, it throws an exception with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">Socket::eConnectionClosed</a> if the connection is closed by the other party during message transmission, or with code <a class="el" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac2e06bbc54ceed2a95904599d29211e1" title="Time out was reached for operation (receive &amp; send).">Socket::eTimeOut</a> if the message cannot be sent before the time out period expires. The time out period can be changed using function <a class="el" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">Port::setSockOpt</a> with parameter <a class="el" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">Socket::eSendTimeOut</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00382">382</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00383"></a>00383 {
<a name="l00384"></a>00384     <span class="keywordflow">if</span>(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a> == INVALID_SOCKET) <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2a6e3240acb59bfd4435c4029bc64852d4" title="Invalid socket descriptor (socket).">eBadDescriptor</a>, <span class="stringliteral">&quot;Port::sendTo() invalid socket&quot;</span>);
<a name="l00385"></a>00385     <span class="keyword">struct </span>sockaddr_in lSock;
<a name="l00386"></a>00386     lSock.sin_family = AF_INET;
<a name="l00387"></a>00387     lSock.sin_port = htons(inPeer.getPortNumber());
<a name="l00388"></a>00388     lSock.sin_addr.s_addr = inet_addr(inPeer.getIPAddress().c_str());
<a name="l00389"></a>00389     memset(&amp;lSock.sin_zero, 0, 8);
<a name="l00390"></a>00390     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lTotalSent = 0;
<a name="l00391"></a>00391     <span class="comment">// send all data</span>
<a name="l00392"></a>00392     <span class="keywordflow">while</span>(lTotalSent &lt; inCount) {
<a name="l00393"></a>00393         void(*lPipeMethod)(int) = ::signal(SIGPIPE, SIG_IGN);
<a name="l00394"></a>00394         <span class="keywordtype">int</span> lSent = ::sendto(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, inBuffer+lTotalSent, inCount-lTotalSent, 0, (<span class="keyword">struct </span>sockaddr*) &amp;lSock, <span class="keyword">sizeof</span>(lSock));
<a name="l00395"></a>00395         ::signal(SIGPIPE, lPipeMethod);
<a name="l00396"></a>00396         <span class="keywordflow">if</span>(lSent &lt; 0) {
<a name="l00397"></a>00397             <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00398"></a>00398         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lSent &lt; 1) {
<a name="l00399"></a>00399             <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a925504388559b18962d2b8b5e58c8289" title="Close socket port.">close</a>();
<a name="l00400"></a>00400             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2ac8286c76cc7016300f8f3ded3358ebef" title="Connection was closed (or broken) by other party.">eConnectionClosed</a>, <span class="stringliteral">&quot;Port::send() operation incomplete&quot;</span>);
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402         lTotalSent += lSent;
<a name="l00403"></a>00403     }
<a name="l00404"></a>00404 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afbd9175d5265732474d0996f99faf9fe"></a><!-- doxytag: member="PACC::Socket::TCPServer::setDefaultOptions" ref="afbd9175d5265732474d0996f99faf9fe" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::TCPServer::setDefaultOptions </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set default server options. </p>
<p>Default options are: </p>
<ul>
<li>
eReuseAddress = true </li>
<li>
eLinger = 10 seconds </li>
</ul>
<p>Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_t_c_p_server_8cpp_source.html#l00154">154</a> of file <a class="el" href="_t_c_p_server_8cpp_source.html">TCPServer.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00155"></a>00155 {
<a name="l00156"></a>00156     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">setSockOpt</a>(<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa1839a506c945f06a24ded765b5ece67a" title="Allow reuse of a TCP address without delay.">eReuseAddress</a>, <span class="keyword">true</span>);
<a name="l00157"></a>00157     <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a0f8abcce1ad096ea617c88b4d366e367" title="Set socket option inName to value inValue.">setSockOpt</a>(<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fae0dcf7836a0dbfe6de1d8de7f5c1aa47" title="Time to linger on close (in seconds).">eLinger</a>, 10);
<a name="l00158"></a>00158 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0f8abcce1ad096ea617c88b4d366e367"></a><!-- doxytag: member="PACC::Socket::TCPServer::setSockOpt" ref="a0f8abcce1ad096ea617c88b4d366e367" args="(Option inName, double inValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::Port::setSockOpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___socket.html#ga5453de5499a4872aea2534d6e052ba1f">Option</a>&nbsp;</td>
          <td class="paramname"> <em>inName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set socket option <code>inName</code> to value <code>inValue</code>. </p>
<p>Options are: </p>
<ul>
<li>
eKeepAlive: keep connection alive (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eLinger: time to linger on close (in seconds; <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eNoDelay: Disable the Nagle algorithm for packet coalescing (<a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p.html" title="Portable TCP socket client.">TCP</a> only) </li>
<li>
eReuseAddress: allow reuse of address </li>
<li>
eRecvBufSize: size of receive buffer (in bytes) </li>
<li>
eSendBufSize: size of send buffer (in bytes) </li>
<li>
eRecvTimeOut: time out period for receive operations (in seconds) </li>
<li>
eSendTimeOut: time out period for send operations (in seconds) </li>
</ul>
<p>Note that for option <code>eLinger</code>, a negative value means don't linger. For options <code>eRecvTimeOut</code> and <code>eSendTimeOut</code>, a negative or nul value means dont't timeout, and a positive value of less than 1 msec will be equivalent to 1 msec. Any error raises a <a class="el" href="class_p_a_c_c_1_1_socket_1_1_exception.html" title="Socket exception.">Socket::Exception</a>. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00420">420</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00421"></a>00421 {
<a name="l00422"></a>00422     <span class="keywordtype">int</span> lBuffer[2] = {0, 0};
<a name="l00423"></a>00423     socklen_t lSize;
<a name="l00424"></a>00424     <span class="keywordflow">switch</span>(inName) {
<a name="l00425"></a>00425         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fad094f0c703765e462059f4c8a92b7292" title="Keep connection alive.">eKeepAlive</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa1839a506c945f06a24ded765b5ece67a" title="Allow reuse of a TCP address without delay.">eReuseAddress</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa08011ee8c01668017dd5157487654c37" title="Size of receive buffer (in number of chars).">eRecvBufSize</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1faf5ee4bfe5d2341a7875edb7ff10ff1c2" title="Size of send buffer (in number of chars).">eSendBufSize</a>:
<a name="l00426"></a>00426             lBuffer[0] = (int) inValue;
<a name="l00427"></a>00427             lSize = <span class="keyword">sizeof</span>(int);
<a name="l00428"></a>00428             <span class="keywordflow">break</span>;
<a name="l00429"></a>00429         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fae0dcf7836a0dbfe6de1d8de7f5c1aa47" title="Time to linger on close (in seconds).">eLinger</a>:
<a name="l00430"></a>00430         {
<a name="l00431"></a>00431             <span class="comment">// warning: the linger structure is not the same size on windows and unix!</span>
<a name="l00432"></a>00432             <span class="keyword">struct </span>linger* lPtr = (<span class="keyword">struct </span>linger*) lBuffer;
<a name="l00433"></a>00433 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span>            lPtr-&gt;l_onoff = (u_short) (inValue &gt;= 0);
<a name="l00435"></a>00435             lPtr-&gt;l_linger = (u_short) (inValue &gt;= 0 ? inValue : 0);
<a name="l00436"></a>00436 <span class="preprocessor">#else</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span>            lPtr-&gt;l_onoff = (int) (inValue &gt;= 0);
<a name="l00438"></a>00438             lPtr-&gt;l_linger = (int) (inValue &gt;= 0 ? inValue : 0);
<a name="l00439"></a>00439 <span class="preprocessor">#endif</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span>        }
<a name="l00441"></a>00441             lSize = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>linger);
<a name="l00442"></a>00442             <span class="keywordflow">break</span>;
<a name="l00443"></a>00443         <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa2dc574083424854591f61e035a86644b" title="Time out period for receive operations (in seconds).">eRecvTimeOut</a>: <span class="keywordflow">case</span> <a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fa9ef3cf4ff01059f3ab29a6324e85ccfe" title="Time out period for send operations (in seconds).">eSendTimeOut</a>:
<a name="l00444"></a>00444             <span class="keywordflow">if</span>(inValue &lt; 0) inValue = 0;
<a name="l00445"></a>00445             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(inValue &gt; 0 &amp;&amp; inValue &lt; 0.001) inValue = 0.001;
<a name="l00446"></a>00446 <span class="preprocessor">#ifdef PACC_SOCKET_WIN32</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span>                <span class="comment">// on windows, timeout must be specified in milliseconds</span>
<a name="l00448"></a>00448                 lBuffer[0] = (int) (1000*inValue);
<a name="l00449"></a>00449             lSize = <span class="keyword">sizeof</span>(int);
<a name="l00450"></a>00450 <span class="preprocessor">#else</span>
<a name="l00451"></a>00451 <span class="preprocessor"></span>            <span class="comment">// on unix, timeout must be specified with timeval structure</span>
<a name="l00452"></a>00452             {
<a name="l00453"></a>00453                 <span class="keyword">struct </span>timeval* lPtr = (<span class="keyword">struct </span>timeval*) lBuffer;
<a name="l00454"></a>00454                 lPtr-&gt;tv_sec = (int32_t) inValue;
<a name="l00455"></a>00455                 lPtr-&gt;tv_usec = (int32_t) ((inValue-lPtr-&gt;tv_sec)*1000000);
<a name="l00456"></a>00456                 lSize = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>timeval);
<a name="l00457"></a>00457             }
<a name="l00458"></a>00458 <span class="preprocessor">#endif</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span>                <span class="keywordflow">break</span>;
<a name="l00460"></a>00460         <span class="keywordflow">default</span>:
<a name="l00461"></a>00461             <span class="keywordflow">throw</span> Exception(<a class="code" href="group___socket.html#gga4bea4dd5de407509e2ebead1392fd0b2aa3cd531717bd60442a3e99b253dd0f53" title="Any other OS specific error.">eOtherError</a>, <span class="stringliteral">&quot;Port::setSockOpt() unsupported socket option&quot;</span>);
<a name="l00462"></a>00462     }
<a name="l00463"></a>00463     <span class="keywordflow">if</span>(::setsockopt(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, (inName==<a class="code" href="group___socket.html#gga5453de5499a4872aea2534d6e052ba1fab326a79f6b50c51a0a81bf793bef57c4" title="Disable the Nagle algorithm for packet coalescing.">eNoDelay</a>?IPPROTO_TCP:SOL_SOCKET), <a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a3d153806aea01830530f4ea04c0f338b" title="Convert socket option inName to native socket option code.">convertToNativeOption</a>(inName), (<span class="keywordtype">char</span>*)lBuffer, lSize) != 0)
<a name="l00464"></a>00464     {
<a name="l00465"></a>00465         <span class="keywordflow">throw</span> Exception(ErrNo, <span class="stringliteral">&quot;Port::setSockOpt() unable to set socket option&quot;</span>);
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad703bbaa6f6220a338e78ebcc28b9f60"></a><!-- doxytag: member="PACC::Socket::TCPServer::wait" ref="ad703bbaa6f6220a338e78ebcc28b9f60" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::TCPServer::wait </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for server termination. </p>
<p>This method will wait for the termination of every server thread. If method <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a5f8d28a0c765c78701ce8932242db84e" title="Stop accepting incomming connections.">TCPServer::halt</a> was previously executed, then the server threads will terminate after the longer of either the time required to complete their current connections or the <code>inMaxHaltDelay</code> delay that was specified in the call to <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a60b5069fbaef5fab03916792cc46dfdc" title="Start accepting incomming connections.">TCPServer::run</a>. Otherwise, they will not terminate until another thread calls the <a class="el" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a5f8d28a0c765c78701ce8932242db84e" title="Stop accepting incomming connections.">TCPServer::halt</a> method. </p>

<p>Definition at line <a class="el" href="_t_c_p_server_8cpp_source.html#l00179">179</a> of file <a class="el" href="_t_c_p_server_8cpp_source.html">TCPServer.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00180"></a>00180 {
<a name="l00181"></a>00181     <span class="comment">// wait for the termination of every server thread</span>
<a name="l00182"></a>00182     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>.size(); ++i) {
<a name="l00183"></a>00183         <span class="comment">// do not wait for one self!</span>
<a name="l00184"></a>00184         <span class="keywordflow">if</span>(!<a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>[i]-&gt;isSelf()) <a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#a1bdb877b4c432bd7adb794fd4fa29fc4" title="Pool of threads pointers.">mThreadPool</a>[i]-&gt;<a class="code" href="class_p_a_c_c_1_1_socket_1_1_t_c_p_server.html#ad703bbaa6f6220a338e78ebcc28b9f60" title="Wait for server termination.">wait</a>(<span class="keyword">true</span>);
<a name="l00185"></a>00185     }
<a name="l00186"></a>00186 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a27ed19ee09dc2503886c071edc813cc8"></a><!-- doxytag: member="PACC::Socket::TCPServer::waitForActivity" ref="a27ed19ee09dc2503886c071edc813cc8" args="(double inSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Socket::Port::waitForActivity </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>inSeconds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for activity. </p>
<p>This function waits for any socket activity for up to <code>inSeconds</code> seconds. The three types of activities are: ready for read, ready for write, and pending errors. It returns true if an activity is detected before timeout, and false otherwise. </p>

<p>Definition at line <a class="el" href="_port_8cpp_source.html#l00472">472</a> of file <a class="el" href="_port_8cpp_source.html">Port.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00473"></a>00473 {
<a name="l00474"></a>00474     fd_set lRead, lWrite, lError;
<a name="l00475"></a>00475     FD_ZERO(&amp;lRead);
<a name="l00476"></a>00476     FD_SET(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lRead);
<a name="l00477"></a>00477     FD_ZERO(&amp;lWrite);
<a name="l00478"></a>00478     FD_SET(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lWrite);
<a name="l00479"></a>00479     FD_ZERO(&amp;lError);
<a name="l00480"></a>00480     FD_SET(<a class="code" href="class_p_a_c_c_1_1_socket_1_1_port.html#a11b5de113c588e85c076ea8f7a42600c" title="socket descriptor">mDescriptor</a>, &amp;lError);
<a name="l00481"></a>00481     <span class="keyword">struct </span>timeval lTime;
<a name="l00482"></a>00482     lTime.tv_sec = (long) inSeconds;
<a name="l00483"></a>00483     lTime.tv_usec = (long) ((inSeconds-lTime.tv_sec)*1000000);
<a name="l00484"></a>00484     <span class="keywordflow">return</span> select(FD_SETSIZE, &amp;lRead, &amp;lWrite, &amp;lError, &amp;lTime) == 1;
<a name="l00485"></a>00485 }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PACC/Socket/<a class="el" href="_t_c_p_server_8hpp_source.html">TCPServer.hpp</a></li>
<li>PACC/Socket/<a class="el" href="_t_c_p_server_8cpp_source.html">TCPServer.cpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jan 31 15:10:21 2010 for PACC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
